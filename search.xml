<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Scaleway星辰Stardust纯IPv6服务器体验</title>
    <url>/p/stardust-VPS-in-scalway/</url>
    <content><![CDATA[<p>Stardust是法国云服务器厂商Scaleway下的一款的经济实例。官方介绍是这样的——“A
tiny Instance so powerful and cost effective that we only release it
once a month.”</p>
<p>Stardust可以使用大小为5G的免费硬盘，并带有免费的IPv6地址，因此为了减免费用可以将收费提供的IPv4地址关掉，这样就可以免费使用流量了。</p>
<p>本文主要介绍如何开通Scaleway星辰Stardust服务器，并对其进行一些配置，以便其可以正常使用。</p>
<p>关键词：<strong>Stardust</strong></p>
<span id="more"></span>
<h2 id="开通">开通</h2>
<p>注册地址：<a
href="https://console.scaleway.com/">https://console.scaleway.com/</a></p>
<p>Stardust服务器仅仅在以下地区提供：</p>
<p><img data-src="image-20230204184827546.png" /></p>
<p>由于是限量供应，因此网站常常显示已售罄。</p>
<p><img data-src="image-20230204184955458.png" /></p>
<p>可以通过API进行开通，进而绕过此限制。</p>
<h3 id="安装api">安装API</h3>
<p>下载地址：<a
href="https://github.com/scaleway/scaleway-cli">https://github.com/scaleway/scaleway-cli</a></p>
<p>安装完毕以后需要创建一个token：<a
href="https://console.scaleway.com/project/credentials">https://console.scaleway.com/project/credentials</a>，创建完了以后如下图所示，需要记录<strong>Secret
Key</strong>，该值显示一次。</p>
<p><img data-src="image-20230204185843449.png" /></p>
<p>在cmd或者shell控制台输入<code>scw init</code>，根据提示输入上文记录的Secret
Key.</p>
<p><img data-src="image-20230204190323811.png" /></p>
<h3 id="使用api创建机器">使用API创建机器</h3>
<p>Github的readme提供了很详细的使用说明：<a
href="https://github.com/scaleway/scaleway-cli#reference-documentation">https://github.com/scaleway/scaleway-cli#reference-documentation</a></p>
<figure>
<img data-src="image-20230204190729175.png" alt="image-20230204190729175" />
<figcaption aria-hidden="true">image-20230204190729175</figcaption>
</figure>
<p>我们这里需要使用的是<code>instance CLI</code>，点击CLI并选择<code>Ceate server</code>.</p>
<figure>
<img data-src="image-20230204190904436.png" alt="image-20230204190904436" />
<figcaption aria-hidden="true">image-20230204190904436</figcaption>
</figure>
<p>根据下面表格中列的信息，设置输入的参数</p>
<figure>
<img data-src="image-20230204202125963.png" alt="image-20230204202125963" />
<figcaption aria-hidden="true">image-20230204202125963</figcaption>
</figure>
<p>主要有以下几个参数需要设置</p>
<p>image：服务器镜像，这里使用debian_bullseye, 也可以使用其他</p>
<p>type：服务器类型， 这里使用STARDUST1-S</p>
<p>ip：这里使用none，即不创建IPv4地址</p>
<p>ipv6：这里使用true，创建ipv6地址</p>
<p>zone：地区，默认地区是法国</p>
<p>组合以上参数，在控制台执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scw instance server create image=debian_bullseye <span class="built_in">type</span>=STARDUST1-S ip=none ipv6=<span class="literal">true</span></span><br></pre></td></tr></table></figure>
<figure>
<img data-src="image-20230204203837121.png" alt="image-20230204203837121" />
<figcaption aria-hidden="true">image-20230204203837121</figcaption>
</figure>
<p>说明以及创建成功。</p>
<p>登录后台，查看运行的机器。登录到后台以后发现无法开机器，后来才发现是创建机器的时候没有声明根存储，最小是10G.</p>
<figure>
<img data-src="image-20230204204234274.png" alt="image-20230204204234274" />
<figcaption aria-hidden="true">image-20230204204234274</figcaption>
</figure>
<p>重新执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scw instance server create image=debian_bullseye <span class="built_in">type</span>=STARDUST1-S ip=none ipv6=<span class="literal">true</span> root-volume=b:10G</span><br></pre></td></tr></table></figure>
<p>还是无法开机。说明当前地域资源已用尽。于是切换到另外一个荷兰地区。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scw instance server create image=debian_bullseye <span class="built_in">type</span>=STARDUST1-S ip=none ipv6=<span class="literal">true</span> root-volume=b:10G zone=nl-ams-1</span><br></pre></td></tr></table></figure>
<p>创建成功啦！</p>
<figure>
<img data-src="image-20230204205112843.png" alt="image-20230204205112843" />
<figcaption aria-hidden="true">image-20230204205112843</figcaption>
</figure>
<h2 id="设置机器">设置机器</h2>
<p>注意：需要使用IPv6地址连接。</p>
<figure>
<img data-src="image-20230204205425980.png" alt="image-20230204205425980" />
<figcaption aria-hidden="true">image-20230204205425980</figcaption>
</figure>
<h3 id="访问ipv4网络">访问IPv4网络</h3>
<p>由于常见的网络地址都是IPv4地址，因此需要赋予机器访问IPv4地址的能力。这里有两种方案。</p>
<h4 id="dns64和nat64">DNS64和NAT64</h4>
<p>使用DNS64和NAT64技术，具体可以参考这一篇文章：<a
href="https://developers.google.com/speed/public-dns/docs/dns64?hl=zh-cn">Google
公共 DNS64 | Public DNS | Google Developers</a></p>
<p>简单说就是请求DNS时，将IPv4地址嵌入在IPv6地址里，此时需要有一个支持DNS64服务的DNS。因此只需要将DNS地址更改为支持DNS64服务的地址，就可以实现访问IPv4的网站。</p>
<p>经过我的测试，谷歌的DNS64dns在这一款服务器上无法使用，可能是和网络有关。给出几个可以使用的DNS64服务的地址。</p>
<table>
<colgroup>
<col style="width: 17%" />
<col style="width: 20%" />
<col style="width: 27%" />
<col style="width: 34%" />
</colgroup>
<thead>
<tr class="header">
<th>提供商</th>
<th>国家/城市</th>
<th>DNS64服务</th>
<th>NAT64前缀</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Kasper Dupont</td>
<td>德国/纽伦堡</td>
<td>2a01:4f8:c2c:123f::1</td>
<td>2a01:4f8:c2c:123f:64::/96</td>
</tr>
<tr class="even">
<td>Kasper Dupont</td>
<td>英国/伦敦</td>
<td>2a00:1098:2c::1</td>
<td>2a00:1098:2c::/96</td>
</tr>
<tr class="odd">
<td>Kasper Dupont</td>
<td>荷兰/阿姆斯特丹</td>
<td>2a00:1098:2b::1</td>
<td>2a00:1098:2b::/96</td>
</tr>
</tbody>
</table>
<p>将DNS更改为以上的DNS服务即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/resolv.conf </span><br><span class="line"><span class="comment">## nameserver 2a00:1098:2b::1</span></span><br></pre></td></tr></table></figure>
<p>设置完毕以后发现可以访问github.com了。</p>
<p><img data-src="image-20230205141017958.png" /></p>
<p>但是这种方式也有一定的问题，就是无法访问纯ipv4地址，下面来看第二种方案。</p>
<h4 id="cloudflare-warp">Cloudflare warp</h4>
<p>warp是Cloudflare基于wireguard提供的一款免费软件，可以通过其经过ipv6地址访问ipv4的网站，也可以访问纯ipv4的地址。</p>
<p>可以使用一键脚本，已经开源在GitHub上：<a
href="https://github.com/fscarmen/warp">fscarmen/warp: WARP one-click
script. Add an IPv4, IPv6 or dual-stack CloudFlare WARP network
interface and Socks5 proxy for VPS. 一键脚本 (github.com)</a></p>
<p>根据脚本的提示操作即可。</p>
<p><img data-src="image-20230205152823725.png" /></p>
<p>实测这种方式最方便。</p>
<h2 id="性能测试">性能测试</h2>
<p>安装经典的<code>bench.ch</code>脚本测试以下服务器的性能</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -qO- bench.sh | bash</span><br></pre></td></tr></table></figure>
<figure>
<img data-src="image-20230205153728307.png" alt="image-20230205153728307" />
<figcaption aria-hidden="true">image-20230205153728307</figcaption>
</figure>
<p>相比于<strong>国内某些厂商</strong>提供的服务器，性能还是非常不错的。</p>
<h2 id="账单">账单</h2>
<p>这款机器如果只开IPv6，系统盘设置为最小10G，则每个月只需要不到0.5欧元。还不到人民币五块钱。如果你那里IPv6连接比较好，可以试试这一款服务器。</p>
<p><img data-src="image-20230205154205719.png" /></p>
<p>全文完。</p>
]]></content>
      <tags>
        <tag>VPS</tag>
      </tags>
  </entry>
  <entry>
    <title>配置Unraid</title>
    <url>/p/install-unraid/</url>
    <content><![CDATA[<p><strong>关键词</strong>：Unraid</p>
<span id="more"></span>
<h2 id="下载地址">下载地址</h2>
<p>https://softoroom.org/ptopic89043.html</p>
<h2 id="代理设置">代理设置</h2>
<h3 id="手动配置代理">手动配置代理</h3>
<p>默认的地址在国内无法访问，因此需要先配置代理</p>
<p>编辑<code>/boot/config/go</code>文件，增加下面的选项：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nano /boot/config/go</span><br><span class="line"></span><br><span class="line">http_proxy=http://server:port https_proxy=http://server:port /usr/local/sbin/emhttp &amp; </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;export http_proxy=\&quot;http://server:port\&quot;&quot;</span> &gt;&gt; /root/.bash_profile </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;export https_proxy=\&quot;http://server:port\&quot;&quot;</span> &gt;&gt; /root/.bash_profile</span><br></pre></td></tr></table></figure>
<p>实测还是不行，考虑到插件使用wget安装，因此尝试安装wget代理。编辑/root/.wgetrc文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https_proxy = http://192.168.0.1:20810</span><br><span class="line">http_proxy = http://192.168.0.1:20810</span><br></pre></td></tr></table></figure>
<p>安装成功</p>
<p><img data-src="Unraid配置/image-20240114103116069.png" /></p>
<h3 id="通过插件进行配置代理">通过插件进行配置代理</h3>
<p><a
href="https://forums.unraid.net/topic/132645-proxy-editor-%E6%8F%90%E4%BE%9B%E5%8F%AF%E8%A7%86%E5%8C%96%E9%A1%B5%E9%9D%A2%EF%BC%8C%E6%96%B9%E4%BE%BF%E5%BF%AB%E6%8D%B7%E8%AE%BE%E7%BD%AE%E3%80%81%E5%88%87%E6%8D%A2%E4%BB%A3%E7%90%86/">可视化页面，方便快捷设置、切换代理</a></p>
<h2 id="语言设置">语言设置</h2>
<p>首先安装上文提到的应用商店，然后更新，点击APPS，搜索简体中文。</p>
<p><img data-src="Unraid配置/image-20240114103813917.png" /></p>
<p>点击SETTINGS，选择语言设置</p>
<figure>
<img data-src="Unraid配置/image-20240114103904186.png"
alt="image-20240114103904186" />
<figcaption aria-hidden="true">image-20240114103904186</figcaption>
</figure>
<h2 id="磁盘设置">磁盘设置</h2>
<p>Unraid和他的名字一样，不支持raid，每个磁盘都被认为是一个独立的文件系统。存在一些三种磁盘类型：</p>
<ul>
<li>奇偶检验盘：<strong>unRAID
的校验盘用于保护阵列硬盘的数据，采用奇偶校验机制来实现数据的冗余和重建。有一块校验盘的情况下可以允许阵列中的一块硬盘损毁而不丢失数据；如果有两块校验盘则允许两块硬盘损毁而不丢失数据。</strong>unraid最多支持添加2块校验盘。由于校验盘需要对阵列里面所有硬盘的数据进行计算，因此使用校验盘有一个硬性要求
—— 校验盘的容量一定要大于等于阵列里面最大的那一个硬盘。</li>
<li>阵列盘：存储数据的盘。</li>
<li>缓存盘：根据文件夹的策略将文件从共享文件夹移动到阵列。</li>
</ul>
<p>这里不指定奇偶校验盘，只添加数据盘和缓存盘。</p>
<p><img data-src="Unraid配置/image-20240114113946061.png" /></p>
<p>选中之后点击下列行的启动，使得磁盘阵列打开。</p>
<p>打开之后需要对磁盘进行格式化，点击格式即可。</p>
<figure>
<img data-src="Unraid配置/image-20240114114146245.png"
alt="image-20240114114146245" />
<figcaption aria-hidden="true">image-20240114114146245</figcaption>
</figure>
<h2 id="共享设置">共享设置</h2>
<h3 id="挂载局域网内的其他设备">挂载局域网内的其他设备</h3>
<p>打开app商店，安装Unassigned Devices插件，点击主界面进行操作。</p>
<figure>
<img data-src="Unraid配置/image-20240114115216856.png"
alt="image-20240114115216856" />
<figcaption aria-hidden="true">image-20240114115216856</figcaption>
</figure>
<h3 id="开启自身的nfs服务">开启自身的NFS服务</h3>
<p>打开设置，点击网络设置。</p>
<p><img data-src="Unraid配置/image-20240114115600300.png" /></p>
<h3 id="启动磁盘共享">启动磁盘共享</h3>
<p>启用磁盘共享可以跳过unraid的shfs的子系统，极大的提高拷贝性能。</p>
<p>打开磁盘共享之前需要关闭阵列。</p>
<blockquote>
<p>https://www.jackiewu.top/article/why-unraid-cpu-overloaded-when-downloading-or-writing-files</p>
</blockquote>
<p><img data-src="Unraid配置/image-20240114131747723.png" /></p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes集群实践（十四）tini进程管理器</title>
    <url>/p/have-a-look-at-tini/</url>
    <content><![CDATA[<p>本文主要介绍tini进程管理器。</p>
<p>关键词：<strong>k8s，tini</strong></p>
<span id="more"></span>
<h2 id="背景">背景</h2>
<p>Linux系统中，PID为1的进程承担了两个重要的使命：</p>
<ol type="1">
<li><p>传递信号给子进程</p>
<p>如果pid为1的进程，无法向其子进程传递信号，可能导致容器发送SIGTERM信号后，父进程等待子进程退出。若此时父进程无法传递信号到子进程，整个容器无法正常退出，除非向父进程传递SIGKILL信号，使其强行退出。<strong>而这样会导致一些退出前的操作无法完成，如关闭数据库连接，关闭输入输出流等。</strong></p></li>
<li><p>接管孤儿进程，防止出现僵尸进程</p>
<p>如果一个进程A中运行了一个子进程B，而子进程B创建了一个子进程C，若此时子进程B异常退出（通过SIGKILL信号，并不会发送SIGKILL信号给进程C），此时进程C会被进程A接管。<strong>进程A不会传递信号到进程C，这就导致了进程B结束了，但是没有回收其子进程C，子进程C就变成了僵尸进程。</strong></p></li>
</ol>
<p>在docker中，<code>docker stop</code>会发送<code>SIGTERM</code>信号给容器的主进程来处理。如果主进程没有处理这个信号，docker会在等待10s后，发送<code>SIGKILL</code>信号来强制终止。</p>
<h2 id="tini介绍">tini介绍</h2>
<p>tini是一个轻量级init进程，被设计作为容器的1号进程。</p>
<p>tini只会做以下事情：</p>
<ul>
<li>生成一个进程，并等待它退出；</li>
<li>收割僵尸进程；</li>
<li>执行信号转发。</li>
</ul>
<p>tini被设计为一个服务于容器的单进程管理器，通常只能管理一个进程。一般情况下，服务容器化要求一个容器尽量只作为一件事情，即只有一个进程或一组进程。</p>
<p>tini编译产物只有一个可执行文件，其静态版本不依赖其他软件，可以在任意发行版中使用。</p>
<h2 id="tini使用">tini使用</h2>
<blockquote>
<p><a
href="https://github.com/krallin/tini#using-tini">README#using-tini</a></p>
</blockquote>
<p>直接把tini打包到镜像中，配置<code>ENTRYPOINT</code>为<code>["/tini", "--"]</code>。选项要加在<code>--</code>前面，例如：<code>["/tini", "-vvv", "--"]</code></p>
<h2 id="tini优势">tini优势</h2>
<p>通过tini可以避免业务进程重复编写本来由1号进程该做的事情，帮助传统的应用可以无感迁移到容器化部署。</p>
<ol type="1">
<li>防止僵尸进程的产生。如果业务进程作为容器的1号进程，且没有等待子进程退出的逻辑，则可能会产生僵尸进程。</li>
<li>实现优雅退出。如果业务进程作为容器的1号进程，且没有处理信号的逻辑，当1号进程收到信号时，什么都不做。<strong>因为PID
1它会忽略具有默认操作的任何信号</strong>，除非实现了监听 SIGTERM
信号的逻辑。</li>
<li>docker ce发行版默认包含tini。只需要docker
run的是添加<code>--init</code>选项即可，不需要改变镜像，不需要添加entrypoint和command。</li>
</ol>
<blockquote>
<p>shell可以处理僵尸进程，但无法做到优雅推出。shell作为PID1进程时不会将信号转发给子进程。</p>
</blockquote>
<h2 id="tini实践">tini实践</h2>
<p>通过<code>ENTRYPOINT</code>启动<code>tini</code>作为进程管理器，然后再通过<code>tini</code>运行CMD指定的程序命令</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos:<span class="number">7</span></span><br><span class="line"><span class="keyword">ENV</span> ADMIN_PASSWD admin</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash">  <span class="built_in">set</span> -ex \</span></span><br><span class="line"><span class="language-bash">&amp;&amp; sed -e <span class="string">&#x27;s|^mirrorlist=|#mirrorlist=|g&#x27;</span> \</span></span><br><span class="line"><span class="language-bash">  -e <span class="string">&#x27;s|^#baseurl=http://mirror.centos.org/centos|baseurl=https://mirrors.nju.edu.cn/centos|g&#x27;</span> \</span></span><br><span class="line"><span class="language-bash">  -i.bak \</span></span><br><span class="line"><span class="language-bash">  /etc/yum.repos.d/CentOS-Base.repo \</span></span><br><span class="line"><span class="language-bash">&amp;&amp; yum clean all \</span></span><br><span class="line"><span class="language-bash">&amp;&amp; yum -y update \</span></span><br><span class="line"><span class="language-bash">&amp;&amp; yum install -y net-tools iproute openssh-clients openssh-server <span class="built_in">which</span> sudo \</span></span><br><span class="line"><span class="language-bash">&amp;&amp; groupadd -g 500 admin \</span></span><br><span class="line"><span class="language-bash">&amp;&amp; useradd -g 500 -u 500 -d /home/admin -m admin \</span></span><br><span class="line"><span class="language-bash">&amp;&amp; <span class="built_in">echo</span> <span class="variable">$&#123;ADMIN_PASSWD&#125;</span> | passwd admin --stdin \</span></span><br><span class="line"><span class="language-bash">&amp;&amp; <span class="built_in">echo</span> <span class="string">&#x27;admin ALL=(ALL) NOPASSWD:ALL&#x27;</span> &gt;&gt; /etc/sudoers</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> TINI_VERSION v0.<span class="number">19.0</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> tini /tini</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">chmod</span> +x /tini</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;/tini&quot;</span>, <span class="string">&quot;--&quot;</span>]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --<span class="built_in">chown</span>=admin:admin spring-petclinic-3.1.0-SNAPSHOT.jar entrypoint.sh /home/admin/</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">chmod</span> +x /home/admin/entrypoint.sh</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> amazon-corretto-17-x64-linux-jdk.rpm /tmp/</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">set</span> -ex \</span></span><br><span class="line"><span class="language-bash">&amp;&amp; yum localinstall -y /tmp/amazon-corretto-17-x64-linux-jdk.rpm  \</span></span><br><span class="line"><span class="language-bash">&amp;&amp; <span class="built_in">rm</span> -rf /tmp/*</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> ssh-keygen -A</span></span><br><span class="line"><span class="comment"># Run your program under Tini</span></span><br><span class="line"><span class="comment"># CMD [&quot;/your/program&quot;, &quot;-and&quot;, &quot;-its&quot;, &quot;arguments&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">USER</span> admin</span><br><span class="line"><span class="keyword">ENV</span> PATH $&#123;PATH&#125;:/usr/local/bin:/usr/sbin</span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;/home/admin/entrypoint.sh&quot;</span>]</span></span><br></pre></td></tr></table></figure>
<p>下面是<code>entrypoint.sh</code>文件的内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/env bash</span></span><br><span class="line">sudo /usr/sbin/sshd &amp;</span><br><span class="line">/usr/bin/java -jar /home/admin/spring-petclinic-3.1.0-SNAPSHOT.jar</span><br></pre></td></tr></table></figure>
<p><code>tini</code>作为容器里的1号进程，首先启动了一个<code>sshd</code>进程，进程号为17，使得从容器外部可以连接到内部。然后启动了一个<code>java</code>进程，进程号为7。</p>
<p><code>tini</code>作为容器中的init进程，可以启动多个进程。同时还可以将信号转发给子进程，实现优雅启停；等待子进程退出，回收子进程占用的资源和进程号，防止出现僵尸进程。</p>
<p><img data-src="image-20231028204307022.png" /></p>
<h2 id="拓展">拓展</h2>
<h3 id="容器中的僵尸进程">容器中的僵尸进程</h3>
<p>当容器的1号进程无法将信号转发到子进程时，就会出现僵尸进程，下面演示一下。</p>
<p>启动一个python3容器，然后通过exec方式进入容器</p>
<p><img data-src="image-20231028210521553.png" /></p>
<p>后台启动一个sleep任务，此时该sleep进程是通过内核init方式创建的bash进行的子进程</p>
<p><img data-src="image-20231028210625820.png" /></p>
<p>此时使用ctrl+d退出容器，bash进程被杀死，而后台运行的sleep进程仍然存活，sleep进程的父进程变为python3。当任务结束后，子进程sleep
100需要将状态码等一系列信息返回给父进程python3，然而父进程并没有调用waitpid()等函数获取子进程的返回值等信息，此时子进程就成为了僵尸进程，无法释放pid等资源。只要pid为1的进程不结束，资源就无法得到释放。</p>
<p><img data-src="image-20231028211650582.png" /></p>
]]></content>
      <tags>
        <tag>tini</tag>
      </tags>
  </entry>
  <entry>
    <title>RHCE学习教程之Ansible运维基础</title>
    <url>/p/learn-rhce-and-ansible/</url>
    <content><![CDATA[<p>ansible是自动化运维利器，可以通过一台Linux服务器批量控制其他服务器。</p>
<p>本文主要介绍RHCE学习中的一些知识点，主要包含ansible的一些用法。</p>
<p><strong>关键词：RHCE Ansible</strong></p>
<span id="more"></span>
<h2 id="配置文件优先级">配置文件优先级</h2>
<ol type="1">
<li><code>ANSIBLE_CONFIG</code>环境变量；</li>
<li>当前<code>/home</code>目录下ansible.cfg；</li>
<li><code>/home</code>目录下.ansible.cfg（隐藏文件）；</li>
<li><code>/etc/absible/ansible.cfg</code></li>
</ol>
<h2 id="配置非root用户提权">配置非root用户提权</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[defaults]         </span><br><span class="line">inventory= ./hosts   //自定义被控主机清单文件，这里叫hosts</span><br><span class="line">remote_user= alice   //被控主机使用的账户，如果不用普通用户则无需本行以及后续配置</span><br><span class="line">[privilege_escalation]  //提升权限的配置</span><br><span class="line">become=True    //是否要提权  True是要提权</span><br><span class="line">become_method=sudo   //提权方式用sudo</span><br><span class="line">become_user=root   //提权时成为root</span><br><span class="line">become_ask_pass=False   //提权操作时无需密码</span><br></pre></td></tr></table></figure>
<p>想不起来使用下面的命令，可以生成默认的配置文件，然后根据提示取消相应的注释。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ansible-config init &gt; ansible.cfg</span><br></pre></td></tr></table></figure>
<h2 id="配置hosts">配置Hosts</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[test01] //组名</span><br><span class="line">node1   </span><br><span class="line">[test02]</span><br><span class="line">node2</span><br><span class="line">[web]</span><br><span class="line">node[3:4] //组名精简写法</span><br><span class="line">[test05]</span><br><span class="line">node5</span><br><span class="line">[webserver:children] //children关键字，代表嵌套组，webserver包含下面的组</span><br><span class="line">web</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="常见方式">常见方式</h2>
<h3 id="命令方式">命令方式</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ansible all -m ping</span><br><span class="line">ansible all -m <span class="built_in">command</span> -a <span class="string">&#x27;ls /opt/abc.txt&#x27;</span>  // 不支持管道，默认模块</span><br><span class="line">ansible all -m shell -a <span class="string">&#x27;echo &quot;nameserver 1.1.1.1&quot; &gt;&gt; /etc/reslove.conf&#x27;</span> // 支持管道</span><br><span class="line">ansible node1 -m shell -a <span class="string">&#x27;echo 123 | passwd --stdin tom&#x27;</span> // 支持管道，设置密码</span><br><span class="line">ansible node1 -m script -a <span class="string">&#x27;test.sh&#x27;</span> // 将脚本上传到节点执行</span><br></pre></td></tr></table></figure>
<h3 id="playbook方式">playbook方式</h3>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">all</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ping</span> <span class="string">test</span></span><br><span class="line">      <span class="attr">ping:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ping</span> <span class="string">test</span></span><br><span class="line">      <span class="attr">command:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        echo &#x27;ok&#x27; /tmp/ok</span></span><br><span class="line"><span class="string"></span>    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">resolv</span></span><br><span class="line">      <span class="attr">command:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        echo &quot;nameserver 1.1.1.1&quot; &gt;&gt; /etc/resolv.conf</span></span><br><span class="line"><span class="string"></span>    <span class="bullet">-</span> <span class="attr">shell:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        echo 123 | passwd --stdin tom</span></span><br><span class="line"><span class="string"></span>    <span class="bullet">-</span> <span class="attr">script:</span> <span class="string">|</span></span><br><span class="line">        <span class="string">test.sh</span></span><br></pre></td></tr></table></figure>
<h2 id="常见模块">常见模块</h2>
<p>refer：https://docs.ansible.com/ansible/latest/collections/ansible/builtin/</p>
<h3 id="file模块">file模块</h3>
<p>一般用来创建文件、目录、链接文件，以及删除文件</p>
<table>
<colgroup>
<col style="width: 7%" />
<col style="width: 92%" />
</colgroup>
<thead>
<tr class="header">
<th>参数</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>path</td>
<td>路径</td>
</tr>
<tr class="even">
<td>state</td>
<td>执行动作。touch：创建普通文件，directory是目录，link是链接文件（src是源，dest是目标），absent是删除</td>
</tr>
<tr class="odd">
<td>owner</td>
<td>属主</td>
</tr>
<tr class="even">
<td>group</td>
<td>属组</td>
</tr>
<tr class="odd">
<td>mode</td>
<td>权限</td>
</tr>
</tbody>
</table>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ansible node1 -m file -a <span class="string">&#x27;state=touch path=/opt/123&#x27;</span></span><br><span class="line">ansible node1 -m file -a <span class="string">&#x27;state=directory path=/opt/456 &#x27;</span></span><br><span class="line">ansible node1 -m file -a <span class="string">&#x27;state=link src=/etc/hosts dest=/var/tmp/hosts&#x27;</span></span><br><span class="line">ansible node1 -m file -a <span class="string">&#x27;state=absent path=/opt/123&#x27;</span></span><br><span class="line">ansible node1 -m file -a <span class="string">&#x27;state=touch path=/opt/123 owner=alice&#x27;</span></span><br><span class="line">ansible node1 -m file -a <span class="string">&#x27;state=touch path=/opt/123 group=alice&#x27;</span></span><br><span class="line">ansible node1 -m file -a <span class="string">&#x27;state=touch path=/opt/123 mode=4777&#x27;</span></span><br></pre></td></tr></table></figure>
<p>playbook</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">all</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">file:</span></span><br><span class="line">        <span class="attr">state:</span> <span class="string">touch</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/opt/123</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">file:</span></span><br><span class="line">        <span class="attr">state:</span> <span class="string">directory</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/opt/456</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">file:</span></span><br><span class="line">        <span class="attr">state:</span> <span class="string">link</span></span><br><span class="line">        <span class="attr">src:</span> <span class="string">/etc/hosts</span></span><br><span class="line">        <span class="attr">dest:</span> <span class="string">/var/tmp/hosts</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">file:</span></span><br><span class="line">        <span class="attr">state:</span> <span class="string">absent</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/opt/123</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">file:</span></span><br><span class="line">        <span class="attr">state:</span> <span class="string">touch</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/opt/456</span></span><br><span class="line">        <span class="attr">owner:</span> <span class="string">alice</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">file:</span></span><br><span class="line">        <span class="attr">state:</span> <span class="string">touch</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/opt/1234</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">alice</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">file:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/opt/1234</span></span><br><span class="line">        <span class="attr">mode:</span> <span class="number">4777</span></span><br></pre></td></tr></table></figure>
<h3 id="yum_repository模块">yum_repository模块</h3>
<p>为被控主机搭建yum仓库，记不住yum后面的文字可以先使用<code>ansible-doc -l | grep yum</code>，再使用<code>ansible-doc yum_repository</code></p>
<table>
<thead>
<tr class="header">
<th>参数</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>name</td>
<td>仓库名</td>
</tr>
<tr class="even">
<td>description</td>
<td>描述</td>
</tr>
<tr class="odd">
<td>file</td>
<td>yum配置文件的名字</td>
</tr>
<tr class="even">
<td>baseurl</td>
<td>软件源地址</td>
</tr>
<tr class="odd">
<td>gpgcheck</td>
<td>gpgkey检测</td>
</tr>
<tr class="even">
<td>gpgkey</td>
<td>如果检测key，指定key路径</td>
</tr>
<tr class="odd">
<td>enabled</td>
<td>是否开启，默认值为1是开启</td>
</tr>
</tbody>
</table>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ansible all -m yum_repository -a <span class="string">&#x27;name=appstream description=appstrem baseurl=http://172.25.0.254/rhel9/AppStream gpgcheck=0&#x27;</span></span><br><span class="line">ansible all -m yum_repository -a <span class="string">&#x27;name=baseos description=baseos baseurl=http://172.25.0.254/rhel9/BaseOS gpgcheck=0&#x27;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">all</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">yum_repository:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">appstream</span></span><br><span class="line">        <span class="attr">description:</span> <span class="string">appstream</span></span><br><span class="line">        <span class="attr">baseurl:</span> <span class="string">http://172.25.0.254/rhel9/AppStream</span></span><br><span class="line">        <span class="attr">gpgcheck:</span> <span class="number">0</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">yum_repository:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">baseos</span></span><br><span class="line">        <span class="attr">description:</span> <span class="string">baseos</span></span><br><span class="line">        <span class="attr">baseurl:</span> <span class="string">http://172.25.0.254/rhel9/BaseOS</span></span><br><span class="line">        <span class="attr">gpgcheck:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h3 id="yum模块">yum模块</h3>
<p>使用yum安装软件</p>
<table>
<thead>
<tr class="header">
<th>参数</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>state</td>
<td>present/安装，absent/卸载，latest/升级</td>
</tr>
<tr class="even">
<td>name</td>
<td>指定软件包名</td>
</tr>
</tbody>
</table>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">all</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">yum:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">net-tools</span></span><br><span class="line">        <span class="attr">state:</span> <span class="string">latest</span></span><br></pre></td></tr></table></figure>
<h3 id="copy模块">Copy模块</h3>
<p>将控制主机的文件拷贝到被控主机</p>
<table>
<thead>
<tr class="header">
<th>参数</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>src</td>
<td>源文件</td>
</tr>
<tr class="even">
<td>dest</td>
<td>目标</td>
</tr>
<tr class="odd">
<td>owner</td>
<td>属主</td>
</tr>
<tr class="even">
<td>group</td>
<td>属组</td>
</tr>
<tr class="odd">
<td>mode</td>
<td>权限</td>
</tr>
<tr class="even">
<td>backup</td>
<td>backup=yes，拷贝时备份控制主机的同名文件，防止被覆盖</td>
</tr>
</tbody>
</table>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ansible node1 -m copy dest=/etc/hostname src=/var/tmp/hostname owner=alice mode=1777 backup=<span class="built_in">yes</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">- hosts: node1</span><br><span class="line">  tasks:</span><br><span class="line">    - copy:</span><br><span class="line">        src: /etc/hostname</span><br><span class="line">        dest: /var/tmp/hostname</span><br><span class="line">        owner: alice</span><br><span class="line">        mode: 1777</span><br><span class="line">        backup: <span class="built_in">yes</span></span><br></pre></td></tr></table></figure>
<h3 id="user模块">User模块</h3>
<p>管理账户的模块</p>
<table>
<thead>
<tr class="header">
<th>参数</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>state</td>
<td>present/创建，absent/删除</td>
</tr>
<tr class="even">
<td>name</td>
<td>名字</td>
</tr>
<tr class="odd">
<td>uid</td>
<td>定义uid号</td>
</tr>
<tr class="even">
<td>password</td>
<td>定义密码</td>
</tr>
<tr class="odd">
<td>group</td>
<td>基本组</td>
</tr>
<tr class="even">
<td>groups</td>
<td>附加组</td>
</tr>
<tr class="odd">
<td>append</td>
<td>append=yes，追加附加组</td>
</tr>
<tr class="even">
<td>remove</td>
<td>remove=yes，删除用户相关文件</td>
</tr>
</tbody>
</table>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ansible node1 -m user -a <span class="string">&#x27;name=zhangsan state=absent remove=yes&#x27;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">all</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">user:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">wf09</span></span><br><span class="line">        <span class="attr">uid:</span> <span class="number">101</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">&#x27;<span class="template-variable">&#123;&#123;&quot;123456&quot;|password_hash(&quot;sha256&quot;)&#125;&#125;</span>&#x27;</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">wf09</span></span><br><span class="line">        <span class="attr">groups:</span> <span class="string">admin</span></span><br><span class="line">        <span class="attr">state:</span> <span class="string">present</span></span><br><span class="line">        <span class="attr">append:</span> <span class="literal">yes</span></span><br></pre></td></tr></table></figure>
<h3 id="group模块">Group模块</h3>
<p>管理组</p>
<table>
<thead>
<tr class="header">
<th>参数</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>state</td>
<td>present/创建，absent/删除</td>
</tr>
<tr class="even">
<td>name</td>
<td>组名</td>
</tr>
<tr class="odd">
<td>gid</td>
<td>gid组号</td>
</tr>
</tbody>
</table>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">all</span></span><br><span class="line">  <span class="attr">tasks:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">group:</span> </span><br><span class="line">        <span class="attr">state:</span> <span class="string">present</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">wf09</span></span><br><span class="line">        <span class="attr">gid:</span> <span class="number">101</span></span><br></pre></td></tr></table></figure>
<h3 id="service模块">Service模块</h3>
<p>管理服务</p>
<table>
<thead>
<tr class="header">
<th>参数</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>state</td>
<td>started/开启服务，stopped/关闭服务，restarted/重启服务</td>
</tr>
<tr class="even">
<td>name</td>
<td>服务名</td>
</tr>
</tbody>
</table>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">all</span></span><br><span class="line">  <span class="attr">tasks:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">service:</span> </span><br><span class="line">        <span class="attr">state:</span> <span class="string">restarted</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">httpd</span></span><br></pre></td></tr></table></figure>
<h3 id="安装collection">安装collection</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vim ansible.cfg</span></span><br><span class="line">collections_paths=/home/alice/ansible/collection</span><br><span class="line"><span class="comment"># 官方网站 https://galaxy.ansible.com</span></span><br><span class="line"><span class="comment"># bash执行</span></span><br><span class="line">ansible-galaxy collection install http://server1.lab0.example.com/materials/ansible-posix-1.5.1.tar.gz  -p /home/alice/ansible/collection</span><br><span class="line"><span class="comment"># 查看firewalld</span></span><br><span class="line">ansible-doc ansible.posix.firewalld</span><br></pre></td></tr></table></figure>
<p><strong>pip 模块</strong></p>
<p>python的包管理模块</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">all</span></span><br><span class="line">  <span class="attr">tasks:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">pip:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">firewalld</span></span><br></pre></td></tr></table></figure>
<p>用firewall之前还需要用yum安装firewalld安装包。</p>
<h3 id="firewalld模块">firewalld模块</h3>
<p>管理防火墙</p>
<table>
<thead>
<tr class="header">
<th>参数</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>state</td>
<td>enabled/添加规则，disabled/删除规则</td>
</tr>
<tr class="even">
<td>service</td>
<td>指定服务（协议）</td>
</tr>
<tr class="odd">
<td>permanent</td>
<td>permanent=yes，永久生效</td>
</tr>
<tr class="even">
<td>immediate</td>
<td>immediate=yes，立刻生效</td>
</tr>
<tr class="odd">
<td>port</td>
<td>22</td>
</tr>
</tbody>
</table>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">--- </span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">all</span></span><br><span class="line">  <span class="attr">tasks:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">firewalld:</span></span><br><span class="line">        <span class="attr">state:</span> <span class="string">enabled</span></span><br><span class="line">        <span class="attr">service:</span> <span class="string">http</span></span><br><span class="line">        <span class="attr">permanent:</span> <span class="literal">yes</span></span><br><span class="line">        <span class="attr">immediate:</span> <span class="literal">yes</span></span><br></pre></td></tr></table></figure>
<h3 id="parted模块">parted模块</h3>
<p>对硬盘分区</p>
<table>
<thead>
<tr class="header">
<th>参数</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>device</strong></td>
<td>操作的设备</td>
</tr>
<tr class="even">
<td><strong>label</strong></td>
<td>分区表类型 mbr/msdos， gpt</td>
</tr>
<tr class="odd">
<td><strong>number</strong></td>
<td>分区序号</td>
</tr>
<tr class="even">
<td><strong>part_start</strong></td>
<td>分区起始位置</td>
</tr>
<tr class="odd">
<td><strong>part_end</strong></td>
<td>分区结束位置</td>
</tr>
<tr class="even">
<td><strong>state</strong></td>
<td><strong>present/创建，absent/删除，info/查看信息</strong></td>
</tr>
</tbody>
</table>
<p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">node5</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">parted:</span></span><br><span class="line">        <span class="attr">state:</span> <span class="string">present</span></span><br><span class="line">        <span class="attr">device:</span> <span class="string">/dev/vdb</span></span><br><span class="line">        <span class="attr">number:</span> <span class="number">2</span></span><br><span class="line">        <span class="attr">part_start:</span> <span class="string">3GiB</span></span><br><span class="line">        <span class="attr">part_end:</span> <span class="string">4GiB</span></span><br></pre></td></tr></table></figure></p>
<h3 id="filesystem模块">filesystem模块</h3>
<p>赋予文件系统</p>
<table>
<thead>
<tr class="header">
<th>参数</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>dev</td>
<td>定义分区</td>
</tr>
<tr class="even">
<td>fstype</td>
<td>分区表类型 mbr/msdos， gpt</td>
</tr>
<tr class="odd">
<td><strong>number</strong></td>
<td>分区序号</td>
</tr>
<tr class="even">
<td><strong>part_start</strong></td>
<td>分区起始位置</td>
</tr>
<tr class="odd">
<td><strong>part_end</strong></td>
<td>分区结束位置</td>
</tr>
<tr class="even">
<td><strong>state</strong></td>
<td><strong>present/创建，absent/删除，info/查看信息</strong></td>
</tr>
</tbody>
</table>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">node5</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">filesystem:</span></span><br><span class="line">        <span class="attr">dev:</span> <span class="string">/dev/vdb2</span></span><br><span class="line">        <span class="attr">fstype:</span> <span class="string">xfs</span></span><br><span class="line">        <span class="attr">force:</span> <span class="literal">yes</span></span><br></pre></td></tr></table></figure>
<h3 id="lvg模块">lvg模块</h3>
<p>管理卷组</p>
<table>
<thead>
<tr class="header">
<th>参数</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>state</td>
<td>present/创建，absent/删除</td>
</tr>
<tr class="even">
<td>vg</td>
<td>卷组名</td>
</tr>
<tr class="odd">
<td>pvs</td>
<td>指定物理卷</td>
</tr>
</tbody>
</table>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">node5</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">lvg:</span></span><br><span class="line">        <span class="attr">vg:</span> <span class="string">myvg</span></span><br><span class="line">        <span class="attr">pvs:</span> <span class="string">/dev/vdb2</span></span><br></pre></td></tr></table></figure>
<h3 id="lvol模块">lvol模块</h3>
<p>管理卷组</p>
<table>
<thead>
<tr class="header">
<th>参数</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>lv</td>
<td>逻辑卷名</td>
</tr>
<tr class="even">
<td>size</td>
<td>大小</td>
</tr>
<tr class="odd">
<td>vg</td>
<td>空间来自哪个卷组</td>
</tr>
<tr class="even">
<td>state</td>
<td>present/创建，absent/删除</td>
</tr>
<tr class="odd">
<td>force</td>
<td>是否强制</td>
</tr>
</tbody>
</table>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">node5</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">lvol:</span></span><br><span class="line">        <span class="attr">lv:</span> <span class="string">mylv</span></span><br><span class="line">        <span class="attr">size:</span> <span class="string">50m</span></span><br><span class="line">        <span class="attr">vg:</span> <span class="string">myvg</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">node5</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">lvol:</span></span><br><span class="line">        <span class="attr">lv:</span> <span class="string">mylv</span></span><br><span class="line">        <span class="attr">size:</span> <span class="string">500m</span> <span class="comment"># 再次执行扩容</span></span><br><span class="line">        <span class="attr">vg:</span> <span class="string">myvg</span></span><br></pre></td></tr></table></figure>
<h3 id="lineinfile模块">lineinfile模块</h3>
<table>
<thead>
<tr class="header">
<th>参数</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>dest</strong></td>
<td>目标文件</td>
</tr>
<tr class="even">
<td><strong>regexp</strong></td>
<td>查找替换内容</td>
</tr>
<tr class="odd">
<td><strong>line</strong></td>
<td>要替换/添加什么内容</td>
</tr>
<tr class="even">
<td><strong>insertbefore</strong></td>
<td>在某行上添加</td>
</tr>
<tr class="odd">
<td><strong>insertafter</strong></td>
<td>在某行下添加</td>
</tr>
</tbody>
</table>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">all</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">copy:</span></span><br><span class="line">        <span class="attr">src:</span> <span class="string">./txt</span></span><br><span class="line">        <span class="attr">dest:</span> <span class="string">/tmp/txt</span></span><br><span class="line">        <span class="attr">owner:</span> <span class="string">alice</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">all</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">lineinfile:</span></span><br><span class="line">        <span class="attr">dest:</span> <span class="string">/tmp/txt</span></span><br><span class="line">        <span class="attr">regexp:</span> <span class="string">txt</span></span><br><span class="line">        <span class="attr">line:</span> <span class="string">abc</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">all</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">shell:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        cat /tmp/txt</span></span><br><span class="line"><span class="string"></span>      <span class="attr">register:</span> <span class="string">info</span> <span class="comment"># 注册变量</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line">        <span class="attr">var:</span> <span class="string">info.stdout</span></span><br></pre></td></tr></table></figure>
<h3 id="replace模块">replace模块</h3>
<p>可以替换文档中的某些字符串</p>
<table>
<thead>
<tr class="header">
<th>参数</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>path</strong></td>
<td>要替换文件的路径</td>
</tr>
<tr class="even">
<td><strong>regexp</strong></td>
<td>要匹配的内容</td>
</tr>
<tr class="odd">
<td><strong>replace</strong></td>
<td>要替换/添加什么内容</td>
</tr>
<tr class="even">
<td><strong>backup</strong></td>
<td>是否要备份</td>
</tr>
</tbody>
</table>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">all</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">replace:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/home/zabbix/etc/zabbix_agentd.conf</span></span><br><span class="line">        <span class="attr">regexp:</span> <span class="string">Server=.*</span></span><br><span class="line">        <span class="attr">replace:</span> <span class="string">Server=1.1.1.1</span></span><br><span class="line">        <span class="attr">backup:</span> <span class="literal">no</span></span><br></pre></td></tr></table></figure>
<h3 id="debug模块">debug模块</h3>
<p>可以输出常量字符，或者变量中的信息</p>
<table>
<thead>
<tr class="header">
<th>参数</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>msg</strong></td>
<td>输出常量字符串，如果是变量要加<code>&#123;&#123; &#125;&#125;</code></td>
</tr>
<tr class="even">
<td><strong>var</strong></td>
<td>输出变量，无需<code>&#123;&#123;&#125;&#125;</code></td>
</tr>
</tbody>
</table>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">all</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line">        <span class="attr">msg:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123;ansible_memfree_mb&#125;&#125;</span>&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line">        <span class="attr">var:</span> <span class="string">ansible_memfree_mb</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line">        <span class="attr">msg:</span> <span class="string">ok</span></span><br></pre></td></tr></table></figure>
<h3 id="setup模块">setup模块</h3>
<p>可以获取被控主机的各自信息并定义成变量</p>
<p>查看某个node的变量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ansible node1 -m setup | less</span><br></pre></td></tr></table></figure>
<table>
<colgroup>
<col style="width: 61%" />
<col style="width: 38%" />
</colgroup>
<thead>
<tr class="header">
<th>变量</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>ansible_enp1s0.ipv4.address</strong></td>
<td>enp1s0网卡的ipv4地址</td>
</tr>
<tr class="even">
<td><strong>ansible_hostname</strong></td>
<td>主机名</td>
</tr>
<tr class="odd">
<td><strong>ansible_memfree_mb</strong></td>
<td>内存剩余大小</td>
</tr>
<tr class="even">
<td><strong>ansible_fqdn</strong></td>
<td>完整主机名</td>
</tr>
<tr class="odd">
<td><strong>ansible_bios_version</strong></td>
<td>bios版本</td>
</tr>
<tr class="even">
<td><strong>ansible_devices.vda.size</strong></td>
<td><strong>第一块硬盘大小</strong></td>
</tr>
<tr class="odd">
<td><strong>ansible_devices.vda.partitions.vda1.size</strong></td>
<td><strong>第一块硬盘第一个分区大小</strong></td>
</tr>
<tr class="even">
<td><strong>ansible_lvm.lvs.root.size_g</strong></td>
<td><strong>逻辑卷root的大小</strong></td>
</tr>
<tr class="odd">
<td><strong>ansible_kernel</strong></td>
<td><strong>内核版本信息</strong></td>
</tr>
</tbody>
</table>
<p>关闭剧本默认执行的变量收集任务</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">node1</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">no</span>		<span class="string">//关闭setup任务，可以加快剧本运行速度</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line"><span class="attr">msg:</span> <span class="string">&quot;ok&quot;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>learning</tag>
        <tag>ansible</tag>
      </tags>
  </entry>
  <entry>
    <title>RHCE学习教程之Ansible高级用法</title>
    <url>/p/advanced-usage-about-ansible/</url>
    <content><![CDATA[<p>ansible是自动化运维利器，可以通过一台Linux服务器批量控制其他服务器。</p>
<p>本文主要介绍ansible的一些高级用法。</p>
<p><strong>关键词：RHCE Ansible</strong></p>
<span id="more"></span>
<h2 id="自定义变量">自定义变量</h2>
<h3 id="主机清单变量">主机清单变量</h3>
<p>针对主机或者组</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment">;针对主机</span></span><br><span class="line"><span class="section">[paas]</span></span><br><span class="line">1.2.4.8 <span class="attr">hostname</span>=<span class="number">1.2</span>.<span class="number">4.8</span>-master01</span><br><span class="line"></span><br><span class="line"><span class="comment">;针对组</span></span><br><span class="line"><span class="comment">;同一组可以使用相同的环境变量</span></span><br><span class="line"><span class="section">[web]</span></span><br><span class="line">1.1.1.1</span><br><span class="line">2.2.2.2</span><br><span class="line">3.3.3.3</span><br><span class="line"><span class="section">[web:vars]</span></span><br><span class="line"><span class="attr">ansible_ssh_user</span>=root</span><br><span class="line"><span class="attr">ansible_ssh_pass</span>=root1234</span><br></pre></td></tr></table></figure>
<h3 id="定义剧本变量">定义剧本变量</h3>
<p>使用关键字vars，针对所有执行剧本的主机生效</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">node1,</span> <span class="string">node2</span></span><br><span class="line">  <span class="attr">vars:</span></span><br><span class="line">    <span class="attr">test01:</span> <span class="string">aaa</span></span><br><span class="line">    <span class="attr">test02:</span> <span class="string">bbb</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">debug:</span> </span><br><span class="line">        <span class="attr">msg:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123; test01 &#125;&#125;</span>--<span class="template-variable">&#123;&#123; test02 &#125;&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="定义文档变量">定义文档变量</h3>
<p>可以在执行剧本时进行调用</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># var.yml</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">abc:</span> <span class="string">abcabc</span></span><br><span class="line"><span class="attr">xyz:</span> <span class="string">xyzxyz</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># test01.yml</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">node1</span></span><br><span class="line">  <span class="attr">var_files:</span> <span class="string">var01.yml</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line">        <span class="attr">msg:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123;abc&#125;&#125;</span> <span class="template-variable">&#123;&#123;xyz&#125;&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="以交互方式定义变量">以交互方式定义变量</h3>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">node1</span></span><br><span class="line">  <span class="comment"># 交互定义变量关键词</span></span><br><span class="line">  <span class="attr">vars_prompt:</span>    </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">var1</span></span><br><span class="line">      <span class="attr">prompt:</span> <span class="string">&quot;输入要创建的用户名&quot;</span></span><br><span class="line">      <span class="comment"># 不隐藏变量的值</span></span><br><span class="line">      <span class="attr">private:</span> <span class="literal">no</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line">        <span class="attr">var:</span> <span class="string">var1</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">user:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123;var1&#125;&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="魔法变量">魔法变量</h3>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">inventory_hostname</span>=清单主机名</span><br><span class="line"><span class="attr">hostvars</span>=包含被控主机的所有变量</span><br><span class="line"><span class="attr">hostvars.node1</span>=只调用node1主机的所有变量</span><br><span class="line"><span class="attr">hostvars.node1.group_names</span>=显示node1所在的组的名字</span><br><span class="line"><span class="attr">groups</span>=所有主机以及组信息</span><br><span class="line"><span class="attr">groups.all</span>=显示被控主机名</span><br><span class="line"><span class="attr">groups.test01</span>=显示test01组里的所有主机名</span><br><span class="line"><span class="attr">group_names</span>=当前运行任务的主机的所在组</span><br></pre></td></tr></table></figure>
<p>使用copy模块拷贝常量和变量字符串到被控主机</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">node1</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">copy:</span></span><br><span class="line">       <span class="attr">content:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        abc</span></span><br><span class="line"><span class="string">        xyz</span></span><br><span class="line"><span class="string">        &#123;&#123;ansible_hostname&#125;&#125;</span></span><br><span class="line"><span class="string"></span>       <span class="attr">dest:</span> <span class="string">/opt/abc.txt</span></span><br></pre></td></tr></table></figure>
<h2 id="模块相关">模块相关</h2>
<h3 id="template模板">template模板</h3>
<p>根据模板生成相应的文件</p>
<p>src：源文件</p>
<p>dest：目标文件</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#cat test.j2</span></span><br><span class="line">&#123;&#123; ansible_hostname &#125;&#125; <span class="comment"># 根据环境变量生成文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># cat tepl.yml</span></span><br><span class="line">- hosts: node1</span><br><span class="line">  tasks:</span><br><span class="line">    - template:</span><br><span class="line">        src: test.j2</span><br><span class="line">        dest: /opt/test.html</span><br></pre></td></tr></table></figure></p>
<h3 id="使用ansible容器运行剧本">使用ansible容器运行剧本</h3>
<p>安装navigator包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum install -y ansible-navigator</span><br></pre></td></tr></table></figure>
<p>修改navigator配置文件</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#vim ~/.ansible-navigator.yml</span></span><br><span class="line"><span class="attr">ansible-navigator:</span></span><br><span class="line">  <span class="attr">execution-environment:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">registry.lab.example.com:5000/ee-supported-rhel8:latest</span></span><br><span class="line">    <span class="attr">pull:</span></span><br><span class="line">      <span class="attr">policy:</span> <span class="string">missing</span></span><br></pre></td></tr></table></figure>
<p>修改container配置文件</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vim /etc/containers/registries.conf</span></span><br><span class="line"><span class="section">[registries.search]</span></span><br><span class="line"><span class="attr">registries</span> = [<span class="string">&quot;registry.lab.example.com:5000&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="section">[registries.insecure]</span></span><br><span class="line"><span class="attr">registries</span> = [<span class="string">&quot;registry.lab.example.com:5000&quot;</span>]</span><br></pre></td></tr></table></figure>
<p>下载镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ansible-navigator images</span><br></pre></td></tr></table></figure>
<p>执行剧本任务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ansible-navigator run debug.yml -m stdout</span><br></pre></td></tr></table></figure>
<h3
id="使用ansible-vault加密敏感文件">使用ansible-vault加密敏感文件</h3>
<table>
<thead>
<tr class="header">
<th>参数</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>encrypt</td>
<td>加密</td>
</tr>
<tr class="even">
<td>decrypt</td>
<td>解密</td>
</tr>
<tr class="odd">
<td>view</td>
<td>查看</td>
</tr>
<tr class="even">
<td>rekey</td>
<td>重置密码</td>
</tr>
</tbody>
</table>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输入密码，加密test01配置文件</span></span><br><span class="line">ansible-vault encrypt test01.yml</span><br><span class="line"><span class="comment"># 输入密码，解密test01配置文件</span></span><br><span class="line">ansible-vault decrypt test01.yml</span><br><span class="line"><span class="comment"># 输入密码，查看test01配置文件</span></span><br><span class="line">ansible-vault view test01.yml</span><br><span class="line"><span class="comment"># 输入密码，执行配置文件</span></span><br><span class="line">ansible-playbook test01.yml --ask-vault-pass</span><br><span class="line"><span class="comment"># 通过保存到pass.txt的密码，执行配置文件</span></span><br><span class="line">ansible-playbook test01.yml --vault-id pass.txt</span><br><span class="line"><span class="comment"># 通过保存到pass.txt的密码，查看配置文件</span></span><br><span class="line">ansible-vault  test01.yml --vault-id pass.txt</span><br><span class="line"><span class="comment"># 重置密码</span></span><br><span class="line">ansible-vault rekey test01.yml</span><br></pre></td></tr></table></figure>
<h2 id="角色">角色</h2>
<p>角色是定义好的统一目录规范</p>
<p>修改配置，定义角色目录位置</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vim ~/ansible/ansible.cfg</span></span><br><span class="line"><span class="section">[default]</span></span><br><span class="line"><span class="attr">roles_path</span> = ./roles</span><br></pre></td></tr></table></figure>
<h3 id="手动创建角色">手动创建角色</h3>
<p>创建http角色相关目录，http是创建的角色，tasks是存放任务的目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p ansible/roles/http/tasks</span><br></pre></td></tr></table></figure>
<p>roles/tasks/main.yml文件</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">yum:</span></span><br><span class="line">	<span class="attr">name:</span> <span class="string">httpd</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line">	<span class="attr">msg:</span> <span class="string">ok</span></span><br></pre></td></tr></table></figure>
<p>编写剧本调用角色</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test</span> <span class="string">roles</span></span><br><span class="line">  <span class="attr">hosts:</span> <span class="string">node1,</span> <span class="string">node2</span></span><br><span class="line">  <span class="attr">roles:</span></span><br><span class="line">  	<span class="bullet">-</span> <span class="string">http</span></span><br></pre></td></tr></table></figure>
<h3 id="使用命令创建角色">使用命令创建角色</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ansible-galaxy init roles/vsftpd</span><br><span class="line"><span class="built_in">ls</span> roles/vsftped</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr class="header">
<th>目录</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>tasks</td>
<td>存放执行任务</td>
</tr>
<tr class="even">
<td>vars</td>
<td>存放变量，优先级高</td>
</tr>
<tr class="odd">
<td>defaults</td>
<td>存放变量，优先级低</td>
</tr>
<tr class="even">
<td>files</td>
<td>存放静态文件，如图片、视频、配置文件等</td>
</tr>
<tr class="odd">
<td>meta</td>
<td>存放作者、角色版本信息</td>
</tr>
<tr class="even">
<td>templates</td>
<td>存放动态数据，比如j2模板</td>
</tr>
<tr class="odd">
<td>handlers</td>
<td>存放提前定义好的任务</td>
</tr>
</tbody>
</table>
<h4 id="测试1">测试1</h4>
<p>准备静态文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> 123 &gt; roles/vsftpd/files/123</span><br></pre></td></tr></table></figure>
<p>根据角色创建任务</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vim roles/vsftpd/tasks/main.yml</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">yum:</span></span><br><span class="line">	<span class="attr">name:</span> <span class="string">vsftpd</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">copy:</span></span><br><span class="line">	<span class="comment"># 自动寻找files下的123文件</span></span><br><span class="line">	<span class="attr">src:</span> <span class="string">&quot;123&quot;</span></span><br><span class="line">	<span class="attr">dest:</span> <span class="string">/var/ftp/pub</span></span><br></pre></td></tr></table></figure>
<p>编写脚本调用角色</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vim test2.yml</span></span><br><span class="line">- hosts: node1, node2</span><br><span class="line">  roles:</span><br><span class="line">    - vsftpd</span><br></pre></td></tr></table></figure>
<p>执行剧本</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ansible-playbook test2.yml</span><br></pre></td></tr></table></figure></p>
<h4 id="测试2">测试2</h4>
<p>定义变量</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vim roles/vsftpd/vars/main.yml</span></span><br><span class="line"><span class="attr">myvar001:</span> <span class="string">abc</span></span><br></pre></td></tr></table></figure>
<p>测试变量</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vim roles/vsftpd/tasks/main.yml</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">template:</span></span><br><span class="line">	<span class="attr">src:</span> <span class="string">&quot;456.j2&quot;</span></span><br><span class="line">	<span class="attr">dest:</span> <span class="string">/var/ftp/pub</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">debug:</span></span><br><span class="line">	<span class="attr">msg:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123;myvar001&#125;&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>查看模板生成的文件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"># less /var/ftp/pub</span><br><span class="line">abc</span><br></pre></td></tr></table></figure>
<h3 id="使用网络下载安装角色">使用网络下载安装角色</h3>
<p>配置需要下载的角色文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#vim roles.yml</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myphp</span></span><br><span class="line">  <span class="attr">src:</span> <span class="string">http://172.25.254.250/roles/myphp.tar</span></span><br></pre></td></tr></table></figure>
<p>安装网上下载的角色</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ansible-galxy install -r roles.yml</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>learning</tag>
        <tag>ansible</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes集群实践（十二）使用keepalived+haproxy创建高可用K8s集群</title>
    <url>/p/create-ha-kubernetes/</url>
    <content><![CDATA[<p>本文主要介绍如何使用keepalived+haproxy创建高可用集群，文中主要来源与作者在工作中的一些实际操作，本文仅供作者自己记录和读者参考。</p>
<p>关键词：<strong>高可用K8s集群</strong></p>
<span id="more"></span>
<p>本文搭建的集群使用3个master节点和4个worker节点，为了节约资源，本文使用嵌入的etcd集群。</p>
<h2 id="集群环境准备">集群环境准备</h2>
<h3 id="集群拓扑">集群拓扑</h3>
<figure>
<img data-src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p1b3pld2Vp,size_16,color_FFFFFF,t_70.png"
alt="堆叠ETCD" />
<figcaption aria-hidden="true">堆叠ETCD</figcaption>
</figure>
<ul>
<li>使用keepalived+haproxy的架构，worker节点通过访问vip和haproxy的后端服务器，实现了K8s集群的高可用；</li>
<li>为了避免堆叠集群出现耦合失败的风险，应该为HA集群运行至少三个堆叠的控制节点；</li>
<li>以上是kubeadm中的默认拓扑。当使用<code>kubeadm init</code>
和<code>kubeadm join --control-plane --upload-certs</code>时，在控制节点平面上自动创建etcd成员。</li>
</ul>
<h3 id="主机规划">主机规划</h3>
<table>
<colgroup>
<col style="width: 11%" />
<col style="width: 16%" />
<col style="width: 5%" />
<col style="width: 11%" />
<col style="width: 44%" />
<col style="width: 11%" />
</colgroup>
<thead>
<tr class="header">
<th>主机IP地址</th>
<th>主机名</th>
<th>主机配置</th>
<th>主机角色</th>
<th>软件列表</th>
<th>其他IP</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>192.168.100.101</td>
<td>192.168.100.101-master</td>
<td>2C4G</td>
<td>master + worker</td>
<td>kube-apiserver、kube-controller-manager、kube-scheduler、etcd、kubelet、kube-proxy、containerd</td>
<td></td>
</tr>
<tr class="even">
<td>192.168.100.102</td>
<td>192.168.100.102-master</td>
<td>2C4G</td>
<td>master + worker</td>
<td>kube-apiserver、kube-controller-manager、kube-scheduler、etcd、kubelet、kube-proxy、containerd</td>
<td></td>
</tr>
<tr class="odd">
<td>192.168.100.103</td>
<td>192.168.100.103-master</td>
<td>2C4G</td>
<td>master + worker</td>
<td>kube-apiserver、kube-controller-manager、kube-scheduler、etcd、kubelet、kube-proxy、containerd</td>
<td></td>
</tr>
<tr class="even">
<td>192.168.100.105</td>
<td>192.168.100.105-worker</td>
<td>2C4G</td>
<td>worker+LB1</td>
<td>kubelet、kube-proxy、containerd、keepalived、haproxy</td>
<td>192.168.100.104</td>
</tr>
<tr class="odd">
<td>192.168.100.106</td>
<td>192.168.100.106-worker</td>
<td>2C4G</td>
<td>worker+LB1</td>
<td>kubelet、kube-proxy、containerd、keepalived、haproxy</td>
<td>192.168.100.104</td>
</tr>
<tr class="even">
<td>192.168.100.107</td>
<td>192.168.100.107-worker</td>
<td>2C4G</td>
<td>worker</td>
<td>kubelet、kube-proxy、containerd</td>
<td></td>
</tr>
<tr class="odd">
<td>192.168.100.108</td>
<td>192.168.100.108-worker</td>
<td>2C4G</td>
<td>worker</td>
<td>kubelet、kube-proxy、containerd</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="软件版本">软件版本</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">软件名称</th>
<th style="text-align: left;">版本</th>
<th style="text-align: left;">备注</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">CentOS8</td>
<td
style="text-align: left;">kernel版本：4.18.0-477.27.1.el8_8.x86_64</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">kubernetes</td>
<td style="text-align: left;">v1.28.2</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">etcd</td>
<td style="text-align: left;">v3.5.9</td>
<td style="text-align: left;">最新版本</td>
</tr>
<tr class="even">
<td style="text-align: left;">flannel</td>
<td style="text-align: left;">v0.22.3</td>
<td style="text-align: left;">网络插件</td>
</tr>
<tr class="odd">
<td style="text-align: left;">containerd</td>
<td style="text-align: left;">v1.7.6</td>
<td style="text-align: left;">容器运行时</td>
</tr>
<tr class="even">
<td style="text-align: left;">haproxy</td>
<td style="text-align: left;">v1.8.27</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">keepalived</td>
<td style="text-align: left;">v2.1.5</td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<h3 id="网络分配">网络分配</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">网络名称</th>
<th style="text-align: left;">网段</th>
<th style="text-align: left;">备注</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Node网络</td>
<td style="text-align: left;">192.168.100.101/108</td>
<td style="text-align: left;">集群节点网络</td>
</tr>
<tr class="even">
<td style="text-align: left;">Service网络</td>
<td style="text-align: left;">10.96.0.0/16</td>
<td style="text-align: left;">实现服务发现时所使用的网络</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Pod网络</td>
<td style="text-align: left;">10.244.0.0/16</td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<h2 id="集群部署">集群部署</h2>
<p>为了方便集群部署，本文使用自动化运维工具ansible配置整个集群。</p>
<p>主要编辑两个文件，一是ansible的配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vim /etc/ansible/ansible.cfg</span></span><br><span class="line">[defaults]</span><br><span class="line"><span class="comment"># hosts主机文件</span></span><br><span class="line">inventory = ./hosts</span><br><span class="line"><span class="comment"># ssh免指纹</span></span><br><span class="line">host_key_checking = False</span><br></pre></td></tr></table></figure>
<p>二是ansible的主机文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vim /etc/ansible/hosts</span></span><br><span class="line">[master]</span><br><span class="line">192.168.100.101 ansible_ssh_user=root</span><br><span class="line">192.168.100.102 ansible_ssh_user=root</span><br><span class="line">192.168.100.103 ansible_ssh_user=root</span><br><span class="line">[worker]</span><br><span class="line">192.168.100.105 ansible_ssh_user=root</span><br><span class="line">192.168.100.106 ansible_ssh_user=root</span><br><span class="line">192.168.100.107 ansible_ssh_user=root</span><br><span class="line">192.168.100.108 ansible_ssh_user=root</span><br></pre></td></tr></table></figure>
<h3 id="运行时下载">运行时下载</h3>
<p>refer：https://github.com/containerd/nerdctl，需要下载full的文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar Cxzvvf /usr/local nerdctl-full-*-linux-amd64.tar.gz</span><br><span class="line">systemctl <span class="built_in">enable</span> buildkit.service --now</span><br><span class="line">systemctl <span class="built_in">enable</span> containerd.service --now</span><br><span class="line">systemctl <span class="built_in">enable</span> stargz-snapshotter.service --now</span><br></pre></td></tr></table></figure>
<h3 id="主机准备">主机准备</h3>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># init-k8s.yml</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">hosts</span></span><br><span class="line">  <span class="attr">hosts:</span> <span class="string">all</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">ansible.builtin.shell:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        cat &gt; /etc/hosts &lt;&lt; EOF</span></span><br><span class="line"><span class="string">        127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4</span></span><br><span class="line"><span class="string">        ::1         localhost localhost.localdomain localhost6 localhost6.localdomain6</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">        <span class="number">192.168</span><span class="number">.100</span><span class="number">.101</span> <span class="number">192.168</span><span class="number">.100</span><span class="number">.101</span><span class="string">-master</span></span><br><span class="line">        <span class="number">192.168</span><span class="number">.100</span><span class="number">.102</span> <span class="number">192.168</span><span class="number">.100</span><span class="number">.102</span><span class="string">-master</span></span><br><span class="line">        <span class="number">192.168</span><span class="number">.100</span><span class="number">.103</span> <span class="number">192.168</span><span class="number">.100</span><span class="number">.103</span><span class="string">-master</span></span><br><span class="line">        <span class="number">192.168</span><span class="number">.100</span><span class="number">.105</span> <span class="number">192.168</span><span class="number">.100</span><span class="number">.105</span><span class="string">-worker</span></span><br><span class="line">        <span class="number">192.168</span><span class="number">.100</span><span class="number">.106</span> <span class="number">192.168</span><span class="number">.100</span><span class="number">.106</span><span class="string">-worker</span></span><br><span class="line">        <span class="number">192.168</span><span class="number">.100</span><span class="number">.107</span> <span class="number">192.168</span><span class="number">.100</span><span class="number">.107</span><span class="string">-worker</span></span><br><span class="line">        <span class="number">192.168</span><span class="number">.100</span><span class="number">.108</span> <span class="number">192.168</span><span class="number">.100</span><span class="number">.108</span><span class="string">-worker</span></span><br><span class="line">        <span class="string">EOF</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">master</span> <span class="string">hostname</span></span><br><span class="line">  <span class="attr">hosts:</span> <span class="string">master</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">hostname:</span> <span class="string">name=&#123;&#123;</span> <span class="string">ansible_enp6s18[&#x27;ipv4&#x27;][&#x27;address&#x27;]</span> <span class="string">&#125;&#125;-master</span> </span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">set</span> <span class="string">worker</span> <span class="string">hostname</span></span><br><span class="line">  <span class="attr">hosts:</span> <span class="string">worker</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">hostname:</span> <span class="string">name=&#123;&#123;</span> <span class="string">ansible_enp6s18[&#x27;ipv4&#x27;][&#x27;address&#x27;]</span> <span class="string">&#125;&#125;-worker</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">k8s</span> <span class="string">env</span></span><br><span class="line">  <span class="attr">hosts:</span> <span class="string">all</span></span><br><span class="line">  <span class="attr">remote_user:</span> <span class="string">root</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">ansible.builtin.shell:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        systemctl disable firewalld --now</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">        <span class="string">sed</span> <span class="string">-i</span> <span class="string">&#x27;s/enforcing/disabled/&#x27;</span> <span class="string">/etc/selinux/config</span></span><br><span class="line">        <span class="string">setenforce</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="string">sed</span> <span class="string">-ri</span> <span class="string">&#x27;/^[^#]*swap/s@^@#@&#x27;</span> <span class="string">/etc/fstab</span></span><br><span class="line">        <span class="string">swapoff</span> <span class="string">-a</span></span><br><span class="line"></span><br><span class="line">        <span class="string">yum</span> <span class="string">install</span> <span class="string">ipvsadm</span> <span class="string">ipset</span> <span class="string">sysstat</span> <span class="string">conntrack</span> <span class="string">libseccomp</span> <span class="string">iproute-tc</span> <span class="string">-y</span></span><br><span class="line"></span><br><span class="line">        <span class="string">cat</span> <span class="string">&gt;</span> <span class="string">/etc/modules-load.d/k8s.conf</span> <span class="string">&lt;&lt;</span> <span class="string">EOF</span></span><br><span class="line">        <span class="string">br_netfilter</span> </span><br><span class="line">        <span class="string">ip_vs</span> </span><br><span class="line">        <span class="string">ip_vs_lc</span> </span><br><span class="line">        <span class="string">ip_vs_wlc</span> </span><br><span class="line">        <span class="string">ip_vs_rr</span> </span><br><span class="line">        <span class="string">ip_vs_wrr</span> </span><br><span class="line">        <span class="string">ip_vs_lblc</span> </span><br><span class="line">        <span class="string">ip_vs_lblcr</span> </span><br><span class="line">        <span class="string">ip_vs_dh</span> </span><br><span class="line">        <span class="string">ip_vs_sh</span> </span><br><span class="line">        <span class="string">ip_vs_fo</span> </span><br><span class="line">        <span class="string">ip_vs_nq</span> </span><br><span class="line">        <span class="string">ip_vs_sed</span> </span><br><span class="line">        <span class="string">ip_vs_ftp</span> </span><br><span class="line">        <span class="string">ip_vs_sh</span> </span><br><span class="line">        <span class="string">nf_conntrack</span> </span><br><span class="line">        <span class="string">ip_tables</span> </span><br><span class="line">        <span class="string">ip_set</span> </span><br><span class="line">        <span class="string">xt_set</span> </span><br><span class="line">        <span class="string">ipt_set</span> </span><br><span class="line">        <span class="string">ipt_rpfilter</span> </span><br><span class="line">        <span class="string">ipt_REJECT</span> </span><br><span class="line">        <span class="string">ipip</span></span><br><span class="line">        <span class="string">EOF</span></span><br><span class="line"></span><br><span class="line">        <span class="string">systemctl</span> <span class="string">enable</span> <span class="string">--now</span> <span class="string">systemd-modules-load.service</span></span><br><span class="line"></span><br><span class="line">        <span class="string">lsmod</span> <span class="string">|</span> <span class="string">grep</span> <span class="string">-e</span> <span class="string">ip_vs</span> <span class="string">-e</span> <span class="string">nf-conntrack</span></span><br><span class="line"></span><br><span class="line">        <span class="string">cat</span> <span class="string">&gt;</span> <span class="string">/etc/sysctl.d/k8s.conf</span> <span class="string">&lt;&lt;</span> <span class="string">EOF</span></span><br><span class="line">        <span class="string">vm.swappiness</span> <span class="string">=</span> <span class="number">0</span></span><br><span class="line">        <span class="string">net.bridge.bridge-nf-call-ip6tables</span> <span class="string">=</span> <span class="number">1</span></span><br><span class="line">        <span class="string">net.bridge.bridge-nf-call-iptables</span> <span class="string">=</span> <span class="number">1</span></span><br><span class="line">        <span class="string">net.ipv4.ip_forward</span> <span class="string">=</span> <span class="number">1</span></span><br><span class="line">        <span class="string">fs.may_detach_mounts</span> <span class="string">=</span> <span class="number">1</span></span><br><span class="line">        <span class="string">vm.overcommit_memory</span> <span class="string">=</span> <span class="number">1</span></span><br><span class="line">        <span class="string">vm.panic_on.oom</span> <span class="string">=</span> <span class="number">0</span></span><br><span class="line">        <span class="string">fs.inotify.max_user_watches</span> <span class="string">=</span> <span class="number">89100</span></span><br><span class="line">        <span class="string">fs.file-max</span> <span class="string">=</span> <span class="number">52706963</span></span><br><span class="line">        <span class="string">fs.nr_open</span> <span class="string">=</span> <span class="number">52706963</span></span><br><span class="line">        <span class="string">net.netfilter.nf_conntrack_max</span> <span class="string">=</span> <span class="number">2310720</span></span><br><span class="line">        <span class="string">net.ipv4.tcp_keepalive_time</span> <span class="string">=</span> <span class="number">600</span></span><br><span class="line">        <span class="string">net.ipv4.tcp_keepalive_probes</span> <span class="string">=</span> <span class="number">3</span></span><br><span class="line">        <span class="string">net.ipv4.tcp_keepalive_intvl</span> <span class="string">=</span> <span class="number">15</span></span><br><span class="line">        <span class="string">net.ipv4.tcp_max_tw_buckets</span> <span class="string">=</span> <span class="number">36000</span></span><br><span class="line">        <span class="string">net.ipv4.tcp_tw_reuse</span> <span class="string">=</span> <span class="number">1</span></span><br><span class="line">        <span class="string">net.ipv4.tcp_max_orphans</span> <span class="string">=</span> <span class="number">327680</span></span><br><span class="line">        <span class="string">net.ipv4.tcp_orphan_retries</span> <span class="string">=</span> <span class="number">3</span></span><br><span class="line">        <span class="string">net.ipv4.tcp_syncookies</span> <span class="string">=</span> <span class="number">1</span></span><br><span class="line">        <span class="string">net.ipv4.tcp_max_syn_backlog</span> <span class="string">=</span> <span class="number">16384</span></span><br><span class="line">        <span class="string">net.ipv4.ip_contrack_max</span> <span class="string">=</span> <span class="number">65536</span></span><br><span class="line">        <span class="string">net.ipv4.tcp_timestamps</span> <span class="string">=</span> <span class="number">0</span></span><br><span class="line">        <span class="string">net.core.somaxconn</span> <span class="string">=</span> <span class="number">16384</span></span><br><span class="line">        <span class="string">EOF</span></span><br><span class="line"></span><br><span class="line">        <span class="string">cat</span> <span class="string">&gt;&gt;</span> <span class="string">/etc/security/limits.d/k8s.conf</span> <span class="string">&lt;&lt;EOF</span></span><br><span class="line">        <span class="string">*</span> <span class="string">soft</span> <span class="string">nofile</span> <span class="number">1048576</span></span><br><span class="line">        <span class="string">*</span> <span class="string">hard</span> <span class="string">nofile</span> <span class="number">1048576</span></span><br><span class="line">        <span class="string">*</span> <span class="string">soft</span> <span class="string">noproc</span> <span class="number">1048576</span></span><br><span class="line">        <span class="string">*</span> <span class="string">hard</span> <span class="string">noproc</span> <span class="number">1048576</span></span><br><span class="line">        <span class="string">*</span> <span class="string">soft</span> <span class="string">memlock</span> <span class="string">unlimited</span></span><br><span class="line">        <span class="string">*</span> <span class="string">hard</span> <span class="string">memlock</span> <span class="string">unlimited</span></span><br><span class="line">        <span class="string">EOF</span></span><br><span class="line">        <span class="string">exit</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Copy</span> <span class="string">file</span> <span class="string">with</span> <span class="string">owner</span> <span class="string">and</span> <span class="string">permissions</span></span><br><span class="line">      <span class="attr">ansible.builtin.copy:</span></span><br><span class="line">        <span class="attr">src:</span> <span class="string">./nerdctl-full-1.6.0-linux-amd64.tar.gz</span></span><br><span class="line">        <span class="attr">dest:</span> <span class="string">/tmp/nerdctl-full-1.6.0-linux-amd64.tar.gz</span></span><br><span class="line">    </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Unzip</span> <span class="string">nerdctl</span> <span class="string">files</span></span><br><span class="line">      <span class="attr">ansible.builtin.unarchive:</span></span><br><span class="line">        <span class="attr">src:</span> <span class="string">/tmp/nerdctl-full-1.6.0-linux-amd64.tar.gz</span></span><br><span class="line">        <span class="attr">dest:</span> <span class="string">/usr/local/</span></span><br><span class="line">    </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Restart</span> <span class="string">Service</span></span><br><span class="line">      <span class="attr">ansible.builtin.shell:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        systemctl enable buildkit.service --now</span></span><br><span class="line"><span class="string">        systemctl enable containerd.service --now</span></span><br><span class="line"><span class="string">        systemctl enable stargz-snapshotter.service --now</span></span><br><span class="line"><span class="string">        mkdir -p /etc/containerd</span></span><br><span class="line"><span class="string">        containerd config default |  tee /etc/containerd/config.toml</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Init</span> <span class="string">containerd</span> <span class="string">Service</span></span><br><span class="line">      <span class="attr">ansible.builtin.shell:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        systemctl enable buildkit.service --now</span></span><br><span class="line"><span class="string">        systemctl enable containerd.service --now</span></span><br><span class="line"><span class="string">        systemctl enable stargz-snapshotter.service --now</span></span><br><span class="line"><span class="string">        mkdir -p /etc/containerd</span></span><br><span class="line"><span class="string">        containerd config default |  tee /etc/containerd/config.toml</span></span><br><span class="line"><span class="string">        sed -ri &quot;s|registry.k8s.io|pkgs.fly97.cn|g&quot; /etc/containerd/config.toml</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">kubeadm</span> <span class="string">repo</span></span><br><span class="line">      <span class="attr">ansible.builtin.shell:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        cat &gt; /etc/yum.repos.d/kubernetes.repo &lt;&lt; EOF</span></span><br><span class="line"><span class="string">        [kubernetes]</span></span><br><span class="line"><span class="string">        name=Kubernetes for EPEL </span></span><br><span class="line"><span class="string">        baseurl=https://pkgs.fly97.cn/repository/kubernetes-yum/</span></span><br><span class="line"><span class="string">        enabled=1</span></span><br><span class="line"><span class="string">        gpgcheck=0</span></span><br><span class="line"><span class="string">        EOF</span></span><br><span class="line"><span class="string">        dnf makecache -y</span></span><br><span class="line"><span class="string">        dnf install kubelet kubeadm kubectl -y</span></span><br><span class="line"><span class="string">        systemctl stop kubelet</span></span><br><span class="line"><span class="string"></span>        </span><br></pre></td></tr></table></figure>
<h3 id="负载均衡">负载均衡</h3>
<p>在105和106机器上分别安装keepalived+HAproxy</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo dnf install keepalived haproxy -y</span><br></pre></td></tr></table></figure>
<h4 id="haproxy">haproxy</h4>
<p>以下是haproxy的配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; /etc/haproxy/haproxy.cfg &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">global</span></span><br><span class="line"><span class="string">    log         127.0.0.1 local2</span></span><br><span class="line"><span class="string">    pidfile     /var/run/haproxy.pid</span></span><br><span class="line"><span class="string">    maxconn     65535</span></span><br><span class="line"><span class="string">    daemon</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">defaults</span></span><br><span class="line"><span class="string">    timeout connect 5000</span></span><br><span class="line"><span class="string">    timeout client 50000</span></span><br><span class="line"><span class="string">    timeout server 50000</span></span><br><span class="line"><span class="string">    timeout http-request 15s</span></span><br><span class="line"><span class="string">    timeout http-keep-alive 15s</span></span><br><span class="line"><span class="string">    retries    3</span></span><br><span class="line"><span class="string">    maxconn    65535</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">frontend  kubernetes-apiserver</span></span><br><span class="line"><span class="string">    mode tcp</span></span><br><span class="line"><span class="string">    bind *:6443</span></span><br><span class="line"><span class="string">    tcp-request inspect-delay 5s</span></span><br><span class="line"><span class="string">    default_backend  kubernetes-apiserver</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">backend kubernetes-apiserver</span></span><br><span class="line"><span class="string">    mode        tcp</span></span><br><span class="line"><span class="string">    balance     roundrobin</span></span><br><span class="line"><span class="string">    server master01 192.168.100.101:6443 check inter 2000 rise 2 fall 2</span></span><br><span class="line"><span class="string">    server master02 192.168.100.102:6443 check inter 2000 rise 2 fall 2</span></span><br><span class="line"><span class="string">    server master03 192.168.100.103:6443 check inter 2000 rise 2 fall 2</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>
<h4 id="keepalived">keepalived</h4>
<p>以下是106机器keepalived的配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; /etc/keepalived/keepalived.conf &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">global_defs &#123;</span></span><br><span class="line"><span class="string">   max_auto_priority</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">vrrp_script check_apiserver &#123;</span></span><br><span class="line"><span class="string">   script &quot;/etc/keepalived/check_apiserver_vip.sh&quot;</span></span><br><span class="line"><span class="string">   interval 2</span></span><br><span class="line"><span class="string">   weight 5</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">vrrp_instance VI_02 &#123;</span></span><br><span class="line"><span class="string">   # BACKUP模式</span></span><br><span class="line"><span class="string">   state BACKUP</span></span><br><span class="line"><span class="string">   nopreempt</span></span><br><span class="line"><span class="string">   interface enp6s18</span></span><br><span class="line"><span class="string">   # 每个集群的router_id要一致</span></span><br><span class="line"><span class="string">   virtual_router_id 100</span></span><br><span class="line"><span class="string">   priority 50</span></span><br><span class="line"><span class="string">   unicast_src_ip 192.168.100.106</span></span><br><span class="line"><span class="string">   unicast_peer&#123;</span></span><br><span class="line"><span class="string">      192.168.100.105</span></span><br><span class="line"><span class="string">   &#125;</span></span><br><span class="line"><span class="string">   # 虚IP地址</span></span><br><span class="line"><span class="string">   virtual_ipaddress &#123;</span></span><br><span class="line"><span class="string">     192.168.100.104/24</span></span><br><span class="line"><span class="string">   &#125;</span></span><br><span class="line"><span class="string">   track_script &#123;</span></span><br><span class="line"><span class="string">     check_apiserver</span></span><br><span class="line"><span class="string">   &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>
<p>以下是105机器keepalived的配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; /etc/keepalived/keepalived.conf &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">global_defs &#123;</span></span><br><span class="line"><span class="string">  max_auto_priority</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">vrrp_script check_apiserver &#123;</span></span><br><span class="line"><span class="string">   script &quot;/etc/keepalived/check_apiserver_vip.sh&quot;</span></span><br><span class="line"><span class="string">   interval 2</span></span><br><span class="line"><span class="string">   weight 5</span></span><br><span class="line"><span class="string">   timeout 1</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">vrrp_instance VI_01 &#123;</span></span><br><span class="line"><span class="string">   # MASTER模式</span></span><br><span class="line"><span class="string">   state MASTER</span></span><br><span class="line"><span class="string">   nopreempt</span></span><br><span class="line"><span class="string">   interface enp6s18</span></span><br><span class="line"><span class="string">   # 每个集群的router_id要一致</span></span><br><span class="line"><span class="string">   virtual_router_id 100</span></span><br><span class="line"><span class="string">   priority 100</span></span><br><span class="line"><span class="string">   unicast_src_ip 192.168.100.105</span></span><br><span class="line"><span class="string">   unicast_peer &#123;</span></span><br><span class="line"><span class="string">     192.168.100.106</span></span><br><span class="line"><span class="string">   &#125;</span></span><br><span class="line"><span class="string">   # 虚IP地址</span></span><br><span class="line"><span class="string">   virtual_ipaddress &#123;</span></span><br><span class="line"><span class="string">     192.168.100.104/24</span></span><br><span class="line"><span class="string">   &#125;</span></span><br><span class="line"><span class="string">   track_script &#123;</span></span><br><span class="line"><span class="string">     check_apiserver</span></span><br><span class="line"><span class="string">   &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>
<p>以下是检查api_server的脚本文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vim /etc/keepalived/check_apiserver_vip.sh</span></span><br><span class="line"><span class="comment">#!/bin/sh</span></span><br><span class="line">killall -0 haproxy</span><br><span class="line"><span class="keyword">if</span> [ $? == 0 ];<span class="keyword">then</span></span><br><span class="line">   http_code=$(curl -k -s -o /dev/null -w <span class="string">&quot;%&#123;http_code&#125;\n&quot;</span> https://127.0.0.1:6443)</span><br><span class="line">   <span class="keyword">if</span> [ <span class="variable">$http_code</span> == 403 ];<span class="keyword">then</span></span><br><span class="line">      <span class="built_in">exit</span> 0</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">exit</span> 1</span><br><span class="line">   <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<h3 id="部署master和node">部署master和node</h3>
<p>在101主机上执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubeadm init --config init-k8s.yml --upload-certs</span><br></pre></td></tr></table></figure>
<p>没有问题的话会安装成功</p>
<p><img data-src="image-20231005000618131.png" /></p>
<p>在102、103master主机上执行上面第一行的命令，在剩下的worker节点执行下面的命令</p>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 75%" />
</colgroup>
<thead>
<tr class="header">
<th>主机</th>
<th>命令</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>102、103等master节点</td>
<td>kubeadm join 192.168.100.104:6443 --token xxx
--discovery-token-ca-cert-hash xxx --control-plane --certificate-key
xxx</td>
</tr>
<tr class="even">
<td>其他worker节点</td>
<td>kubeadm join 192.168.100.104:6443 --token xxx
--discovery-token-ca-cert-hash xxx</td>
</tr>
</tbody>
</table>
<p>执行成功后，在任一master节点下执行<code>kubectl get nodes</code>，会显示下面的节点状态</p>
<p><img data-src="image-20231005003115986.png" /></p>
<p>此时节点状态仍然是<strong>NotReady</strong>，通过kubelet日志可以看到网络插件尚未安装。</p>
<p><img data-src="image-20231005003336911.png" /></p>
<h3 id="部署网络插件">部署网络插件</h3>
<p>本文使用flannel作为K8s的网络插件：Flannel
是一种简单易用的方法来配置专为 Kubernetes 设计的第 3 层网络结构。</p>
<p>refer：https://github.com/flannel-io/flannel</p>
<p>资源清单可以参考：https://github.com/flannel-io/flannel/blob/master/Documentation/kube-flannel.yml</p>
<p>主要需要修改image镜像地址，镜像可以参考：https://sci.nju.edu.cn/9e/05/c30384a564741/page.htm</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f kube-flannel.yml</span><br></pre></td></tr></table></figure>
<p>等待kube-flannel中pod状态变为running即可</p>
<p><img data-src="image-20231005004551653.png" /></p>
<p>此时集群状态正常，安装完毕</p>
<p><img data-src="image-20231005004647172.png" /></p>
<h2 id="高可用检查">高可用检查</h2>
<h3 id="安装etcdctl">安装etcdctl</h3>
<p>refer：https://github.com/etcd-io/etcd/releases/tag/v3.5.9</p>
<p>添加环境变量实现自动别名操作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vim .bash_profile</span></span><br><span class="line"><span class="built_in">export</span> ETCDCTL_API=3</span><br><span class="line"><span class="built_in">alias</span> etcdctl=<span class="string">&#x27;etcdctl --endpoints=https://192.168.100.101:2379,https://192.168.100.102:2379,https://192.168.100.103:2379 --cacert=/etc/kubernetes/pki/etcd/ca.crt --cert=/etc/kubernetes/pki/etcd/server.crt --key=/etc/kubernetes/pki/etcd/server.key</span></span><br></pre></td></tr></table></figure>
<p>查看etcd endpoint状态</p>
<p><img data-src="image-20231005010150190.png" /></p>
<p>查看etcd endpoint健康</p>
<p><img data-src="image-20231005010229342.png" /></p>
<h3 id="未完待续">未完待续。。。</h3>
]]></content>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>rockylinux常见操作</title>
    <url>/p/how-to-use-rockylinux/</url>
    <content><![CDATA[<p><strong>关键词：RockyLinux 9</strong></p>
<span id="more"></span>
<h2 id="下载地址">下载地址</h2>
<p><a href="https://mirrors.nju.edu.cn/rocky/9/isos/">RockyLinux
9</a></p>
<p><a href="https://mirrors.nju.edu.cn/rocky/8/isos/">RockyLinux
8</a></p>
<p>这里一般下载minimal镜像，免去设置镜像源的烦恼。</p>
<p><img data-src="image-20230916195636348.png" /></p>
<h2 id="换源">换源</h2>
<p>参考：<a
href="https://mirror.nju.edu.cn/mirrorz-help/rocky/?mirror=NJU">Rocky
Linux 软件仓库镜像使用帮助 - MirrorZ Help (nju.edu.cn)</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo sed -e <span class="string">&#x27;s|^mirrorlist=|#mirrorlist=|g&#x27;</span> \</span><br><span class="line">         -e <span class="string">&#x27;s|^#baseurl=http://dl.rockylinux.org/$contentdir|baseurl=https://mirror.nju.edu.cn/rocky|g&#x27;</span> \</span><br><span class="line">         -i.bak \</span><br><span class="line">         /etc/yum.repos.d/rocky-extras.repo \</span><br><span class="line">         /etc/yum.repos.d/rocky.repo</span><br></pre></td></tr></table></figure>
<h2 id="网络管理">网络管理</h2>
<p>默认的管理工具是NetworkManager，附带有nmcli网络管理工具</p>
<p>配置命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmcli c add <span class="built_in">type</span> ethernet con-name enp6s18 ifname enp6s18 \</span><br><span class="line">ipv4.addr 192.168.8.211/24 ipv4.gateway 192.168.8.1 ipv4.method manual \</span><br><span class="line">ipv4.dns 192.168.8.1</span><br></pre></td></tr></table></figure>
<p>配置成功后会自动生成配置文件，配置文件地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vim /etc/NetworkManager/system-connections</span></span><br><span class="line">[connection]</span><br><span class="line"><span class="built_in">id</span>=enp6s18</span><br><span class="line">uuid=b944afc1-e640-4b36-ad04-c7342189565f</span><br><span class="line"><span class="built_in">type</span>=ethernet</span><br><span class="line">interface-name=enp6s18</span><br><span class="line"></span><br><span class="line">[ethernet]</span><br><span class="line"></span><br><span class="line">[ipv4]</span><br><span class="line">address1=192.168.8.210/24,192.168.8.1</span><br><span class="line">dns=192.168.8.1;</span><br><span class="line">method=manual</span><br><span class="line"></span><br><span class="line">[ipv6]</span><br><span class="line">addr-gen-mode=default</span><br><span class="line">method=auto</span><br><span class="line"></span><br><span class="line">[proxy]</span><br></pre></td></tr></table></figure>
<p>修改完成后，直接使用nmcli c up即可启动网卡。</p>
<p>rocklinux8一般使用ifup/ifdown进行管理，配置文件地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vim /etc/sysconfig/network-scripts</span></span><br><span class="line">TYPE=Ethernet</span><br><span class="line">PROXY_METHOD=none</span><br><span class="line">BROWSER_ONLY=no</span><br><span class="line">BOOTPROTO=dhcp</span><br><span class="line">DEFROUTE=<span class="built_in">yes</span></span><br><span class="line">IPV4_FAILURE_FATAL=no</span><br><span class="line">IPV6INIT=<span class="built_in">yes</span></span><br><span class="line">IPV6_AUTOCONF=<span class="built_in">yes</span></span><br><span class="line">IPV6_DEFROUTE=<span class="built_in">yes</span></span><br><span class="line">IPV6_FAILURE_FATAL=no</span><br><span class="line">NAME=ens3</span><br><span class="line">UUID=badebd4f-dbf2-4d42-8e49-0e3839499e59</span><br><span class="line">DEVICE=ens3</span><br><span class="line">ONBOOT=<span class="built_in">yes</span></span><br></pre></td></tr></table></figure>
<p>修改完成后，直接使用ifup ifcfg-网卡名即可启动网卡。</p>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>learning</tag>
        <tag>rockylinux</tag>
      </tags>
  </entry>
  <entry>
    <title>运维自动化实战（一）Linux Shell 自动交互</title>
    <url>/p/linux-shell-automatic-interaction/</url>
    <content><![CDATA[<p>本文主要介绍自动化输入脚本的方式。</p>
<p>关键词：<strong>shell</strong></p>
<span id="more"></span>
<h2 id="bash脚本输入方式">bash脚本输入方式</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> -n <span class="string">&quot;ServiceName\nOperator\nPassword&quot;</span> | upx login</span><br></pre></td></tr></table></figure>
<p>输入每行文字后输入一个回车，某些情况不适用。</p>
<h2 id="expect脚本">Expect脚本</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash    </span></span><br><span class="line">/usr/bin/expect &lt;&lt;-<span class="string">EOF</span></span><br><span class="line"><span class="string">set timeout 50</span></span><br><span class="line"><span class="string">spawn upx login </span></span><br><span class="line"><span class="string">expect &quot;*ServiceName*&quot; &#123;send &quot;ServiceName\r&quot;&#125;</span></span><br><span class="line"><span class="string">expect &quot;*Operator*&quot; &#123;send &quot;Operator\r&quot;&#125;</span></span><br><span class="line"><span class="string">expect &quot;*Password*&quot; &#123;send &quot;Password\r&quot;&#125;</span></span><br><span class="line"><span class="string">expect eof</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>
<p>expect 提示的字段是捕获输出，然后在后面跟着输入。</p>
]]></content>
      <tags>
        <tag>devops</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>K8s核心能力</title>
    <url>/p/learn-K8s/</url>
    <content><![CDATA[<p>本文主要记录在上班学（mo）习（yu）时的一些学习记录，本文主要记录的是K8s的学习。</p>
<p><strong>关键词：K8s</strong></p>
<span id="more"></span>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>learning</tag>
      </tags>
  </entry>
  <entry>
    <title>红帽认证RHCSA</title>
    <url>/p/learn-Red-Hat-certification-rhcsa/</url>
    <content><![CDATA[<p>本文主要记录在上班学（mo）习（yu）时的一些学习记录，本文主要记录的是红帽认证RHCSA。</p>
<p><strong>关键词：RHCSA</strong></p>
<span id="more"></span>
<h1 id="红帽认证rhcsa">红帽认证RHCSA</h1>
<h2 id="命令行概述格式快捷键">命令行概述、格式、快捷键</h2>
<figure>
<img data-src="image-20230802155436739.png" alt="image-20230802155436739" />
<figcaption aria-hidden="true">image-20230802155436739</figcaption>
</figure>
<figure>
<img data-src="image-20230802155744136.png" alt="image-20230802155744136" />
<figcaption aria-hidden="true">image-20230802155744136</figcaption>
</figure>
<figure>
<img data-src="image-20230802160003170.png" alt="image-20230802160003170" />
<figcaption aria-hidden="true">image-20230802160003170</figcaption>
</figure>
<figure>
<img data-src="image-20230802160320052.png" alt="image-20230802160320052" />
<figcaption aria-hidden="true">image-20230802160320052</figcaption>
</figure>
<h2 id="常用的命令">常用的命令</h2>
<figure>
<img data-src="image-20230802160459480.png" alt="image-20230802160459480" />
<figcaption aria-hidden="true">image-20230802160459480</figcaption>
</figure>
<p>注意：su 切换到别的用户时建议使用 - 来模拟登录过程。</p>
<figure>
<img data-src="image-20230802165404943.png" alt="image-20230802165404943" />
<figcaption aria-hidden="true">image-20230802165404943</figcaption>
</figure>
<p>mv 移动文件、重命名文件</p>
<h2 id="获取命令的帮助man">获取命令的帮助man</h2>
<figure>
<img data-src="image-20230802171358699.png" alt="image-20230802171358699" />
<figcaption aria-hidden="true">image-20230802171358699</figcaption>
</figure>
<h2 id="vivim编辑器">vi/vim编辑器</h2>
<p><img data-src="image-20230802172136098.png" /></p>
<p>++ yum -y install vim-enhanced 安装增强版的vim</p>
<h2 id="systemctl服务控制">systemctl服务控制</h2>
<figure>
<img data-src="image-20230803092228191.png" alt="image-20230803092228191" />
<figcaption aria-hidden="true">image-20230803092228191</figcaption>
</figure>
<p>++ 重启后生效</p>
<p>++ setenforce 0|1
立即变成宽松模式|强制模式：只能在宽松模式和强制模式之间切换，不能在关闭和打开之前切换。</p>
<p>++ getenforce：获取selinux状态。</p>
<h2 id="网络控制">网络控制</h2>
<p>使用nmtul设置网络。</p>
<figure>
<img data-src="image-20230803100131748.png" alt="image-20230803100131748" />
<figcaption aria-hidden="true">image-20230803100131748</figcaption>
</figure>
<figure>
<img data-src="image-20230803101248194.png" alt="image-20230803101248194" />
<figcaption aria-hidden="true">image-20230803101248194</figcaption>
</figure>
<p>hostname查看主机名，hostnamectl设置主机名</p>
<p>nmcli：networkManager Commander Interface</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  查看网卡设备状态</span></span><br><span class="line">nmcli device status</span><br><span class="line"><span class="comment">#  查看网络连接状态</span></span><br><span class="line">nmcli connection show</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置网络连接</span></span><br><span class="line">nmcli connection modify enp1s0 ipv4.method manal ipv4.addresses 192.168.8.121/24   ipv4.gateway 192.168.8.1 ipv4.dns 192.168.8.1 connection.autoconnect <span class="built_in">yes</span></span><br><span class="line"><span class="comment"># 激活网卡连接</span></span><br><span class="line">nmcli connection up enp1s0</span><br></pre></td></tr></table></figure>
<figure>
<img data-src="image-20230803102043041.png" alt="image-20230803102043041" />
<figcaption aria-hidden="true">image-20230803102043041</figcaption>
</figure>
<figure>
<img data-src="image-20230803103614245.png" alt="image-20230803103614245" />
<figcaption aria-hidden="true">image-20230803103614245</figcaption>
</figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[BaseOSUSTC]</span><br><span class="line">name = BaseOSUSTC</span><br><span class="line">baseurl = https://mirrors.ustc.edu.cn/centos-vault/8.5.2111/BaseOS/x86_64/os/media.repo</span><br><span class="line">gpgcheck = 0</span><br><span class="line"></span><br><span class="line">[AppStreamUSTC]</span><br><span class="line">name = AppStremUSTC</span><br><span class="line">baseurl = https://mirrors.ustc.edu.cn/centos-vault/8.5.2111/AppStream/x86_64/os/media.repo</span><br><span class="line">gpgcheck = 0</span><br></pre></td></tr></table></figure>
<figure>
<img data-src="image-20230803140654846.png" alt="image-20230803140654846" />
<figcaption aria-hidden="true">image-20230803140654846</figcaption>
</figure>
<figure>
<img data-src="image-20230803141927636.png" alt="image-20230803141927636" />
<figcaption aria-hidden="true">image-20230803141927636</figcaption>
</figure>
<h2 id="调试服务">调试服务</h2>
<figure>
<img data-src="image-20230803145531367.png" alt="image-20230803145531367" />
<figcaption aria-hidden="true">image-20230803145531367</figcaption>
</figure>
<h2 id="selinux调试">SELinux调试</h2>
<figure>
<img data-src="image-20230803150645826.png" alt="image-20230803150645826" />
<figcaption aria-hidden="true">image-20230803150645826</figcaption>
</figure>
<figure>
<img data-src="image-20230803152634490.png" alt="image-20230803152634490" />
<figcaption aria-hidden="true">image-20230803152634490</figcaption>
</figure>
<figure>
<img data-src="image-20230803153321589.png" alt="image-20230803153321589" />
<figcaption aria-hidden="true">image-20230803153321589</figcaption>
</figure>
<figure>
<img data-src="image-20230803154524540.png" alt="image-20230803154524540" />
<figcaption aria-hidden="true">image-20230803154524540</figcaption>
</figure>
<figure>
<img data-src="image-20230803155912452.png" alt="image-20230803155912452" />
<figcaption aria-hidden="true">image-20230803155912452</figcaption>
</figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 临时关闭selinux</span></span><br><span class="line">setenforce 0</span><br><span class="line"><span class="comment"># 查看selinx状态</span></span><br><span class="line">getenforce </span><br></pre></td></tr></table></figure>
<h2 id="用户账户管理">用户账户管理</h2>
<figure>
<img data-src="image-20230803160112653.png" alt="image-20230803160112653" />
<figcaption aria-hidden="true">image-20230803160112653</figcaption>
</figure>
<p><img data-src="image-20230804091730441.png" /></p>
<h2 id="归属权限以及acl">归属、权限以及ACL</h2>
<figure>
<img data-src="image-20230804094922756.png" alt="image-20230804094922756" />
<figcaption aria-hidden="true">image-20230804094922756</figcaption>
</figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置某文件/文件夹的属主权限</span></span><br><span class="line"><span class="built_in">chmod</span> u=rx /xxx </span><br><span class="line"><span class="comment"># 设置某文件/文件夹的属组权限</span></span><br><span class="line"><span class="built_in">chmod</span> g+rx /xxx </span><br><span class="line"><span class="comment"># 设置某文件/文件夹的其他人权限</span></span><br><span class="line"><span class="built_in">chmod</span> o-rx /xxx </span><br></pre></td></tr></table></figure>
<figure>
<img data-src="image-20230804110002258.png" alt="image-20230804110002258" />
<figcaption aria-hidden="true">image-20230804110002258</figcaption>
</figure>
<figure>
<img data-src="image-20230804143107386.png" alt="image-20230804143107386" />
<figcaption aria-hidden="true">image-20230804143107386</figcaption>
</figure>
<p>使用访问控制列表设置zhangsan能读能写：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">setfacl -m user:zhangsan:rw /var/tmp/hosts</span><br></pre></td></tr></table></figure>
<p>使用访问控制列表设置lisi不能读不能写：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">setfacl -m user:lisi:--- /var/tmp/hosts</span><br></pre></td></tr></table></figure>
<h3 id="附加权限">附加权限</h3>
<p><img data-src="image-20230804110835797.png" /></p>
<h2 id="ntp同步">NTP同步</h2>
<figure>
<img data-src="image-20230804151425466.png" alt="image-20230804151425466" />
<figcaption aria-hidden="true">image-20230804151425466</figcaption>
</figure>
<figure>
<img data-src="image-20230804154830315.png" alt="image-20230804154830315" />
<figcaption aria-hidden="true">image-20230804154830315</figcaption>
</figure>
<h2 id="查找文件">查找文件</h2>
<figure>
<img data-src="image-20230804160644701.png" alt="image-20230804160644701" />
<figcaption aria-hidden="true">image-20230804160644701</figcaption>
</figure>
<p>查找文件大于5KB，文件名是以file为开头，同时需要使用ls
-lh查看大小的文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find /etc -size +5k -name <span class="string">&quot;file*&quot;</span> -<span class="built_in">exec</span> <span class="built_in">ls</span> -lh &#123;&#125; \;</span><br></pre></td></tr></table></figure>
<figure>
<img data-src="image-20230804161536008.png" alt="image-20230804161536008" />
<figcaption aria-hidden="true">image-20230804161536008</figcaption>
</figure>
<h2 id="查找字符串">查找字符串</h2>
<figure>
<img data-src="image-20230804164614308.png" alt="image-20230804164614308" />
<figcaption aria-hidden="true">image-20230804164614308</figcaption>
</figure>
<figure>
<img data-src="image-20230804164653597.png" alt="image-20230804164653597" />
<figcaption aria-hidden="true">image-20230804164653597</figcaption>
</figure>
<p>题目：</p>
<figure>
<img data-src="image-20230804164830102.png" alt="image-20230804164830102" />
<figcaption aria-hidden="true">image-20230804164830102</figcaption>
</figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep sbin /etc/man_db.conf &gt; /root/out.txt</span><br></pre></td></tr></table></figure>
<h2 id="归档和压缩">归档和压缩</h2>
<p><img data-src="image-20230804165655396.png" /></p>
<h2 id="配置autofs">配置autoFS</h2>
<figure>
<img data-src="image-20230807094123859.png" alt="image-20230807094123859" />
<figcaption aria-hidden="true">image-20230807094123859</figcaption>
</figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 挂载远程资源</span></span><br><span class="line">mount 10.10.10.1:/home/wf09 /mnt</span><br></pre></td></tr></table></figure>
<figure>
<img data-src="image-20230807100925339.png" alt="image-20230807100925339" />
<figcaption aria-hidden="true">image-20230807100925339</figcaption>
</figure>
<figure>
<img data-src="image-20230807112248031.png" alt="image-20230807112248031" />
<figcaption aria-hidden="true">image-20230807112248031</figcaption>
</figure>
<figure>
<img data-src="image-20230807112546761.png" alt="image-20230807112546761" />
<figcaption aria-hidden="true">image-20230807112546761</figcaption>
</figure>
<h2 id="设置root密码">设置ROOT密码</h2>
<figure>
<img data-src="image-20230807144542841.png" alt="image-20230807144542841" />
<figcaption aria-hidden="true">image-20230807144542841</figcaption>
</figure>
<figure>
<img data-src="image-20230807145422169.png" alt="image-20230807145422169" />
<figcaption aria-hidden="true">image-20230807145422169</figcaption>
</figure>
<h2 id="配置网络">配置网络</h2>
<p><img data-src="image-20230807150656550.png" /></p>
<h2 id="磁盘分区">磁盘分区</h2>
<figure>
<img data-src="image-20230807151801644.png" alt="image-20230807151801644" />
<figcaption aria-hidden="true">image-20230807151801644</figcaption>
</figure>
<figure>
<img data-src="image-20230807153835938.png" alt="image-20230807153835938" />
<figcaption aria-hidden="true">image-20230807153835938</figcaption>
</figure>
<h2 id="逻辑卷">逻辑卷</h2>
<figure>
<img data-src="image-20230807164615687.png" alt="image-20230807164615687" />
<figcaption aria-hidden="true">image-20230807164615687</figcaption>
</figure>
<figure>
<img data-src="image-20230808094037624.png" alt="image-20230808094037624" />
<figcaption aria-hidden="true">image-20230808094037624</figcaption>
</figure>
<figure>
<img data-src="image-20230808094900139.png" alt="image-20230808094900139" />
<figcaption aria-hidden="true">image-20230808094900139</figcaption>
</figure>
<figure>
<img data-src="image-20230808101315117.png" alt="image-20230808101315117" />
<figcaption aria-hidden="true">image-20230808101315117</figcaption>
</figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 创建卷组并指定扩展块</span></span><br><span class="line">vgcreate -s 16M myvg /dev/nvme0n1p3</span><br><span class="line"><span class="comment"># 创建逻辑卷并设置大小为50个扩展单元</span></span><br><span class="line">lvcreate -n mylv -L 800M myvg</span><br><span class="line"><span class="comment"># 格式化成vfat格式</span></span><br><span class="line">mkfs.vfat /dev/myvg/mylv</span><br><span class="line"><span class="comment"># 设置自动挂载</span></span><br><span class="line"><span class="comment"># vim /etc/fstab</span></span><br><span class="line">/dev/myvg/mylv    /mnt/mylv  vfat defaults 0 0</span><br></pre></td></tr></table></figure>
<h2 id="vdo虚拟卷">VDO虚拟卷</h2>
<figure>
<img data-src="image-20230808102351816.png" alt="image-20230808102351816" />
<figcaption aria-hidden="true">image-20230808102351816</figcaption>
</figure>
<figure>
<img data-src="image-20230808103639259.png" alt="image-20230808103639259" />
<figcaption aria-hidden="true">image-20230808103639259</figcaption>
</figure>
<blockquote>
<p>总结成一句话：用实际容量小的物理磁盘创建容量大的逻辑磁盘</p>
</blockquote>
<p><img data-src="image-20230808104325531.png"
alt="image-20230808104325531" /> <img data-src="image-20230808105540492.png"
alt="image-20230808105540492" /></p>
<figure>
<img data-src="image-20230808111305131.png" alt="image-20230808111305131" />
<figcaption aria-hidden="true">image-20230808111305131</figcaption>
</figure>
<figure>
<img data-src="image-20230808111331418.png" alt="image-20230808111331418" />
<figcaption aria-hidden="true">image-20230808111331418</figcaption>
</figure>
<figure>
<img data-src="image-20230808111345237.png" alt="image-20230808111345237" />
<figcaption aria-hidden="true">image-20230808111345237</figcaption>
</figure>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>learning</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenWRT x86各个版本的区别</title>
    <url>/p/the-difference-between-each-version-of-openwrt(x86)/</url>
    <content><![CDATA[<p>本文主要记录在上班学（mo）习（yu）时的一些学习记录，本文主要记录的是OpenWRT
X86各个架构的区别。</p>
<p><strong>关键词： OpenWRT x86各个版本的区别</strong></p>
<span id="more"></span>
<p>简单介绍 <a
href="https://itlangzi.com/jump.html?https:%2F%2Fopenwrt.org%2F">openwrt</a>
<code>x86</code> 平台各个版本的区别</p>
<p>x86 OpenWrt
有多个目标，其中一些针对旧的或特定的硬件，它们的构建默认值可能不适合现代
x86 硬件：</p>
<ul>
<li><strong>64</strong>适用于现代 PC 硬件（从 2007
年左右开始的任何硬件），它是为 64 位功能的计算机构建的，并且支持现代 CPU
功能。除非您有充分的理由不这样做，否则请选择此选项。</li>
<li><strong>Generic</strong>适用于仅 32 位的硬件（旧硬件或某些 Atom
处理器），应该是<strong>i686</strong> Linux 架构，可在 Pentium 4
及更高版本上工作。仅当您的硬件无法运行 64 位版本时才使用此选项。</li>
<li><strong>Legacy</strong>是针对非常老的PC硬件，Pentium
MMX，在Linux架构中被称为<strong>i586的支持。</strong>它将错过您在现代硬件上想要/需要的许多功能，例如多核支持和对
4GB 以上 RAM
的支持，但实际上可以在古老的硬件上运行，而其他版本则不能。</li>
<li><strong>Geode</strong>是为 Geode SoC
定制的传统目标，它仍在许多（老化的）网络设备中使用，例如 PCEngines 的旧
Alix 板。</li>
</ul>
<h1 id="ext4-combined-efi.img.gz">1. ext4-combined-efi.img.gz</h1>
<ul>
<li>使用可读写的<code>ext4</code>分区，没有<code>squashfs</code>的只读文件系统</li>
<li>根分区可以使用更大的驱动器(e.g. SSD/SATA/mSATA/SATA
DOM/NVMe/etc)进行扩展</li>
<li>没有故障安全模式和出厂重置等功能，这些功能需要<code>squashfs</code>的支持</li>
<li>自带引导分区和根分区以及主引导记录 (MBR) 区域以及更新的 GRUB2</li>
<li>支持efi引导</li>
</ul>
<h1 id="ext4-combined.img.gz">2. ext4-combined.img.gz</h1>
<ul>
<li><a
href="https://itlangzi.com/s/FCZV11.html#1-ext4-combined-efiimggz">同1</a>，但不支持efi引导</li>
</ul>
<h1 id="ext4-rootfs.img.gz">3. ext4-rootfs.img.gz</h1>
<ul>
<li>只有根分区的镜像，重新安装不会覆盖引导分区和主引导记录 (MBR)，</li>
<li>由于不带引导分区，首次安装需要自行使用<code>grub</code>或者<code>syslinux</code>来引导</li>
<li>使用<code>ext4</code>分区</li>
</ul>
<h1 id="kernel.bin">4. kernel.bin</h1>
<ul>
<li>独立的内核</li>
</ul>
<h1 id="squashfs-combined-efi.img.gz">5.
squashfs-combined-efi.img.gz</h1>
<ul>
<li><code>squashfs</code>是个只读的文件系统,
相当于<code>windows</code>的<code>ghost</code>,
支持故障安全模式和出厂重置等功能</li>
<li>包含一个只读的根文件系统和一个存储设置以及安装软件可读写的分区</li>
<li>组合模式，只有不到<code>100MB</code>的空间来存储额外的包和配置，并且无法扩展根分区</li>
<li>支持efi引导</li>
</ul>
<h1 id="squashfs-combined.img.gz">6. squashfs-combined.img.gz</h1>
<ul>
<li><a
href="https://itlangzi.com/s/FCZV11.html#5-squashfs-combined-efiimggz">同5</a>，但不支持efi引导</li>
</ul>
<h1 id="squashfs-rootfs.img.gz">7. squashfs-rootfs.img.gz</h1>
<ul>
<li><不知道是干啥的></li>
</ul>
<h1 id="rootfs.tar.gz">8. rootfs.tar.gz</h1>
<ul>
<li>所有的文件都在根目录下</li>
<li>不带引导，需要自行使用<code>grub</code>或者<code>syslinux</code>来引导</li>
</ul>
<p><strong>建议:</strong></p>
<ul>
<li>需要扩展分区使用:
<code>combined-ext4.img.gz</code>和<code>ext4-combined-efi.img.gz</code></li>
<li>不需要扩展分区使用:
<code>squashfs-combined.img.gz</code>和<code>squashfs-combined-efi.img.gz</code></li>
</ul>
<p><strong>参考:</strong></p>
<ol type="1">
<li><a
href="">https://openwrt.org/docs/guide-user/installation/openwrt_x86</a></li>
</ol>
]]></content>
      <tags>
        <tag>learning</tag>
        <tag>OpenWRT</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建zabbix监控系统</title>
    <url>/p/install-zabbix/</url>
    <content><![CDATA[<p>本文主要记录在上班学（mo）习（yu）时的一些学习记录，本文主要记录的是zabbix监控系统的学习。</p>
<p><strong>关键词：zabbix</strong></p>
<span id="more"></span>
<h2 id="zabbix架构">zabbix架构</h2>
<p><img data-src="使用docker搭建zabbix监控系统/image-20230811085633556.png" /></p>
<h2 id="镜像种类">镜像种类</h2>
<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 45%" />
<col style="width: 45%" />
</colgroup>
<thead>
<tr class="header">
<th>说明</th>
<th>镜像</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Zabbix agent</td>
<td><a
href="https://hub.docker.com/r/zabbix/zabbix-agent/">zabbix/zabbix-agent</a></td>
<td></td>
</tr>
<tr class="even">
<td>Zabbix server</td>
<td><a
href="https://hub.docker.com/r/zabbix/zabbix-server-mysql/">zabbix/zabbix-server-mysql</a></td>
<td>支持 MySQL 数据库的 Zabbix server</td>
</tr>
<tr class="odd">
<td></td>
<td><a
href="https://hub.docker.com/r/zabbix/zabbix-server-pgsql/">zabbix/zabbix-server-pgsql</a></td>
<td>支持 PostgreSQL 数据库的 Zabbix server</td>
</tr>
<tr class="even">
<td>Zabbix web UI</td>
<td><a
href="https://hub.docker.com/r/zabbix/zabbix-web-apache-mysql/">zabbix/zabbix-web-apache-mysql</a></td>
<td>基于Apache2 Web服务器 的 Zabbix web 界面，支持 MySQL 数据库</td>
</tr>
<tr class="odd">
<td></td>
<td><a
href="https://hub.docker.com/r/zabbix/zabbix-web-apache-pgsql/">zabbix/zabbix-web-apache-pgsql</a></td>
<td>基于Apache2 Web服务器 的 Zabbix web 界面，支持 PostgreSQL
数据库</td>
</tr>
<tr class="even">
<td></td>
<td><a
href="https://hub.docker.com/r/zabbix/zabbix-web-nginx-mysql/">zabbix/zabbix-web-nginx-mysql</a></td>
<td>基于Nginx Web服务器 的 Zabbix web 界面，支持 MySQL 数据库</td>
</tr>
<tr class="odd">
<td></td>
<td><a
href="https://hub.docker.com/r/zabbix/zabbix-web-nginx-pgsql/">zabbix/zabbix-web-nginx-pgsql</a></td>
<td>基于Nginx Web服务器 的 Zabbix web 界面，支持 PostgreSQL 数据库</td>
</tr>
<tr class="even">
<td>Zabbix proxy</td>
<td><a
href="https://hub.docker.com/r/zabbix/zabbix-proxy-sqlite3/">zabbix/zabbix-proxy-sqlite3</a></td>
<td>Zabbix proxy ，支持 SQLite3 数据库（Zabbix
proxy是使得Zabbix支持分布式监控的扩展的组件）</td>
</tr>
<tr class="odd">
<td></td>
<td><a
href="https://hub.docker.com/r/zabbix/zabbix-proxy-mysql/">zabbix/zabbix-proxy-mysql</a></td>
<td>Zabbix proxy， 支持 MySQL 数据库</td>
</tr>
<tr class="even">
<td></td>
<td><a
href="https://hub.docker.com/r/zabbix/zabbix-java-gateway/">zabbix/zabbix-java-gateway</a></td>
<td>Zabbix Java 网关（Zabbix
Java网关是用于与Java应用程序中集成并监控其性能和状态，可以充当Zabbix服务器与Java
应用程序之间的中间代理）</td>
</tr>
</tbody>
</table>
<h2 id="docker-compose.yml文件">docker-compose.yml文件</h2>
<p>根据架构图，zabbix主要有以下组件：</p>
<ul>
<li>zabbix
server服务端，负责处理由agent或者proxy发送来的数据，并将这部分数据写入数据库。与这部分相关的docker配置文件如下</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">zabbix/zabbix-server-mysql</span></span><br><span class="line">  <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="comment">#- ./zabbix:/etc/zabbix</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">./alertscripts:/usr/lib/zabbix/alertscripts</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/etc/localtime:/etc/localtime</span></span><br><span class="line">  <span class="attr">environment:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">DB_SERVER_HOST=192.168.15.131</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">MYSQL_DATABASE=zabbix</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">MYSQL_USER=zabbix</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">MYSQL_PASSWORD=zabbix</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">MYSQL_ROOT_PASSWORD=root</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ZBX_JAVAGATEWAY=192.168.15.131</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ZBX_JAVAGATEWAY_ENABLE=true</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ZBX_JAVAGATEWAYPORT=10052</span></span><br></pre></td></tr></table></figure>
<p>主要设置以下几个地方：</p>
<ol type="1">
<li>DB_SERVER_HOST：这部分是设置后端数据库的地址，如果两者在同一台机器上直接使用localhost即可。</li>
<li>MYSQL_DATABASE：数据库名称，默认是zabbix。</li>
<li>MYSQL_USER：zabbix数据库的用户名，默认也是zabbix。</li>
<li>MYSQL_PASSWORD：zabbix数据库的密码，默认也是zabbix。</li>
<li>MYSQL_ROOT_PASSWORD：数据库的root密码</li>
<li>ZBX_JAVAGATEWAY：java gateway的地址，这里以容器的名称代替。</li>
<li>ZBX_JAVAGATEWAY_ENABLE：设置是否启用java gateway。</li>
<li>ZBX_JAVAGATEWAYPORT：java gateway的端口。</li>
</ol>
<blockquote>
<p>配置文件目录对应/etc/zabbix/zabbix_server.conf</p>
</blockquote>
<ul>
<li>zabbix 需要连接的mysql数据库</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mysql:</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">mysql:debian</span></span><br><span class="line">  <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">  <span class="attr">environment:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">MYSQL_DATABASE=zabbix</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">MYSQL_USER=zabbix</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">MYSQL_PASSWORD=zabbix</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">MYSQL_ROOT_PASSWORD=root</span></span><br><span class="line">  <span class="attr">command:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">mysqld</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--default-authentication-plugin=mysql_native_password</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--character-set-server=utf8</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--collation-server=utf8_bin</span></span><br></pre></td></tr></table></figure>
<p>这部分是zabbix连接的mysql数据库，需要注意的是mysql的版本对于某个特定版本可能会有要求，这个可以在日志中查看到对应的报错。</p>
<ul>
<li><p>zabbix的java
gateway：可以通过JAVA程序的JMX特性连接到JAVA应用程序，进而查看JAVA应用程序的性能。这部分没有默认设置。</p>
<blockquote>
<p>该应用程序的默认端口是10052，这个端口和设置的JMX端口不同，一个是客户端（应用程序）的端口（JMX端口），另外一个相当于是代理的gateway端口（默认工作在10052）</p>
</blockquote></li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">zabbix-java-gateway:</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">zabbix/zabbix-java-gateway</span></span><br><span class="line">  <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/etc/localtime:/etc/localtime</span></span><br><span class="line">  <span class="attr">network_mode:</span> <span class="string">host</span></span><br></pre></td></tr></table></figure>
<ul>
<li>zabbix的前端展示界面，一般是php+nginx的环境。</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">zabbix-web-nginx-mysql:</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">zabbix/zabbix-web-nginx-mysql</span></span><br><span class="line">  <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">  <span class="attr">environment:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">DB_SERVER_HOST=192.168.15.131</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">MYSQL_DATABASE=zabbix</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">MYSQL_USER=zabbix</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">MYSQL_PASSWORD=zabbix</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">MYSQL_ROOT_PASSWORD=root</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ZBX_SERVER_HOST=192.168.15.131</span></span><br><span class="line">  <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">network_mode:</span> <span class="string">host</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/etc/localtime:/etc/localtime</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">./Song.ttf:/usr/share/zabbix/assets/fonts/DejaVuSans.ttf</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里注意区分DB_SERVER_HOST和ZBX_SERVER_HOST的区别，一个是连接后端数据库的端口，另一个是连接zabbix服务端的端口。</p>
<p>此外容器的默认字体无法正常显示中文，这里使用宋体进行替换。</p>
</blockquote>
<ul>
<li>zabbix的代理客户端：负责监控当前主机的组件,
配合自定义的脚本可以实现自定义监控.</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">zabbix-agent:</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">zabbix/zabbix-agent</span></span><br><span class="line">  <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">  <span class="attr">environment:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ZBX_HOSTNAME=Zabbix</span> <span class="string">server</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ZBX_SERVER_HOST=192.168.15.131</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ZBX_SERVER_PORT=10051</span></span><br><span class="line">  <span class="attr">network_mode:</span> <span class="string">host</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>主要设置Zabbix Server的IP地址和Zabbix的端口地址</p>
</blockquote>
<p>总体zabbix配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">zabbix-web-nginx-mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">zabbix/zabbix-web-nginx-mysql</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_SERVER_HOST=192.168.15.131</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_DATABASE=zabbix</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_USER=zabbix</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_PASSWORD=zabbix</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_ROOT_PASSWORD=root</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ZBX_SERVER_HOST=192.168.15.131</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">host</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/etc/localtime:/etc/localtime</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./Song.ttf:/usr/share/zabbix/assets/fonts/DejaVuSans.ttf</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">zabbix-server-mysql</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">zabbix-mysql</span></span><br><span class="line">  <span class="attr">zabbix-mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:debian</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_DATABASE=zabbix</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_USER=zabbix</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_PASSWORD=zabbix</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_ROOT_PASSWORD=root</span></span><br><span class="line">    <span class="attr">command:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysqld</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">--default-authentication-plugin=mysql_native_password</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">--character-set-server=utf8</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">--collation-server=utf8_bin</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/etc/localtime:/etc/localtime</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./db:/var/lib/mysql</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">host</span></span><br><span class="line">  <span class="attr">zabbix-java-gateway:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">zabbix/zabbix-java-gateway</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/etc/localtime:/etc/localtime</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">host</span></span><br><span class="line">  <span class="attr">zabbix-server-mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">zabbix/zabbix-server-mysql</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="comment">#- ./zabbix:/etc/zabbix</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./alertscripts:/usr/lib/zabbix/alertscripts</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/etc/localtime:/etc/localtime</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_SERVER_HOST=192.168.15.131</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_DATABASE=zabbix</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_USER=zabbix</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_PASSWORD=zabbix</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_ROOT_PASSWORD=root</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ZBX_JAVAGATEWAY=192.168.15.131</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ZBX_JAVAGATEWAY_ENABLE=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ZBX_JAVAGATEWAYPORT=10052</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">zabbix-mysql</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">host</span></span><br><span class="line">  <span class="attr">zabbix-agent:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">zabbix/zabbix-agent</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ZBX_HOSTNAME=Zabbix</span> <span class="string">server</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ZBX_SERVER_HOST=192.168.15.131</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ZBX_SERVER_PORT=10051</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">host</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>zabbix</tag>
      </tags>
  </entry>
  <entry>
    <title>鸟哥的私房菜：基础学习篇</title>
    <url>/p/the-basics-of-learning-private-kitchen-in-linux/</url>
    <content><![CDATA[<p>本文主要记录在上班学（mo）习（yu）时的一些学习记录，本文主要记录的是鸟哥的私房菜</p>
<p><strong>关键词：鸟哥的私房菜</strong></p>
<span id="more"></span>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>learning</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Nginx进行反向代理</title>
    <url>/p/reverse-proxy-with-nginx/</url>
    <content><![CDATA[<p>本文介绍如何使用Nginx的流（stream）模块对指定网站进行反向代理。</p>
<p><strong>关键词：Nginx，反向代理</strong></p>
<span id="more"></span>
<p>Nginx的stream模块可以通过SNI（服务器名称指示）进行识别，可以设置根据不同的SNI名访问不同的upstream（上游）。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">user</span> root;</span><br><span class="line"><span class="attribute">worker_processes</span> auto;</span><br><span class="line"><span class="attribute">error_log</span> /var/log/nginx/<span class="literal">error</span>.log;</span><br><span class="line"></span><br><span class="line"><span class="attribute">include</span> /usr/share/nginx/modules/<span class="regexp">*.conf</span>;</span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">use</span> <span class="literal">epoll</span>;</span><br><span class="line">    <span class="attribute">multi_accept</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">accept_mutex</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">worker_connections</span> <span class="number">65535</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">stream</span> &#123;</span><br><span class="line">    <span class="attribute">log_format</span> proxy <span class="string">&#x27;<span class="variable">$remote_addr</span> [<span class="variable">$time_local</span>] &#x27;</span></span><br><span class="line">                 <span class="string">&#x27;<span class="variable">$protocol</span> <span class="variable">$status</span> <span class="variable">$bytes_sent</span> <span class="variable">$bytes_received</span> &#x27;</span></span><br><span class="line">                 <span class="string">&#x27;<span class="variable">$session_time</span> &quot;<span class="variable">$upstream_addr</span>&quot; &#x27;</span></span><br><span class="line">                 <span class="string">&#x27;&quot;<span class="variable">$upstream_bytes_sent</span>&quot; &quot;<span class="variable">$upstream_bytes_received</span>&quot; &quot;<span class="variable">$upstream_connect_time</span>&quot;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">access_log</span> /var/log/nginx/tcp-access.log proxy;</span><br><span class="line">    <span class="attribute">open_log_file_cache</span> <span class="literal">off</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># SNI识别，将一个个域名映射成一个配置名</span></span><br><span class="line">    <span class="attribute">map</span> <span class="variable">$ssl_preread_server_name</span> <span class="variable">$stream_map</span> &#123;</span><br><span class="line">        <span class="attribute">default</span> others;</span><br><span class="line">        cloudflare.<span class="attribute">com</span> cloudflare;</span><br><span class="line">        ocsp.pki.<span class="attribute">goog</span> google; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">upstream</span> cloudflare &#123;</span><br><span class="line">        <span class="attribute">server</span> cloudflare.com:<span class="number">443</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># upstream, 也就是流量上游的配置</span></span><br><span class="line">    <span class="section">upstream</span> google &#123;</span><br><span class="line">        <span class="attribute">server</span> ocsp.pki.goog:<span class="number">443</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">upstream</span> others &#123;</span><br><span class="line">        <span class="attribute">server</span> unix:/dev/shm/nginx.sock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># stream模块监听443端口，并进行端口复用</span></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">443</span> reuseport;</span><br><span class="line">        <span class="attribute">proxy_pass</span> <span class="variable">$stream_map</span>;</span><br><span class="line">        <span class="attribute">ssl_preread</span> <span class="literal">on</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上图代码中，cloudflare作为配置名，对应cloudflare.com:443的流量上游；</p>
<p>google作为配置名，对应google.com:443的流量上游。</p>
<p>定义一个others配置，对应其余的SNI，也就是默认配置。</p>
]]></content>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Go操作数据库(二)</title>
    <url>/p/go-with-database-2/</url>
    <content><![CDATA[<p>MySQL是常用的关系数据库，本文主要介绍Go语言怎么操作MySQL数据库。</p>
<p>关键词：<strong>golang</strong></p>
<p>在项目中我们通常会使用<code>database/sql</code>连接MySQL数据库。本文结束<code>sqlx</code>实现批量插入数据的例子，介绍了<code>sqlx</code>中可能被忽略的<code>sqlx.In</code>和<code>DB.NameExec</code>方法。</p>
<span id="more"></span>
<h2 id="sqlx介绍">sqlx介绍</h2>
<p><code>sqlx</code>被分为是<code>database/sql</code>的超集，在<code>database/sql</code>的基础上提供了一组扩展，而这组扩展处理大家常用来查询的<code>Get(dest interface&#123;&#125;, ...) error</code>和<code>Select(dest interface&#123;&#125;, ...) error</code>之外，还有很多强大的功能。</p>
<p>仓库地址：<a
href="github.com/jmoiron/sqlx">github.com/jmoiron/sqlx</a></p>
<h2 id="安装">安装</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get github.com/jmoiron/sqlx</span><br></pre></td></tr></table></figure>
<h2 id="基本使用">基本使用</h2>
<h3 id="连接数据库">连接数据库</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> db *sqlx.DB</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initDB</span><span class="params">()</span></span> (err <span class="type">error</span>)&#123;</span><br><span class="line">    dsn := <span class="string">&quot;user:password@tcp(xxx.aws.us-west-1.rds.amazonaws.com:3306)/mt_subtitle_table?charset=utf8mb4&amp;parseTime=True&quot;</span></span><br><span class="line">    <span class="comment">//也可以使用MustConnect，连接不成功就panic</span></span><br><span class="line">    db, err = sqlx.Connect(<span class="string">&quot;mysql&quot;</span>, dsn)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;connect DB failed, err:%v&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    db.SetMaxOpenConns(<span class="number">20</span>)              <span class="comment">// 设置最大连接数</span></span><br><span class="line">    db.SetMaxIdleConns(<span class="number">10</span>)			   <span class="comment">// 设置最大闲置连接数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查询">查询</h3>
<h4 id="查询单行数据">查询单行数据</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查询单条数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">queryRowDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sqlStr := <span class="string">&quot;select id, actress, title from mt_subtitle_table where id = ?&quot;</span></span><br><span class="line">    <span class="keyword">var</span> m Moive</span><br><span class="line">    err := db.Get(&amp;m, sqlStr, <span class="string">&quot;AAA-001&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;get failed, err :%v&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;m: %v&quot;</span>, m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="查询多行数据">查询多行数据</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">queryMultRowDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sqlStr := <span class="string">&quot;select id, actress, title from mt_subtitle_table where actress= ?&quot;</span></span><br><span class="line">   	<span class="keyword">var</span> movies []Movie</span><br><span class="line">    err := db.Select(&amp;moives, sqlStr, <span class="string">&quot;川岛芳子&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;query failed, err :%v&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;movies: %#v&quot;</span>, movies)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="插入更新和删除">插入、更新和删除</h3>
<p>sqlx中的exec方法和原生sql中的exec使用基本一致：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//插入数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertRowDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sqlStr := <span class="string">&quot;insert into mt_subtitle_table(id, actress, title) values (?,?)&quot;</span></span><br><span class="line">    ret, err := db.Exec(sqlStr, <span class="string">&quot;AAA-002&quot;</span>, <span class="string">&quot;仲川そら&quot;</span>,<span class="string">&quot;赤面羞恥&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;insert failed, err:%v&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    theID, err := ret.LastInsertId() <span class="comment">// 新插入数据的id</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;get lastinsert ID failed, err:%v&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;insert success, the id is %d&quot;</span>, theID)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 更新数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">updateRowDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sqlStr := <span class="string">&quot;update mt_subtitle_table set actress=? where id = ?&quot;</span></span><br><span class="line">    ret, err := db.Exec(sqlStr, <span class="string">&quot;仲川そら&quot;</span>, <span class="string">&quot;マジックミラ&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;update failed, err:%v&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    n, err := ret.RowAffected() <span class="comment">// 影响操作的行数</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;get RowAffected failed, err:%v&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;update success, affected rows:%d&quot;</span>, n)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 删除数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteRowDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sqlStr := <span class="string">&quot;delete from mt_subtitle_table where id = ?&quot;</span></span><br><span class="line">    ret, err := db.Exec(sqlStr, <span class="string">&quot;AAA-002&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;delete failed, err:%v&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    n, err := ret.RowsAffected() <span class="comment">// 影响操作的行数</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;get RowAffected failed, err:%v&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;delete success, affected rows:%d&quot;</span>, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="namedexec">NamedExec</h3>
<p><code>DB.NamedExec</code>方法用来绑定SQL语句与<strong>结构体或者map中的同名字段</strong>。</p>
<p>map同名字段</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertUserDemo</span><span class="params">()</span></span> (err <span class="type">error</span>)  &#123;</span><br><span class="line">    sqlStr := <span class="string">&quot;INSERT INTO mt_subtitle_table(id, actress, title) values(:name, :age)&quot;</span></span><br><span class="line">    _, err = db.NamedExec(sqlStr,</span><br><span class="line">                          <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">                              <span class="string">&quot;id&quot;</span>: <span class="string">&quot;ABC-001&quot;</span>,</span><br><span class="line">                              <span class="string">&quot;actress&quot;</span>: <span class="string">&quot;川岛芳子&quot;</span>,</span><br><span class="line">                              <span class="string">&quot;title&quot;</span>: <span class="string">&quot;上海回忆录&quot;</span></span><br><span class="line">                          &#125;)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>:字段名</code>的用法要记住。</li>
</ul>
<p>结构体同名字段</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    FirstName <span class="type">string</span> <span class="string">`db:&quot;first_name&quot;`</span></span><br><span class="line">    LastName  <span class="type">string</span> <span class="string">`db:&quot;last_name&quot;`</span></span><br><span class="line">    Email     <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tx.NamedExec(<span class="string">&quot;INSERT INTO person (first_name, last_name, email) VALUES (:first_name, :last_name, :email)&quot;</span>, &amp;Person&#123;<span class="string">&quot;Jane&quot;</span>, <span class="string">&quot;Citizen&quot;</span>, <span class="string">&quot;jane.citzen@example.com&quot;</span>&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="namedquery">NamedQuery</h3>
<p>与<code>DB.NamedExec</code>同理，这里是支持查询</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nameQuery</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sqlStr := <span class="string">&quot;SELECT * FROM mt_subtitle_table WHERE actress=:actress&quot;</span></span><br><span class="line">    <span class="comment">// 使用map做命名查询</span></span><br><span class="line">    rows, err := db.NamedQuery(sqlStr, <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">        <span class="string">&quot;actress&quot;</span>: <span class="string">&quot;川岛芳子&quot;</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;dn.NamedQuery failed, err:%v&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> rows.Close()</span><br><span class="line">    <span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">        <span class="keyword">var</span> m Movie</span><br><span class="line">        err := rows.StructScan(&amp;m)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;scan failed, err: %v&quot;</span>, err)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;movie: %v&quot;</span>, m)</span><br><span class="line">    &#125;</span><br><span class="line">    m1 := Movie&#123;</span><br><span class="line">        Id: <span class="string">&quot;SNAA-001&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用结构体命名查询，根据结构体的 db tag 进行映射</span></span><br><span class="line">    rows, err := db.NameQuery(sqlStr, m1)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;db.NamedQuery failed, err: %v&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> rows.Close() </span><br><span class="line">    <span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">        <span class="keyword">var</span> m Moive</span><br><span class="line">        err != rows.StructScan(&amp;m)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;scan failed, err:%v&quot;</span>, err)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;movie: %#v&quot;</span>, m)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="事务操作">事务操作</h3>
<p>对于事务操作，我们可以使用<code>sqlx</code>中提供的<code>db.Beginx()</code>和<code>tx.Exec()</code>方法。
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">transationDemo</span><span class="params">()</span></span> (err <span class="type">error</span>) &#123;</span><br><span class="line">    tx. err := db.Begin() <span class="comment">// 开启事务</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Prinf(<span class="string">&quot;事务开始失败，错误:%v&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// return之前执行</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> p := <span class="built_in">recover</span>(); p != <span class="literal">nil</span> &#123;</span><br><span class="line">            tx.Rollback()</span><br><span class="line">            <span class="built_in">panic</span>(p)      <span class="comment">// 回滚之后重新panic</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;rollback&quot;</span>)</span><br><span class="line">            tx.Rollback() <span class="comment">// 有错误，因此需要回滚</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            err = tx.Commit() <span class="comment">// 没有错误，提交事务</span></span><br><span class="line">            fmt.Println(<span class="string">&quot;commit&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    </span><br><span class="line">    sqlStr1 := <span class="string">&quot;UPDATE mt_subtitle_table SET title=&#x27;艺妓回忆录&#x27; where id = ?&quot;</span></span><br><span class="line">    rs, err := tx.Exec(sqlStr1, <span class="string">&quot;ABC-001&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> n != <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> errors.New(<span class="string">&quot;sqlStr1执行失败&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    sqlStr2 := <span class="string">&quot;UPDATE mt_subtitle_table SET title=&#x27;上海回忆录&#x27; where id = ?&quot;</span></span><br><span class="line">    rs, err := tx.Exec(sqlStr2, <span class="string">&quot;AAA-001&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    n, err = rs.RowsAffected()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> n != <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> errors.New(<span class="string">&quot;sqlStr2执行失败&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="sqlx.in">sqlx.In</h2>
<p><code>sqlx.In</code>
是<code>sqlx</code>提供的一个非常方便的函数。</p>
<h3 id="批量插入">批量插入</h3>
<p>这里创建一个表，表结构如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `mt_subtitle_table`  (</span><br><span class="line">  `id` text <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `actress` text <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `title` text <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">)ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br></pre></td></tr></table></figure>
<p>定义一个结构体，字段通过tag和上述表中的字段一致。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Moive <span class="keyword">struct</span>&#123;</span><br><span class="line">    ID <span class="type">string</span> <span class="string">`db:&quot;id&quot;`</span></span><br><span class="line">    Actress <span class="type">string</span> <span class="string">`db:&quot;actress&quot;`</span></span><br><span class="line">    Title <span class="type">string</span> <span class="string">`db:&quot;title&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>绑定变量：bindvars</strong></p>
<p>查询占位符<code>?</code>又被称为<strong>bindvars</strong>，非常重要，应该<strong>始终使用它们向数据库发送值</strong>，因为他们可以防止SQL注入攻击。<code>database/sql</code>不尝试对查询文本进行任何验证；它与编码的参数一起按照原样发送到服务器，除非驱动程序实现一个特殊的接口，否则在执行之前，查询实在服务器上准备的。</p>
<p><code>bindvars</code>是特定于数据库的：</p>
<ul>
<li>MySQL中使用<code>?</code></li>
<li>PostgreSQL使用枚举的<code>$1</code>、<code>$2</code>等语法</li>
<li>SQLite中使用<code>?</code>和<code>$1</code>的语法都支持</li>
<li>Oracle中使用<code>:name</code>的语法</li>
</ul>
<p><code>bindvars</code>的一个常见错误是，他们用来在sql语句中插入值。其实他们<strong>仅仅用于参数化</strong>，不允许更改SQL语句的结构。例如使用<code>bindvars</code>尝试参数化列或表名将不起作用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ? 不能用来插入表名（叫SQL语句中表名的占位符）</span></span><br><span class="line">db.Query(<span class="string">&quot;SELECT * FROM ?&quot;</span>, <span class="string">&quot;mytable&quot;</span>)</span><br><span class="line"><span class="comment">// ? 不能用来插入列名（叫做SQL语句中列名的占位符）</span></span><br><span class="line">db.Query(<span class="string">&quot;SELECT ?, ? FROM people&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;location&quot;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="自己实现语句实现批量插入">自己实现语句实现批量插入</h4>
<p>比较笨，但是好理解。就是有多少个movie就拼接多少个<code>(?, ?)</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BatchInsertMoive 自行构造批量插入的语句</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BatchInsertMovie</span><span class="params">(movies []*Movie)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// 存放(?, ?)的slice</span></span><br><span class="line">    valueStrings := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>, <span class="built_in">len</span>(movies))</span><br><span class="line">    <span class="comment">// 存放values的slice</span></span><br><span class="line">    valueArgs := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="number">0</span>, <span class="built_in">len</span>(movies) * <span class="number">3</span>)</span><br><span class="line">    <span class="comment">// 遍历users准备相关数据</span></span><br><span class="line">    <span class="keyword">for</span> _, m := <span class="keyword">range</span> moives &#123;</span><br><span class="line">        <span class="comment">// 此处占位符要与插入值的个数对应</span></span><br><span class="line">        valuesStrings = <span class="built_in">append</span>(valuesStrings, <span class="string">&quot;(?, ?, ?)&quot;</span>)</span><br><span class="line">        valueArgs = <span class="built_in">append</span>(valuesArgs, m.ID, m.Actress, m.Title)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 自行拼接要执行的具体语句</span></span><br><span class="line">    stmt := fmt.Sprintf(<span class="string">&quot;INSERT INTO mt_subtitle_table(id, actress, title) VALUES %s&quot;</span>,</span><br><span class="line">strings.Join(valueStrings, <span class="string">&quot;,&quot;</span>))</span><br><span class="line">    _, err := db.Exec(stmt, valueArgs...)</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用sqlx.in实现批量插入">使用sqlx.In实现批量插入</h4>
<p>前提是需要我们的结构体实现<code>driver.Valuer</code>接口</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Movie)</span></span> Value() (driver.Value, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> []<span class="keyword">interface</span>&#123;&#125;&#123;m.ID, m.Actress, m.title&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>sqlx.In</code>实现批量插入代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//BatchInsertMoive 使用的是sqlx.In帮我们拼接语句和参数，注意传入的参数是[]interface&#123;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BatchInsertMoive</span><span class="params">(moive []<span class="keyword">interface</span>&#123;&#125;)</span></span> (<span class="type">error</span>) &#123;</span><br><span class="line">    query, args, _ := sqlx.In(</span><br><span class="line">        <span class="string">&quot;INSERT INTO mt_subtitle_table(id, actress, title) VALUES (?), (?), (?),&quot;</span> <span class="comment">// 这里是根据movie长度来，还是根据字段的个数来，有待观察</span></span><br><span class="line">        movies..., <span class="comment">// 如果参数实现了driver.Valuer, sqlx.In会通过调用Value()来展开它</span></span><br><span class="line">    )</span><br><span class="line">    fmt.Println(query) <span class="comment">// 查看生成的querysting</span></span><br><span class="line">    fmt.Println(args) <span class="comment">// 查看生成的args</span></span><br><span class="line">    _, err := db.Exec(query, args...)</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用namedexec实现批量插入">使用NamedExec实现批量插入</h4>
<p>使用NamedExec实现批量插入的方法如下</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BatchInsert</span><span class="params">(users []*User)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    _, err := db.NameExec(<span class="string">&quot;INSERT INTO mt_subtitle_table(id, actress, title) VALUES(:name, :age)&quot;</span>, users)</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="sqlx.in的查询例子">sqlx.In的查询例子</h3>
<p>关于<code>sqlx.In</code>这里在补充一个用法，在<code>sqlx</code>查询语句中实现了In查询和FIND_IN_SET函数。即实现<code>SELECT * FROM mt_subtitle_table WHERE actress in ("川岛芳子"，"广田雅美")</code>和<code>SELECT * FROM mt_subtitle_table in (3, 2, 1) ORDER BY FIND_IN_SET(id, "川岛芳子"，"广田雅美")</code>.</p>
<h4 id="in查询">in查询</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// QueryByIDs 根据指定ID查询</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">QueryByIDs</span><span class="params">(ids []<span class="type">string</span>)</span></span> (movies []Movie, err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 动态填充id</span></span><br><span class="line">    query, args, err := sqlx.In(<span class="string">&quot;SELECT id, actress, title FROM mt_subtitle_table WHERE actress IN (?)&quot;</span>, ids)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// sqlx.In返回带`?`bindvar`的查询语句，我们使用Rebind()重新绑定他</span></span><br><span class="line">    query = db.Rebind(query)</span><br><span class="line">    err = db.Select(&amp;movies, query, args...)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="in查询和find_in_set函数">in查询和FIND_IN_SET函数</h4>
<p>查询id在给定id集合的数据并维持给定id集合的顺序。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// QuertAndOrderByIDs 按照指定id查询并维护顺序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">QuertAndOrderByIDs</span><span class="params">(ids []<span class="type">string</span>)</span></span>(moives []Movie, err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 动态填充id</span></span><br><span class="line">    strIDs := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>, <span class="built_in">len</span>(ids))</span><br><span class="line">    <span class="keyword">for</span> _, id := <span class="keyword">range</span> ids &#123;</span><br><span class="line">        strIDs = <span class="built_in">append</span>(strIDs, fmt.Sprintf(<span class="string">&quot;%d&quot;</span>, id))</span><br><span class="line">    &#125;</span><br><span class="line">    query, args, err := sqlx.In(<span class="string">&quot;SELECT id, actress FROM user WHERE id IN (?) ORDER BY FIND_IN_SET(id, ?) ORDER BY FIND_IN_SET(id, ?)&quot;</span>, ids, strings.Join(strIDs, <span class="string">&quot;,&quot;</span>))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// sqlx.In 返回带 `?` bindvar的查询语句，我们使用Rebind()重新绑定它</span></span><br><span class="line">    query = db.Rebind(query)</span><br><span class="line">    err = db.Select(&amp;movie, query, args...)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>golang</tag>
        <tag>mysql在、</tag>
      </tags>
  </entry>
  <entry>
    <title>Go操作数据库(一)</title>
    <url>/p/go-with-database-1/</url>
    <content><![CDATA[<p>MySQL是常用的关系数据库，本文主要介绍Go语言怎么操作MySQL数据库。</p>
<p>关键词：<strong>golang</strong></p>
<span id="more"></span>
<h2 id="连接">连接</h2>
<p>sql包提供了保证SQL或类SQL数据库的泛用接口。</p>
<p>使用sql包时必须注入（至少）一个数据库驱动。参见http://golang.org/s/sqldrivers
获取驱动列表。</p>
<p>更多用法示例，参见wiki页面：http://golang.org/s/sqlwiki。</p>
<p>这里使用<code>github.com/go-sql-driver/mysql/</code>作为MySQL的驱动。</p>
<h3 id="下载依赖">下载依赖</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get -u github.com/go-sql-driver/mysql</span><br></pre></td></tr></table></figure>
<h3 id="初始化链接">初始化链接</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(driverName, dataSourceName <span class="type">string</span>)</span></span> (*DB, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>返回的DB类型可用被多个goroutine同时使用</strong>，只需要创建一次，很少需要关闭这个对象；</p></li>
<li><p>Open函数<strong>只验证</strong>参数格式是否正确，不创建数据库的连接，无法验证密码是否正确；</p></li>
<li><p>一般设置成全局变量，<strong>一次初始化然后整个模块使用</strong>。</p></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;database/sql&quot;</span></span><br><span class="line">    _ <span class="string">&quot;https://github.com/go-sql-driver/mysql&quot;</span> <span class="comment">// init mysql驱动</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> db *sql.DB</span><br><span class="line"><span class="comment">// Data Source Name</span></span><br><span class="line"><span class="keyword">const</span> dsn = <span class="string">&quot;root:xxx@tcp(127.0.0.1)/dbname&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">	<span class="comment">// Open不会校验账号密码是否正确</span></span><br><span class="line">    <span class="comment">// 这里不要使用:=, 我们是给全局变量赋值，然后在main函数中示意使用全局变量</span></span><br><span class="line">    db, err = sql.Open(<span class="string">&quot;mysql&quot;</span>, dsn)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> db.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="验证用户名和密码是否正确">验证用户名和密码是否正确</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> Ping() <span class="type">error</span></span><br></pre></td></tr></table></figure>
<ul>
<li>验证数据库是否可用</li>
<li>如果必要的话建立一个连接</li>
</ul>
<h3 id="设置最大连接数">设置最大连接数</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> SetMaxOpenConns(n <span class="type">int</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>设置数据库最大连接数</li>
<li>如果n &gt;
0且小于<strong>最大闲置连接数</strong>，则会将最大闲置连接数减少到匹配开启最大连接数的限制</li>
<li>如果n &lt;= 0（默认值），不会限制最大开启连接数限制</li>
</ul>
<h3 id="设置最大闲置连接数">设置最大闲置连接数</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> SetMaxIdleConns(n <span class="type">int</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>设置数据库最大闲置连接数</li>
<li>如果n
大于<strong>最大连接数</strong>，则新的最大闲置连接数会减少到最大连接数</li>
<li>如果n &lt;= 0，则不会保持闲置连接，<strong>默认值为2</strong></li>
</ul>
<h2 id="增删改查">增删改查</h2>
<h3 id="建库建表">建库建表</h3>
<p>先在MySQL中创建一个名为movies的数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE movies;</span><br></pre></td></tr></table></figure>
<p>进入该数据库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">USE movies;</span><br></pre></td></tr></table></figure>
<p>创建一张用于测试的数据表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `mt_subtitle_table`  (</span><br><span class="line">  `id` text NOT NULL,</span><br><span class="line">  `actress` text NOT NULL,</span><br><span class="line">  `title` text NOT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">)ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;</span><br></pre></td></tr></table></figure>
<p>为了方便查询，我们实现定义一个结构体来存储mt_subtitle_table表的数据。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Movie <span class="keyword">struct</span> &#123;</span><br><span class="line">    id <span class="type">string</span></span><br><span class="line">    actress <span class="type">string</span></span><br><span class="line">    title <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单行查询">单行查询</h3>
<p>单行查询执行一次查询，并<strong>期望返回最多一行结果（即Row）</strong>。QueryRow总是返回非nil的值，直到返回值的Scan方法被调用时，才会返回被延迟的错误，如未找到结果等。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> QueryRow(query <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) *Row</span><br></pre></td></tr></table></figure>
<p>代码实例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查询单条数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">queryRowDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sqlStr := <span class="string">&quot;select id, actress, title from user where id=?&quot;</span></span><br><span class="line">    <span class="keyword">var</span> m Movie</span><br><span class="line">    <span class="comment">// 要确保QueryRow之后调用Scan方法，否则持有的数据库连接不会被释放。</span></span><br><span class="line">    err := db.QueryRow(sqlStr, <span class="string">&quot;APAA-401&quot;</span>).Scan(&amp;m.id, &amp;m.actress, &amp;m.title)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;scan failed, err: %v&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;id: %s, actress: %s, title: %s&quot;</span>, m.id, m.actress, m.title)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多行查询">多行查询</h3>
<p>多行查询<code>db.Query()</code>执行一次查询，返回多行结果（Rows），一般用于执行select命令，<strong>参数args表示query中的占位符参数</strong>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> Query(query <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)(*Rows, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>
<p>代码示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">queryMultRowDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sqlStr := <span class="string">&quot;select id, actress, title for user where actress = ?&quot;</span></span><br><span class="line">    rows, err := db.Query(sqlStr, <span class="string">&quot;樱空桃&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printlf(<span class="string">&quot;query failed, err: %v&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 非常重要：释放持有的数据库连接</span></span><br><span class="line">    <span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">        <span class="keyword">var</span> m Moive</span><br><span class="line">        err := rows.Scan(&amp;m.id, &amp;m.actress, &amp;m.title)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;scan failed, err: %v&quot;</span>, err)</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;id: %s, actress: %s, title: %s&quot;</span>, m.id, m.name, m.age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="插入数据">插入数据</h3>
<p>插入、更新和删除都使用<code>Exec</code>方法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> Exec(query <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) (Result, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>
<p>Exec执行一次命令（包括查询、删除、更新、插入等），返回的Result是对已执行的SQL命令的总结，参数args表示query中的占位参数。</p>
<p>插入数据代码示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 插入数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertRowDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sqlStr := <span class="string">&quot;insert into mt_subtitle_table(id, actress, title) values(?, ?, ?)&quot;</span></span><br><span class="line">    ret, err := db.Exec(sqlStr, <span class="string">&quot;APAA-401&quot;</span>, <span class="string">&quot;樱空桃&quot;</span>, <span class="string">&quot;先輩方の気遣いが嬉しい&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;insert failed, err :%v&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    theID, err := ret.LastInsertId() <span class="comment">// 返回插入新数据的ID</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;get lastinsert ID failed, err: %v&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;insert success, affected id: %v&quot;</span>, theID)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="更新数据">更新数据</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 更新数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">updateRowDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sqlStr := <span class="string">&quot;update mt_subtitle_table set title=? where id=?&quot;</span></span><br><span class="line">    ret, err := db.Exec(sqlStr, <span class="string">&quot;先輩方の気遣いが嬉しい&quot;</span>, <span class="string">&quot;APAA-401&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;update failed, err: %v\n&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    n, err := ret.RowsAffected() <span class="comment">// 返回操作影响的行数</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;get RowsAffected failed, err:%v\n&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;update success, affected rows: %d\n&quot;</span>, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除数据">删除数据</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteRowDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sqlStr := <span class="string">&quot;delete from mt_subtitle_table where id = ?&quot;</span></span><br><span class="line">    ret, err := db.Exec(sqlStr, <span class="string">&quot;APAA-401&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;delete failed, err: %v&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    &#125;</span><br><span class="line">    n, err := ret.RowAffected() <span class="comment">// 操作影响的行数</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;get RowsAffected failed, err: %v&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;delete success, affected rows: %d&quot;</span>, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="mysql预处理">MySQL预处理</h2>
<h3 id="什么是预处理">什么是预处理</h3>
<p>普通SQL语句执行过程：</p>
<ol type="1">
<li>客户端对SQL语句进行占位符替换得到完整的SQL语句；</li>
<li>客户端发送完整的SQL语句到MySQL服务端；</li>
<li>MySQL服务端执行完整的SQL语句并将结果返回给客户端。</li>
</ol>
<p>预处理执行过程：</p>
<ol type="1">
<li>把SQL语句分成两部分，命令部分与数据部分。</li>
<li>先把命令部分发送到MySQL服务端，MySQL服务端进行SQL预处理。</li>
<li>然后把数据部分发送到MySQL服务端，MySQL服务端使用占位符进行替换。</li>
<li>MySQL服务端执行完整的SQL语句并将结果返回给客户端。</li>
</ol>
<h3 id="为何要预处理">为何要预处理</h3>
<ol type="1">
<li>优化MySQL服务器重复执行SQL的方法，可以提升服务器性能，提前让服务器编译，一次编译多次执行，节省后续编译的成本。</li>
<li>避免SQL注入问题。</li>
</ol>
<h2 id="go实现mysql预处理">Go实现MySQL预处理</h2>
<p><code>database/sql</code>使用下面的<code>Prepare</code>方法来实现预处理操作。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> Prepare(query <span class="type">string</span>)(*Stmt, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>
<p><code>Prepare</code>方法会先将sql语句发送给MySQL服务端，返回一个准备好的状态用于之后的查询和命令。返回值可以同时执行多个查询和命令。</p>
<p>查询操作的预处理实例代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 预处理查询实例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">prepareQueryDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sqlStr := <span class="string">&quot;select id, actress, title from mt_subtitle_table where actress = ?&quot;</span></span><br><span class="line">    stmt, err := db.Prepare(sqlStr)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;prepare failed, err: %v&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> stmt.Close()</span><br><span class="line">    rows, err := stmt.Query(<span class="string">&quot;白桃花&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;query failed, err: %v\n&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> rows.Close()</span><br><span class="line">    <span class="comment">// 循环读取结果中的数据</span></span><br><span class="line">    <span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">        <span class="keyword">var</span> m Movie</span><br><span class="line">        err := rows.Scan(&amp;m.id, &amp;m.actress, &amp;m.title)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;scan failed, err: %v&quot;</span>, err)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;id: %v, actress: %v, title: %v&quot;</span>, m.id, m.actress, m.title)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>插入、更新和删除的预处理操作十分类似，这里以插入数据的预处理为例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 预处理插入实例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">prepareInsertDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sqlStr := <span class="string">&quot;insert into mt_subtitle_table(id, actress, title) values(?,?)&quot;</span></span><br><span class="line">    stmt, err := db.Prepare(sqlStr)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;prepare failed, err:%v&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> stmt.Close()</span><br><span class="line">    _, err = stmt.Exec(<span class="string">&quot;APAA-401&quot;</span>, <span class="string">&quot;白桃花&quot;</span>, <span class="string">&quot;先輩方の気遣いが嬉しい&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;insert failed, err:%v&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    _, err = stmt.Exec(<span class="string">&quot;APAA-402&quot;</span>, <span class="string">&quot;樱空桃&quot;</span>, <span class="string">&quot;先輩方の気遣いが嬉しい&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;insert failed, err:%v&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;insert success.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="sql注入问题">SQL注入问题</h2>
<p>任何时候都不应该自己拼接SQL语句！</p>
<p>这里我们编写一个根据name字段查询user表的函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sql注入实例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sqlInjectDemo</span><span class="params">(name <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    sqlStr := fmt.Sprinf(<span class="string">&quot;select id, actress, title from mt_subtitle_table where actress = &#x27;%s&#x27;&quot;</span>, name)</span><br><span class="line">    <span class="keyword">var</span> m Movie</span><br><span class="line">    err := db.QueryRow(sqlStr).Scan(&amp;m.id, &amp;m.name, &amp;m.title)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;exec failed, err: %v\n&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;movie: #%v\n&quot;</span>, m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时输入以下字符串都可以引发SQL注入问题：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">sqlInjectDemo(<span class="string">&quot;xxx&#x27; or 1=1#&quot;</span>)</span><br><span class="line">sqlInjectDemo(<span class="string">&quot;xxx&#x27; union select * from user #&quot;</span>)</span><br><span class="line">sqlInjectDemo(<span class="string">&quot;xxx&#x27; and (select count(*) from user) &gt; 10&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>补充：不同的数据库中，SQL语句中使用的占位符语法不尽相同。</p>
<table>
<thead>
<tr class="header">
<th>数据库</th>
<th>占位符</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>MySQL</td>
<td><code>?</code></td>
</tr>
<tr class="even">
<td>PostgreSQL</td>
<td><code>$1</code>,<code>$2</code>等</td>
</tr>
<tr class="odd">
<td>SQlite</td>
<td><code>?</code>和<code>$1</code></td>
</tr>
<tr class="even">
<td>Oracle</td>
<td><code>:name</code></td>
</tr>
</tbody>
</table>
<h2 id="go实现mysql事务">Go实现MySQL事务</h2>
<h3 id="什么是事务">什么是事务</h3>
<p>事务：一个最小的不可再分的工作单元；</p>
<p>通常一个事务对应一个完整的业务（如银行转账业务，该业务就是一个最小的工作单元）同时这个完整的操作需要执行多次的DML（插入、更新、删除）语句共同联合完成，A转账给B，这里就需要两次update操作。</p>
<p>在MySQL中只有使用了Innodb数据库引擎的数据库才支持表或事物。事务处理可以用来维护数据的完整性，保证成批的SQL语句要么全部执行，要么全部不执行。</p>
<h3 id="事务的acid">事务的ACID</h3>
<p>通常事务必须满足四个条件（ACID）：原子性（Atomicity，或称不可分割性）、一致性（Consistency）、隔离性（Isolation又称独立性）、持久性（Durability）。</p>
<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 90%" />
</colgroup>
<thead>
<tr class="header">
<th>条件</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>原子性</td>
<td>一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发送错误，会被回滚（Rollback）到事务前开始的状态，就像这个事务从来没有执行过一样。</td>
</tr>
<tr class="even">
<td>一致性</td>
<td>在事务开始之前和事务结束以后，数据库的完整性没有被破坏，这表示写入的资料必须完全符合所有的预设规则，这包含资料的准确度、串联性以及后续数据库可以自发性的完成预定的工作。</td>
</tr>
<tr class="odd">
<td>隔离性</td>
<td>数据库允许多个并发事务同时对其数据进行读写和修改的能力。隔离性可以防止多个事务并发执行时由于交叉执行而导致的数据行不一致的情况。事务隔离分为不同级别，包括读未提交（Read
uncommitted）、读提交（Read committed)、可重复读（Repeatable
read）和串行化（Serializable）。</td>
</tr>
<tr class="even">
<td>持久性</td>
<td>事务处理结束以后，对数据的修改就是永久的，即便系统故障也不会丢失。</td>
</tr>
</tbody>
</table>
<h3 id="事务相关方法">事务相关方法</h3>
<p>Go语言使用以下三个方法实现MySQL中的事务操作。</p>
<p>开始事务</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> Begin() (*Tx, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>
<p>提交事务</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span></span> Commit() <span class="type">error</span></span><br></pre></td></tr></table></figure>
<p>回滚事务</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span></span> Rollback() <span class="type">error</span></span><br></pre></td></tr></table></figure>
<h3 id="事务实例">事务实例</h3>
<p>下面的代码演示了一个简单的事务操作，该事务操作能够保证两次更新操作要么同时成功要么同时失败，不会出现中间状态。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 事务操作实例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">transationDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    tx, err := db.Begin() <span class="comment">// 开启事务</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> tx != <span class="literal">nil</span> &#123;</span><br><span class="line">        	tx.Rollback() <span class="comment">// 回滚</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;begin trans fail, err: %v&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    sqlStr1 := <span class="string">&quot;UPDATE mt_subtitle_table set id = AAA501 where actress=?&quot;</span></span><br><span class="line">    ret1, err := tx.Exec(sqlStr1, <span class="string">&quot;若狭留美&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        tx.Rollback() <span class="comment">// 回滚</span></span><br><span class="line">        fmt.Prinf(<span class="string">&quot;exec sql1 failed, err: %v&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    affRow1, err := ret1.RowAffected()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        tx.Rollback() <span class="comment">// 回滚</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;exec ret1.RowAffected() failed, err:%v&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    sqlStr2 := <span class="string">&quot;UPDATE mt_subtitle_table set id = AAA4501 where actress = ?&quot;</span></span><br><span class="line">    ret2, err := tx.Exec(sqlStr2, <span class="string">&quot;泷泽萝拉&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err := <span class="literal">nil</span> &#123;</span><br><span class="line">        tx.Rollback() <span class="comment">// 回滚</span></span><br><span class="line">        fmt.Println(<span class="string">&quot;exec sql2 failed, err: %v&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    affRow2, err := ret2.RowsAffected()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        tx.Rollback() <span class="comment">// 回滚</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;exec ret2.RosAffected() failed, err:%v&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(affRow1, affRow2)</span><br><span class="line">    <span class="keyword">if</span> affRow1 == <span class="number">1</span> &amp;&amp; affRow2 == <span class="number">1</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;很好，事务提交了&quot;</span>)</span><br><span class="line">        tx.Commit() <span class="comment">// 提交事务</span></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        tx.Rollback()</span><br><span class="line">        fmt.Println(<span class="string">&quot;不好意思，有点问题，事务回滚了&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;事务执行成功！&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>mysql</tag>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言基础（五）httprouter详解</title>
    <url>/p/httprouter-tutorial-01/</url>
    <content><![CDATA[<p>httprouter
是一个高性能、可扩展的HTTP路由，可以作为golang默认路由<code>net/http</code>的替代。</p>
<p>关键词：<strong>httprouter </strong></p>
<span id="more"></span>
<h2 id="安装">安装</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get -u  <span class="string">&quot;github.com/julienschmidt/httprouter&quot;</span></span><br></pre></td></tr></table></figure>
<p>一个例子作为开始</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;github.com/julienschmidt/httprouter&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HelloWorld</span><span class="params">(w http.ResponseWriter, r *http.Request, _ httprouter.Params)</span></span> &#123;</span><br><span class="line">	w.Write([]<span class="type">byte</span>(<span class="string">&quot;HelloWorld&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	router := httprouter.New()</span><br><span class="line">	router.GET(<span class="string">&quot;/hi&quot;</span>, HelloWorld)</span><br><span class="line">	log.Fatal(http.ListenAndServe(<span class="string">&quot;:80&quot;</span>, router))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码中，HelloWorld是一个<code>handle httprouter.Handle</code>类型，需要传入三个参数，三个参数的作用以后说。该<code>handle</code>在main函数忠被注册到<code>/hi</code>路径上。运行代码会得到一下效果。</p>
<p><img data-src="image-20220416101901309.png" /></p>
<h2 id="http-method">HTTP Method</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Router)</span></span> GET(path <span class="type">string</span>, handle Handle) &#123;</span><br><span class="line">    r.Handle(<span class="string">&quot;GET&quot;</span>, path, handle)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Router)</span></span> HEAD(path <span class="type">string</span>, handle Handle) &#123;</span><br><span class="line">    r.Handle(<span class="string">&quot;HEAD&quot;</span>, path, handle)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Router)</span></span> OPTIONS(path <span class="type">string</span>, handle Handle) &#123;</span><br><span class="line">    r.Handle(<span class="string">&quot;OPTIONS&quot;</span>, path, handle)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Router)</span></span> POST(path <span class="type">string</span>, handle Handle) &#123;</span><br><span class="line">    r.Handle(<span class="string">&quot;POST&quot;</span>, path, handle)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Router)</span></span> PUT(path <span class="type">string</span>, handle Handle) &#123;</span><br><span class="line">    r.Handle(<span class="string">&quot;PUT&quot;</span>, path, handle)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Router)</span></span> PATCH(path <span class="type">string</span>, handle Handle) &#123;</span><br><span class="line">    r.Handle(<span class="string">&quot;PATCH&quot;</span>, path, handle)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Router)</span></span> DELETE(path <span class="type">string</span>, handle Handle) &#123;</span><br><span class="line">    r.Handle(<span class="string">&quot;DELETE&quot;</span>, path, handle)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="路由匹配">路由匹配</h2>
<h3 id="nethttp的路由匹配">net/http的路由匹配</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//	/api,可以访问到</span></span><br><span class="line"><span class="comment">//	/api/,不可以</span></span><br><span class="line">http.HandleFunc(<span class="string">&quot;/api&quot;</span>,<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter,r *http.Request)</span></span>&#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;/api&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//	/api,可以</span></span><br><span class="line"><span class="comment">//	/api/,也可以</span></span><br><span class="line">http.HandleFunc(<span class="string">&quot;/api/&quot;</span>,<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter,r *http.Request)</span></span>&#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;/api&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="httprouter的路由匹配">httprouter的路由匹配</h3>
<p>两者路由命名捕获方式：（是路由命名不是路由参数）</p>
<ul>
<li><p><code>:name</code>的捕获方式是匹配内容直到下一个斜线或者路径的结尾</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Path: /blog/:category/:post  </span><br><span class="line">router.GET(<span class="string">&quot;/blog/:category/:post&quot;</span>, Hello) //category/post可以看成是一个变量</span><br><span class="line">	</span><br><span class="line">当请求路径为：</span><br><span class="line">/blog/go/request-routers            match: category=<span class="string">&quot;go&quot;</span>, post=<span class="string">&quot;request-routers&quot;</span></span><br><span class="line">/blog/go/request-routers/           no match, but the router would redirect</span><br><span class="line">/blog/go/                           no match</span><br><span class="line">/blog/go/request-routers/comments   no match</span><br></pre></td></tr></table></figure></li>
<li><p><code>*name</code>的方式是从指定位置开始（包含前缀"/"）匹配到结尾</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Path: /files/*filepath</span><br><span class="line">router.GET(<span class="string">&quot;/files/*filepath&quot;</span>, Hello) //filepath可以看成是一个变量</span><br><span class="line"></span><br><span class="line">当请求路径为：</span><br><span class="line">/files/                             match: filepath=<span class="string">&quot;/&quot;</span></span><br><span class="line">/files/LICENSE                      match: filepath=<span class="string">&quot;/LICENSE&quot;</span></span><br><span class="line">/files/templates/article.html       match: filepath=<span class="string">&quot;/templates/article.html&quot;</span></span><br><span class="line">/files                              no match, but the router would redirect</span><br></pre></td></tr></table></figure></li>
</ul>
<p>获取路由命名的参数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HelloWorld</span><span class="params">(w http.ResponseWriter, r *http.Request, ps httprouter.Params)</span></span> &#123;</span><br><span class="line">    name := ps.ByName(<span class="string">&quot;who&quot;</span>) <span class="comment">//获取who对应的参数</span></span><br><span class="line">    name := ps[<span class="number">0</span>].Value      <span class="comment">//直接通过Value检索</span></span><br><span class="line">	w.Write([]<span class="type">byte</span>(<span class="string">&quot;HelloWorld&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line">router.GET(<span class="string">&quot;/hi/:who&quot;</span>, HelloWorld)</span><br></pre></td></tr></table></figure>
<h3 id="httprouter重定向">httprouter重定向</h3>
<p>如果请求的URL路径包含或者不包含尾随斜线时，但在注册的路径上包含了或没有包含"/"的目标上定义了handler，但是会进行301重定向。简单地说，<strong>不管URL是否带尾随斜线，只要注册路径不存在，但在去掉尾随斜线或加上尾随斜线的路径上定义了handler，就会自动重定向。</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span></span> *Router &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Router&#123;</span><br><span class="line">		<span class="comment">//是否启用自动重定向</span></span><br><span class="line">        RedirectTrailingSlash:  <span class="literal">true</span>,</span><br><span class="line">        <span class="comment">// 设置为true时回尝试修复路径, 第一个多余的路径会被删除. 之后, 路由器对已清理的路径进行不区分大小写的查找. 如果可以找到此路由的句柄，则路由器将重定向到正确的路径</span></span><br><span class="line">        RedirectFixedPath:      <span class="literal">true</span>,</span><br><span class="line">        HandleMethodNotAllowed: <span class="literal">true</span>,</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果启用，则路由器会自动回复OPTIONS请求</span></span><br><span class="line">        HandleOPTIONS:          <span class="literal">true</span>,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面有几种会重定向的情况</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">注册路径：/blog/:category/:post</span><br><span class="line">请求URL路径：/blog/go/request-routers/</span><br><span class="line"></span><br><span class="line">注册路径：/blog/:category</span><br><span class="line">请求URL路径：/blog/go</span><br><span class="line"></span><br><span class="line">注册路径：/files/*filepath</span><br><span class="line">请求URL路径：/files</span><br></pre></td></tr></table></figure>
<h3 id="httprouter-lookup">httprouter lookup</h3>
<p>Lookup根据<code>method+path</code>检索对应的Handle，以及<code>Params</code>，并可以通过第三个返回值判断是否会进行重定向。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Router)</span></span> Lookup(method, path <span class="type">string</span>) (Handle, Params, <span class="type">bool</span>)</span><br></pre></td></tr></table></figure>
<h3 id="httprouter获取请求相关的信息">httprouter获取请求相关的信息</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HelloWorld</span><span class="params">(w http.ResponseWriter, r *http.Request, ps httprouter.Params)</span></span> &#123;</span><br><span class="line">	err := r.ParseForm() <span class="comment">// 解析表单必须</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		w.WriteHeader(http.StatusBadGateway)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Who: %v\n&quot;</span>, ps.ByName(<span class="string">&quot;who&quot;</span>))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Method: %v\n&quot;</span>, r.Method)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Host: %v\n&quot;</span>, r.Host)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;UserAgent: %v\n&quot;</span>, r.UserAgent())</span><br><span class="line">	fmt.Printf(<span class="string">&quot;r.PostForm: %v\n&quot;</span>, r.PostForm)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;r.Form: %v\n&quot;</span>, r.Form)</span><br><span class="line">	fmt.Println(<span class="string">&quot;========OK=======&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其中PostForm获取<code>x-www-form-urlencoded</code>发送的表单，Form获取明文发送如http://127.0.0.1/hi/xxx?user=xxx如user=xxx的信息。</p>
<h3 id="http返回信息">http返回信息</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HelloWorld</span><span class="params">(w http.ResponseWriter, r *http.Request, ps httprouter.Params)</span></span> &#123;</span><br><span class="line">    w.WriteHeader(http.statusOK)</span><br><span class="line">    status, err := w.Write([]<span class="type">byte</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">if</span> err := <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    &#125;</span><br><span class="line">    w.Header() </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>第一行返回http请求状态码</p>
<p>第二行返回Body，通常是返回一个json</p>
<p>第三行是返回Header，格式是map</p>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>http请求参数之Query String Parameters、Form Data、Request Payload区别</title>
    <url>/p/the-difference-between-query-string-parameters-and-form-data-and-request-payload/</url>
    <content><![CDATA[<p><strong>在与server端进行数据传递时，通常会用到GET、POST方法进行参数提交，而参数提交的方式，通常取决于server端对数据的接收方式。</strong></p>
<p>关键词：<strong>http</strong></p>
<span id="more"></span>
<h2 id="query-string-parameters">Query String Parameters</h2>
<p>Query String Parameters 当发起一次HTTP请求时，参数会以url
string的形式进行传递。</p>
<p>即<code>?</code>后面的字符串则为请求的参数，并以<code>&amp;</code>为分隔符。</p>
<h4 id="header">header</h4>
<p><img data-src="1620.png" /></p>
<h4 id="传入参数">传入参数</h4>
<p><img data-src="1620-1672985410153-3.png" /></p>
<h2 id="request-payload">Request Payload</h2>
<p>当发起一次POST请求后，若<code>content-type</code>为<code>application/json</code>，则参数会以Request
Payload的形式进行传递，数据形式为JSON。</p>
<p>上述请求不会显式的出现在URL中。</p>
<h4 id="header-1">header</h4>
<p><img data-src="1620-1672985432471-6.png" /></p>
<h4 id="传入参数-1">传入参数</h4>
<figure>
<img data-src="1620-1672985616176-9.png" alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h2 id="form-data">Form Data</h2>
<p>当发起一次HTTP请求时，若未指定content-type，则默认<code>content-type</code>为<code>application/x-www-form-urlencoded</code>。</p>
<p>参数会以<code>From Data</code>的形式进行传递，不会显式出现在请求url中。</p>
<h4 id="传入参数-2">传入参数</h4>
<p><img data-src="1620-1672985628992-12.png" /></p>
]]></content>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS实战（十一）ROS2之节点</title>
    <url>/p/agent-in-ros2/</url>
    <content><![CDATA[<p>本文主要介绍ROS2上的节点。</p>
<p><strong>关键词：ROS2</strong></p>
<span id="more"></span>
<h2 id="节点">节点</h2>
<p>机器人是各种功能的综合体，每一项功能就像机器人的一个工作细胞。众多细胞通过一些机制联系到一起，就成为了一个机器人整体。</p>
<p>在ROS中，这些细胞被称为节点。</p>
<h3 id="通信模型">通信模型</h3>
<p>完成的机器人系统可能并不是一个物理上的整体，比如这样的一个机器人：</p>
<p><img data-src="image-20220526231417594.png" /></p>
<p>在机器人身体里搭载了一台计算机A，通过机器人的眼睛——摄像头，获取外界的信息，也可以通过控制机器人的腿——轮子，让机器人一栋栋到想要去的地方。除此之外，还有另外一台计算机B，放在你的桌子上，可以远程监控机器人看到的消息，也可以远程配置机器人的速度和某些参数，还可以连接成为一个摇杆，人为控制机器人左右运动。</p>
<p>这些功能虽然位于不同的计算机中，但是都是机器人的工作细胞，也就是节点，他们共同组成了一个完整的机器人系统。</p>
<ul>
<li>节点在机器人系统中的职责就是<strong>执行某些具体的任务</strong>，从操作系统来看，也叫做进程；</li>
<li>每个节点都是一个<strong>独立运行的可执行文件，</strong>比如执行某一个python程序，或者执行C++编译生成的结果，都是算运行了一个节点；</li>
<li>既然每一个节点都是独立的执行文件，那自然就可以想到，得到这个执行文件的编程语言可以是不同的，比如C++、Python等；</li>
<li>这些节点是功能各不相同的细胞，根据系统设计的不同，可能位于计算机A，也可能位于计算机B</li>
</ul>
]]></content>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS实战（十一）ROS2之功能包</title>
    <url>/p/package-in-ros2/</url>
    <content><![CDATA[<p>本文主要介绍ROS2上的功能包。</p>
<p><strong>关键词：ROS2</strong></p>
<span id="more"></span>
<p>功能包的机制，是提高ROS中软件复用率的重要方法。</p>
<h2 id="创建功能包">创建功能包</h2>
<p>如何在ROS2中创建一个功能包，可以使用以下这个指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 pkg create --build-type &lt;build-type&gt; &lt;package_name&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>pkg：表示功能包相关的功能；</li>
<li>create：表示创建功能包；</li>
<li>build-type：表示新创建的功能包是C++还是Python的，如果是C++或者C，那这里就用ament_cmake，如果使用Python，就用ament_python；</li>
<li>package_name：新建功能包的名字。</li>
</ul>
<p>比如在终端中分别创建C++和Python版本的功能包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/dev_ws/src</span><br><span class="line">ros2 pkg create --build-type ament_cmake learning_pkg_c            <span class="comment"># C++</span></span><br><span class="line">ros2 pkg create --build-type ament_python learning_pkg_python      <span class="comment"># Python</span></span><br></pre></td></tr></table></figure>
<h2 id="编译功能包">编译功能包</h2>
<p>在创建好的功能包中，可以继续完成代码的编写，之后需要编译和配置环境变量，才能正常运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/dev_ws/src</span><br><span class="line">colcon build      <span class="comment"># 编译工作空间所有功能包</span></span><br><span class="line"><span class="built_in">source</span> install/local_setup.bash</span><br></pre></td></tr></table></figure>
<h2 id="功能包的结构">功能包的结构</h2>
<p>分析以下刚刚创建的两个功能包的结构。</p>
<h3 id="c功能包">C++功能包</h3>
<p>首先看下C++的功能包，其中必然存在两个文件：<strong>package.xml和CMakerLists.txt</strong></p>
<p><img data-src="image-20220524112122164.png" /></p>
<p>package.xml文件的主要内容如下，包含功能包的版权描述，和各种依赖的声明。</p>
<p><img data-src="image-20220524112141298.png" /></p>
<p>CMakeLists.txt文件是编译规则，C++代码需要编译才能运行，必须要在该文件中设置如何编译，使用CMake语法。</p>
<p><img data-src="image-20220524112132626.png" /></p>
<p>Python功能包</p>
<p>C++功能包需要将源码解释成可执行文件，但是Python语言是解析型的，不需要编译。</p>
<p>也是有两个文件：package.xml和setup.py。</p>
<p><img data-src="image-20220524112228806.png" /></p>
<p>package.xml文件的主要内容和C++版本的功能包一样，包含功能包的版权描述，和各自依赖的声明。</p>
<p><img data-src="image-20220524112246102.png" /></p>
<p>setup.py文件里面也包含一些版权信息，初次之外，还有"entry_points"配置的程序入口。</p>
<p><img data-src="image-20220524112235574.png" /></p>
]]></content>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS实战（十）ROS2之工作空间</title>
    <url>/p/workspace-in-ros2/</url>
    <content><![CDATA[<p><strong>摘要：转眼间三年已经过去，而我也开始面临毕业的问题。由于导师放养式的教学，导致我的论文一直没什么长进。抱怨没有用，一切靠自己。还是得把之前丢下的捡起来。</strong></p>
<p>本文主要介绍ROS2上的工作空间。</p>
<p><strong>关键词：ROS2</strong></p>
<span id="more"></span>
<h2 id="工作空间开发过程中的大本营">工作空间：开发过程中的大本营</h2>
<h3 id="什么是工作空间">什么是工作空间</h3>
<p>在ROS机器人开发中，我们针对机器人的某些功能需要进行代码便携式，各种编写的代码、参数、脚本等文件，也需要放置在某一个文件夹里进行管理，这个文件夹在ROS系统中就叫做工作空间。</p>
<p>工作空间是一个存放项目于开发相关文件的文件夹，是开发过程中存放所有资料的大本营。</p>
<p>ROS系统中一个典型的工作空间如下，一般会有四个子目录：</p>
<figure>
<img data-src="https://book.guyuehome.com/ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/image/2.1_%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4/image-20220524111415729.png"
alt="image-20220524111415729" />
<figcaption aria-hidden="true">image-20220524111415729</figcaption>
</figure>
<ul>
<li><p><strong>src，代码空间</strong>：编写的代码、脚本都需要放在这里；</p></li>
<li><p><strong>build，编译空间</strong>：保存编译过程中产生的中间文件；</p></li>
<li><p><strong>install，安装空间</strong>：放置编译过程得到的可执行文件和脚本；</p></li>
<li><p><strong>log，日志空间</strong>：编译和运行过程中，保存各种警告、错误、信息等日志。</p></li>
</ul>
<p>总体来说，这四个空间的文件夹，我们绝大部分的操作都是在src进行的，编译成功后，会执行install里面的结果，build和log两个文件很少用。</p>
<p>工作空间里的名称我们也可以自己定义，数量也不是唯一的.</p>
<h3 id="创建工作空间">创建工作空间</h3>
<p>执行以下命令创建工作空间</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p ~/dev_ws/src</span><br><span class="line"><span class="built_in">cd</span> ~/dev_ws/src</span><br><span class="line">git <span class="built_in">clone</span> https://gitee.com/guyuehome/ros2_21_tutorials.git</span><br></pre></td></tr></table></figure>
<h3 id="自动安装依赖">自动安装依赖</h3>
<p>一般使用<code>rosdep</code>工具进行自动安装，而<code>rosdep</code>默认会使用国外的源进行安装，而一般国内的网络无法正常连接，因此有开发者开发了<code>rosdepc</code>模块，<code>c</code>的含义就是china，这个软件使用了清华源进行了替换。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pip install rosdepc</span><br><span class="line">sudo rosdepc init </span><br><span class="line">rosdepc update</span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line">rosdepc install -i --from-path src --rosdistro foxy -y</span><br></pre></td></tr></table></figure>
<p><img data-src="2022-12-17-16-30-20-image.png" /></p>
<h3 id="编译工作空间">编译工作空间</h3>
<p>依赖安装完毕，可以使用以下命令编译工作空间，如果有缺少的依赖，或者代码有错误，编译过程中会有报错，否则编译过程中不会出现任何错误：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install python3-colcon-ros</span><br><span class="line"><span class="built_in">cd</span> ~/dev_ws/</span><br><span class="line">colcon build</span><br></pre></td></tr></table></figure>
<p><img data-src="2022-12-17-16-37-46-image.png" /></p>
<p>编译成功后，就可以在工作空间后就可以看到构建后的文件夹了</p>
<p><img data-src="2022-12-17-16-40-47-image.png" /></p>
<h3 id="设置环境变量">设置环境变量</h3>
<p>编译成功后，为了让系统找到我们的功能包和可执行文件，还需要设置环境变量：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> install/local_setup.sh <span class="comment"># 仅在当前终端生效</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;source ~/dev_ws/install/local_setup.sh&quot;</span> &gt;&gt; ~/.bashrc <span class="comment"># 全局生效</span></span><br></pre></td></tr></table></figure>
<p>至此，我们就完成了工作空间的创建、编译、和配置。</p>
]]></content>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS实战（九）安装ROS2</title>
    <url>/p/install-ros2-with-linux/</url>
    <content><![CDATA[<p><strong>摘要：转眼间三年已经过去，而我也开始面临毕业的问题。由于导师放养式的教学，导致我的论文一直没什么长进。抱怨没有用，一切靠自己。还是得把之前丢下的捡起来。</strong></p>
<p>本文主要介绍如何在Linux平台上安装ROS2。</p>
<p><strong>关键词：ROS2</strong> <span id="more"></span></p>
<h2 id="ros2安装">ROS2安装</h2>
<p>ROS2的安装受ubuntu发行版的限制，比如ubuntu 20.04
LTS只能安装foxy这个发行版；</p>
<p>ubuntu 22.04 LTS只能按照ROS2长期支持版humble这个发行版。</p>
<p>本文以ubuntu 20.04 LTS安装foxy发行版为例。</p>
<h3 id="设置编码">设置编码</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt update &amp;&amp; sudo apt install locales</span><br><span class="line">sudo locale-gen en_US en_US.UTF-8</span><br><span class="line">sudo update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8 </span><br><span class="line"><span class="built_in">export</span> LANG=en_US.UTF-8</span><br></pre></td></tr></table></figure>
<h3 id="安装必要软件">安装必要软件</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt update &amp;&amp; sudo apt install curl gnupg lsb-release software-properties-common</span><br><span class="line">sudo add-apt-repository universe</span><br></pre></td></tr></table></figure>
<h3 id="设置源">设置源</h3>
<p>此处注意，需要确认你的网络可以连接<code>raw.githubusercontent.com</code>，这里先下载完key然后上传到服务器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -sSL https://raw.githubusercontent.com/ros/rosdistro/master/ros.key</span><br><span class="line">sudo <span class="built_in">mv</span> ros.key /usr/share/keyrings/ros-archive-keyring.gpg </span><br></pre></td></tr></table></figure>
<p>这里使用清华源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb [arch=<span class="subst">$(dpkg --print-architecture)</span> signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] https://mirrors.tuna.tsinghua.edu.cn/ros2/ubuntu jammy main&quot;</span> | sudo <span class="built_in">tee</span> /etc/apt/sources.list.d/ros2.list &gt; /dev/null</span><br><span class="line"></span><br><span class="line">sudo apt update</span><br></pre></td></tr></table></figure>
<h3 id="安装ros2">安装ROS2</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt upgrade</span><br><span class="line">sudo apt install ros-foxy-desktop python3-argcomplete -y</span><br></pre></td></tr></table></figure>
<p>注意，如果是嵌入式设备，使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install ros-foxy-ros-base python3-argcomplete -y </span><br></pre></td></tr></table></figure>
<p>如果需要安装编译的环境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install ros-dev-tools -y</span><br></pre></td></tr></table></figure>
<h3 id="设置环境变量">设置环境变量</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> /opt/ros/foxy/setup.bash</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot; source /opt/ros/foxy/setup.bash&quot;</span> &gt;&gt; ~/.bashrc </span><br></pre></td></tr></table></figure>
<h2 id="ros2测试">ROS2测试</h2>
<h3 id="命令行">命令行</h3>
<p>启动一个终端，允许一个数据的发布者节点：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 run demo_nodes_cpp talker</span><br></pre></td></tr></table></figure>
<p><img data-src="2022-12-16-20-48-59-image.png" /></p>
<p>启动第二个终端，通过以下命令启动一个数据的订阅者节点：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 run demo_nodes_py listener</span><br></pre></td></tr></table></figure>
<p><img data-src="2022-12-16-20-49-55-image.png" /></p>
<h3 id="gui">GUI</h3>
<p>运行一个ROS的经典实例——小海龟仿真器</p>
<p>启动两个终端，分别执行如下指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 run turtlesim turtlesim_node</span><br><span class="line">ros2 run turtlesim turtle_teleop_key</span><br></pre></td></tr></table></figure>
<p>第一句指令将启动一个蓝色背景的海龟仿真器，第二局指令将启动一个键盘控制节点，在该终端中点击键盘上的上下左右按键，就可以控制小海龟移动了。</p>
<h2 id="常见的命令行操作">常见的命令行操作</h2>
<p>ROS2的命令行的操作机制与Linux相同，不过所有的操作都集中在ros2的总命令中，后面第一个参数表示不同的操作目的，比如node表示对节点的操作，topic表示对话题的操作，后面还可以继续跟参数表示具体操作。</p>
<p><img data-src="2022-12-17-12-27-08-image.png" /></p>
<p>接下来以小乌龟仿真为例，感受下ROS2命令行的主要功能，也对ROS2中的核心概念有一个大体了解。</p>
<h3 id="运行节点程序">运行节点程序</h3>
<p>想要运行ROS2中的某个节点，可以使用ros2 run命令进行操作。</p>
<p>例如我们要运行海龟仿真节点：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 run turtlesim turtlesim_node</span><br></pre></td></tr></table></figure>
<p><img data-src="2022-12-17-12-36-55-image.png" /></p>
<p>我们要运行键盘控制节点：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 run turtlesim turtle_teleop_key</span><br></pre></td></tr></table></figure>
<p><img data-src="2022-12-17-12-41-35-image.png" /></p>
<h3 id="查看节点信息">查看节点信息</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 node list</span><br></pre></td></tr></table></figure>
<p><img data-src="2022-12-17-12-46-11-image.png" /></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 node info /turtlesim</span><br></pre></td></tr></table></figure>
<p><img data-src="2022-12-17-12-47-32-image.png" /></p>
<h3 id="查看话题信息">查看话题信息</h3>
<p>使用以下命令即可查看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 topic list</span><br></pre></td></tr></table></figure>
<p><img data-src="2022-12-17-12-48-52-image.png" /></p>
<p>查看指定话题的消息数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 topic <span class="built_in">echo</span> /turtle1/pose</span><br></pre></td></tr></table></figure>
<h3 id="发布话题消息">发布话题消息</h3>
<p>想让海龟直接动起来，可以直接通过命令行发布话题指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 topic pub --rate 1 /turtule1/cmd_vel geometry_msgs/msg/Twist <span class="string">&quot;&#123;linear: &#123;x: 2.0, y: 0.0, z: 0.0&#125;, angular: &#123;x: 0.0, y: 0.0, z: 1.8&#125;&#125;&quot;</span></span><br></pre></td></tr></table></figure>
<p><img data-src="2022-12-17-13-59-05-image.png" /></p>
<h3 id="发送服务请求">发送服务请求</h3>
<p>一只小海龟太孤单，仿真器还提供了另外一个服务，产生海龟，我们试一试服务调用，再来一只小海龟，图片也如上图所示</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 service call /spawn turtlesim/srv/Spwan <span class="string">&quot;&#123;x: 2, y: 2, theta: 0.2, name:&#x27;&#x27;&#125;&quot;</span><span class="string">&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="发送动作目标">发送动作目标</h3>
<p>想让海龟完成一个具体动作，比如转到指定角度，仿真器提供的action可以实现：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 action send_goal /turtle1/rotate_absolute turtlesim/action/RotateAbsolute <span class="string">&quot;theta: 3&quot;</span></span><br></pre></td></tr></table></figure>
<p>再继续发布上述话题的基础上，会发现小乌龟在转变了角度以后继续转圈：</p>
<p><img data-src="2022-12-17-14-01-39-image.png" /></p>
<h3 id="录制控制命令">录制控制命令</h3>
<p>系统中运行的数据有很多，如果想要把某段数据录制下来，然后再复现这段数据。</p>
<p>ros2中的rosbag命令可以实现上面的需求：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 bag record /turtle1/cmd_vel</span><br><span class="line">ros2 bag play rosbag2_2022_04_11-17_35_40/rosbag2_2022_04_11-17_35_40_0.db3</span><br></pre></td></tr></table></figure>
<p><img data-src="2022-12-17-14-04-20-image.png" /></p>
<p>以上就是ROS2中的常见命令。</p>
]]></content>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS实战（八）ROS2初探</title>
    <url>/p/hello-to-ros2/</url>
    <content><![CDATA[<p><strong>摘要：转眼间三年已经过去，而我也开始面临毕业的问题。由于导师放养式的教学，导致我的论文一直没什么长进。抱怨没有用，一切靠自己。还是得把之前丢下的捡起来。</strong></p>
<p>本文主要介绍ROS2.</p>
<p><strong>关键词：ROS2</strong></p>
<span id="more"></span>
<h2 id="为什么是ros2">为什么是ROS2</h2>
<p>ROS2是一个全新的机器人操作系统，在借鉴ROS1成功经验的基础上，对系统架构和软件代码全部进行了重新设计和实现。与ROS1相比，体现在以下几点：</p>
<figure>
<img data-src="https://book.guyuehome.com/ROS2/1.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/image/1.2_ROS2%E5%AF%B9%E6%AF%94ROS1/image-20220523114359304.png"
alt="image-20220523114359304" />
<figcaption aria-hidden="true">image-20220523114359304</figcaption>
</figure>
<ul>
<li><p><strong>系统出现了颠覆性的变化</strong>，ROS1的所有节点都需要在节点管理器ROS
Master下进行工作，一旦Master出现问题，系统就会宕机。ROS2实现了真正的分布式，不再有Master这个角色，借助全新的通信框架DDS，为所有节点提供了可靠通信保障。</p></li>
<li><p><strong>软件API进行了重新设计</strong>，ROS1原有的接口无法满足需求，ROS2结合C++最新标准和Python3语言特性，设计了更具通用的API，虽然导致原有ROS1的代码无法直接在ROS2上运行，但是尽量保留了类似的使用方法，同时提供了大量的移植说明。</p></li>
<li><p><strong>编译系统进行了升级</strong>，ROS1仲使用的rosbuild和catkin问题诸多，尤其是针对代码比较多的项目以及Python编写的项目。编译、连接经常会出错，ROS2对这些进行了优化，重新优化后的编译系统叫做<strong>ament和colcon</strong>。</p>
<p>以上几点是框架层面的优化，而ROS1和ROS2的明显变化，请看下文：</p>
<h2 id="ros2-vs-ros1">ROS2 vs ROS1</h2>
<h3 id="系统架构">系统架构</h3>
<figure>
<img data-src="https://book.guyuehome.com/ROS2/1.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/image/1.2_ROS2%E5%AF%B9%E6%AF%94ROS1/image26-16532775781034.png"
alt="image26" />
<figcaption aria-hidden="true">image26</figcaption>
</figure>
<p>如图所示，可以看出最大的变化就是<strong>Master。</strong></p></li>
<li><p>ROS1中，应用层里面的<strong>Master</strong>节点管理器至关重要，所有节点都得听他指挥。ROS2把这个不稳定的角色请走了，节点可以通过自发现机制找到彼此，从而建立稳定的通信连接；</p></li>
<li><p>中间层是ROS封装好的标准通信接口，写程序会频繁和这些接口打交道，比如发布一个图像的数据，接受一个雷达的信息，客户端库再调用底层复杂的驱动和通信协议，使得我们的开发变得更加明了。</p></li>
<li><p>ROS1中，ROS通信依赖底层的TCP和UDP通信，ROS2中，通信协议换成了更见复杂但更见完善的DDS系统；</p></li>
<li><p>如果是进程内需要大量数据的通信，ROS1和ROS2都提供了基于共享内存的通信方法，只不过名字不太一样；</p></li>
<li><p>最下面是系统层，也就是ROS可以安装在那些操作系统上，ROS1主要安装在Linux上，ROS2的可选项很多，Linux、Windows、MacOS、RTOS都可以；</p></li>
</ul>
<h3 id="dds通信">DDS通信</h3>
<figure>
<img data-src="https://book.guyuehome.com/ROS2/1.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/image/1.2_ROS2%E5%AF%B9%E6%AF%94ROS1/image27.png"
alt="image27" />
<figcaption aria-hidden="true">image27</figcaption>
</figure>
<p>ROS1中基于TCP/UDP的通信系统，频繁诟病与延迟、丢数据、无法加密等问题，ROS2中的DDS在通信层面的功能就丰富多了；</p>
<p>DDS是物联网中广泛得到应用的一种通信协议。DDS是一个国际标准，能够实现该标准的软件系统并不是唯一的，可以选择多个厂家提供的DDS系统，比如<strong>OpenSplice、FastRTPS</strong>，还有更多厂家提供的，<strong>每一家的性能不同，适用的场景也不一样</strong>；</p>
<p>ROS2设计了个ROS
Middleware，RMW，也就是指定一个标准的接口，<strong>比如如何发数据、如何收数据，数据的各自属性如何配置，等</strong>。如果厂家想要接入DDS社区，需要按照这个标准写一个适配的接口，将自家的DDS移植过来，这样问题交给了熟悉自家的DDS厂家。</p>
<p><strong>当我们在产品开发时，可以先用开源版本的DDS满足业务需求，部署交付的产品时，再更改为商业版本更加稳定的DDS，减少开发成本。</strong></p>
<p>总之，DDS的加入，让ROS2更加稳定，也更加灵活，与之相同的时复杂度也会变高。这样我们不用在纠结ROS的通信系统是否稳定、应该如何优化等问题，更多精力可以放在其他三个部分，专注优化机器人应用功能。</p>
<h3 id="核心概念">核心概念</h3>
<p>ROS1应用以及非常广泛，全球有几百万开发者，大家已经熟悉了ROS1的开发方式和其中很多的概念。ROS2尽量保留了这些概念，以便开发者从ROS1迁移到ROS2。</p>
<figure>
<img data-src="https://book.guyuehome.com/ROS2/1.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/image/1.2_ROS2%E5%AF%B9%E6%AF%94ROS1/image-20220523114814371.png"
alt="image-20220523114814371" />
<figcaption aria-hidden="true">image-20220523114814371</figcaption>
</figure>
<h3 id="编码方式">编码方式</h3>
<p>如果各位熟悉ROS1，这里的概念应该并不陌生，在ROS2中，这些概念依然存在，意义也几乎一致，在本课程的第二个部分，我们就会一一讲解这些概念的含义和使用方法，没有学习过ROS的小伙伴也不用担心。</p>
<figure>
<img data-src="https://book.guyuehome.com/ROS2/1.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/image/1.2_ROS2%E5%AF%B9%E6%AF%94ROS1/image-20220523114851763.png"
alt="image-20220523114851763" />
<figcaption aria-hidden="true">image-20220523114851763</figcaption>
</figure>
<p>总体而言，ROS2会用到更多面向对象的实现方法和语言特性，从编程语言的角度来讲，难度确实会提高一些，不过当我们迈过这道坎之后，就会发现我们写的程序会更具备可读性和可移植性，也会更接接近真实企业中机器人软件开发的过程。</p>
<h3 id="命令行"><strong>命令行</strong></h3>
<p>最后我们再对比下ROS开发中最为常用的一种工具——命令行。</p>
<figure>
<img data-src="https://book.guyuehome.com/ROS2/1.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/image/1.2_ROS2%E5%AF%B9%E6%AF%94ROS1/image-20220523114915528.png"
alt="image-20220523114915528" />
<figcaption aria-hidden="true">image-20220523114915528</figcaption>
</figure>
<p>ROS1中的命令行相对分散，每一个功能都是一个独立的命令，比如rosrun启动某一个节点，rostopic控制话题相关的功能。</p>
<p>ROS2对命令行做了大幅度的集成，所有命令都集成在一个ros2的主命令中，比如ros2
run，表示启动某一个节点，ros2 topic表示话题相关的功能。</p>
<h2 id="总结">总结</h2>
<p>ROS2和ROS1相比，总结如下：</p>
<ul>
<li><strong>节点干掉了Master</strong></li>
<li><strong>通信换成了DDS</strong></li>
<li><strong>核心概念没变化</strong></li>
<li><strong>编程难度有上升</strong></li>
</ul>
]]></content>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言基础（四）客户端模拟发送HTTP请求</title>
    <url>/p/how-to-send-http-request-in-go/</url>
    <content><![CDATA[<p>在Golang中web开发中net/http是经常用到的包，在这个包中包含了各种请求与响应的方式，下面我会一一进行介绍。</p>
<p>关键词：<strong>golang</strong></p>
<span id="more"></span>
<h2 id="get请求">GET请求</h2>
<h3 id="不带参数的get请求">不带参数的GET请求</h3>
<p>直接使用http.Get()函数，返回一个<code>*http.Response</code>类型的变量，使用<code>os.ReadAll(resp.Body)</code>会读取相应后内容</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SendSimpleGetRequest</span><span class="params">()</span></span> &#123;</span><br><span class="line">	response, err := http.Get(<span class="string">&quot;https://www.baidu.com&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> response.Body.Close()</span><br><span class="line">	s, err := io.ReadAll(response.Body)</span><br><span class="line">	fmt.Println(<span class="type">string</span>(s))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="携带参数的get请求">携带参数的GET请求</h3>
<p>使用<code>url.Values&#123;&#125;</code>返回一个<code>map[string][]string</code>类型，不推荐直接在url地址中携带。</p>
<p>可以使用<code>params.Encode()</code>对中文进行编码，防止数据在传输过程中出错。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SendComplexGetRequest</span><span class="params">()</span></span> &#123;</span><br><span class="line">	params := url.Values&#123;&#125;</span><br><span class="line">	urlObj, err := url.Parse(<span class="string">&quot;http://www.baidu.com&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	params.Set(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;afds&quot;</span>)</span><br><span class="line">	params.Set(<span class="string">&quot;id&quot;</span>, <span class="type">string</span>(<span class="string">&quot;1&quot;</span>))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果有中文参数，这个操作会对中文参数进行解析</span></span><br><span class="line">	urlObj.RawQuery = params.Encode()</span><br><span class="line">	urlPath := urlObj.String()</span><br><span class="line">	resp, err := http.Get(urlPath)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">	response, err := io.ReadAll(resp.Body)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;response: %s\n&quot;</span>, response)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="post-请求">Post 请求</h2>
<h3
id="post请求applicationx-www-form-urlencoded">Post请求：application/x-www-form-urlencoded</h3>
这应该是最常见的 POST 提交数据的方式了。浏览器的原生
<form>
<p>表单，如果不设置 <code>enctype</code> 属性，那么最终就会以
<code>application/x-www-form-urlencoded</code> 方式提交数据</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">httpPostForm</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// params := url.Values&#123;&#125;</span></span><br><span class="line">	<span class="comment">// params.Set(&quot;id&quot;, &quot;123&quot;)</span></span><br><span class="line">	params := url.Values&#123;</span><br><span class="line">		<span class="string">&quot;key&quot;</span>: &#123;<span class="string">&quot;value&quot;</span>&#125;,</span><br><span class="line">		<span class="string">&quot;id&quot;</span>:  &#123;<span class="string">&quot;123&quot;</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	resp, _ := http.PostForm(<span class="string">&quot;http://baidu.com&quot;</span>, params)</span><br><span class="line">	fmt.Println(<span class="string">&quot;request header[Content-Type]:&quot;</span>, resp.Request.Header[<span class="string">&quot;Content-Type&quot;</span>])</span><br><span class="line">	<span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">	s, _ := io.ReadAll(resp.Body)</span><br><span class="line">	fmt.Println(<span class="type">string</span>(s))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="post请求multipartform-data">Post请求：multipart/form-data</h3>
<p>multipart/form-data的基础方法是post，其请求头必须包含一个特殊的头信息：<code>Content-Type</code>，值为<code>multipart/form-data</code>，同时还需要规定一个内容分割符用于分割请求体中的多个post的内容。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">httpPostMultipartField</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	url := <span class="string">&quot;/qb/api/v2/auth/login&quot;</span></span><br><span class="line">	method := <span class="string">&quot;POST&quot;</span></span><br><span class="line"></span><br><span class="line">	body := &amp;bytes.Buffer&#123;&#125;</span><br><span class="line">	writer := multipart.NewWriter(body)</span><br><span class="line">	err := writer.WriteField(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;fly97&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	err = writer.WriteField(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;xxxx&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	err = writer.Close()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	req, err := http.NewRequest(method, url, body)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	req.Header.Set(<span class="string">&quot;Content-Type&quot;</span>, writer.FormDataContentType())</span><br><span class="line">	resp, err := http.DefaultClient.Do(req)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;request header[Content-Type]:&quot;</span>, resp.Request.Header[<span class="string">&quot;Content-Type&quot;</span>])</span><br><span class="line">	<span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line"></span><br><span class="line">	response, err := io.ReadAll(resp.Body)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;response: %s&quot;</span>, response)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="客户端通用模式">客户端通用模式</h2>
<p>一般遵循以下的顺序：</p>
<ol type="1">
<li>使用<code>http.Client&#123;&#125;</code>实例化一个客户端；</li>
<li>使用<code>http.NewRequest()</code>新创建一个请求；</li>
<li>设置请求头<code>req.Header.Set()</code>；</li>
<li>使用<code>client.Do(req)</code>发送请求；</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">httpDo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    client := &amp;http.Client&#123;&#125;</span><br><span class="line"></span><br><span class="line">    urlmap := url.Values&#123;&#125;</span><br><span class="line"></span><br><span class="line">    urlmap.Add(<span class="string">&quot;client_id&quot;</span>, <span class="string">&quot;esss&quot;</span>)</span><br><span class="line">    urlmap.Add(<span class="string">&quot;client_secret&quot;</span>, <span class="string">&quot;sk&quot;</span>)</span><br><span class="line">    parms := ioutil.NopCloser(strings.NewReader(urlmap.Encode())) <span class="comment">//把form数据编下码</span></span><br><span class="line">    req, err := http.NewRequest(<span class="string">&quot;POST&quot;</span>, <span class="string">&quot;www.baidu.com&quot;</span>, parms)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// handle error</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    req.Header.Set(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>)</span><br><span class="line">    req.Header.Set(<span class="string">&quot;Cookie&quot;</span>, <span class="string">&quot;name=anny&quot;</span>)</span><br><span class="line"></span><br><span class="line">    resp, err := client.Do(req)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line"></span><br><span class="line">    body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// handle error</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="type">string</span>(body))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>一些常见的运维操作</title>
    <url>/p/common-operation-and-maintenance-operations/</url>
    <content><![CDATA[<p>关键词：<strong>运维操作</strong></p>
<span id="more"></span>
<h3 id="sudo无需输入密码">sudo无需输入密码</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;%sudo ALL=(ALL) NOPASSWD:ALL&quot;</span> &gt;&gt; /etc/sudoers</span><br></pre></td></tr></table></figure>
<h3 id="一键安装docker">一键安装docker</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -fsSL get.docker.com -o get-docker.sh</span><br><span class="line"><span class="comment"># sudo sh get-docker.sh --mirror </span></span><br><span class="line">sudo sh get-docker.sh --mirror Aliyun</span><br></pre></td></tr></table></figure>
<h3 id="docker需要使用sudo">docker需要使用sudo</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo groupadd docker</span><br><span class="line">sudo gpasswd -a <span class="variable">$&#123;USER&#125;</span> docker</span><br><span class="line">sudo service docker restart</span><br><span class="line">newgrp - docker</span><br></pre></td></tr></table></figure>
<h3 id="查看文件夹占用">查看文件夹占用</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo du -s /* | sort -nr</span><br><span class="line">sudo du -h  --max-depth=1</span><br></pre></td></tr></table></figure>
<h3 id="清理docker冗余容器">清理docker冗余容器</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker system prune -a</span><br></pre></td></tr></table></figure>
<h3 id="清理k3s冗余容器">清理k3s冗余容器</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo k3s crictl rmi --prune</span><br></pre></td></tr></table></figure>
<h3 id="systemctl定时执行任务">Systemctl定时执行任务</h3>
<p>参考</p>
<ol type="1">
<li><p><a
href="https://www.cnblogs.com/operationhome/p/10720067.html">Linux
定时任务 crontab 和 Systemd Timer - 自由早晚乱余生 - 博客园</a></p></li>
<li><p>https://www.junmajinlong.com/linux/systemd/systemd_timer/</p></li>
</ol>
<p>执行文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=GLaDOS Checkin Service</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/usr/bin/docker compose -f /home/wf09/glados/docker-compose.yml up</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>
<p>timer触发器：以每天3点执行一次为例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=GLaDOS Checkin Timer</span><br><span class="line"></span><br><span class="line">[Timer]</span><br><span class="line">OnCalendar=*-*-* 03:00:00</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>
<h3 id="bash-date日期时间">bash date日期时间</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">date</span> <span class="string">&#x27;+%Y-%m-%d %H:%M:%S&#x27;</span></span><br><span class="line">2021-08-17 22:49:57</span><br><span class="line"><span class="built_in">date</span> <span class="string">&#x27;+%Y-%m-%d&#x27;</span></span><br><span class="line">2021-08-17</span><br><span class="line"><span class="built_in">date</span> <span class="string">&#x27;+%Y%m%d&#x27;</span></span><br><span class="line">20210817</span><br><span class="line"><span class="built_in">date</span> +%Y%m%d</span><br><span class="line">20210817</span><br><span class="line"><span class="built_in">date</span> +%s</span><br><span class="line">1629211600</span><br></pre></td></tr></table></figure>
<h3 id="linux软连接">Linux软连接</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s 源文件 目的文件</span><br></pre></td></tr></table></figure>
<h3 id="debian类修改源">debian类修改源</h3>
<h4 id="amd64">amd64</h4>
<h5 id="ubuntu">ubuntu</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo sed -i <span class="string">&#x27;s/cn.archive.ubuntu.com/mirrors.ustc.edu.cn/g&#x27;</span> /etc/apt/sources.list</span><br><span class="line">sudo sed -i <span class="string">&#x27;s/security.ubuntu.com/mirrors.ustc.edu.cn/g&#x27;</span> /etc/apt/sources.list</span><br></pre></td></tr></table></figure>
<h5 id="debian">debian</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo sed -i <span class="string">&#x27;s/deb.debian.org/mirrors.ustc.edu.cn/g&#x27;</span> /etc/apt/sources.list</span><br><span class="line">sudo sed -i <span class="string">&#x27;s|security.debian.org/debian-security|mirrors.ustc.edu.cn/debian-security|g&#x27;</span> /etc/apt/sources.list</span><br></pre></td></tr></table></figure>
<h4 id="arm64">arm64</h4>
<h5 id="ubuntu-1">ubuntu</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo sed -i <span class="string">&#x27;s/ports.ubuntu.com/mirrors.ustc.edu.cn/g&#x27;</span> /etc/apt/sources.list</span><br><span class="line">sudo sed -i <span class="string">&#x27;s/ports.ubuntu.com/mirrors.ustc.edu.cn/g&#x27;</span> /etc/apt/sources.list</span><br></pre></td></tr></table></figure>
<h4 id="树莓派">树莓派</h4>
<p>arm64架构的树莓派可以直接用debian的源 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo su</span><br><span class="line"><span class="built_in">echo</span> &gt; /etc/apt/sources.list</span><br><span class="line">sudo vim /etc/apt/sources.list</span><br></pre></td></tr></table></figure> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deb https://mirrors.ustc.edu.cn/debian/ bullseye main contrib non-free</span><br><span class="line"><span class="comment"># deb-src http://mirrors.ustc.edu.cn/debian bullseye main contrib non-free</span></span><br><span class="line">deb https://mirrors.ustc.edu.cn/debian/ bullseye-updates main contrib non-free</span><br><span class="line"><span class="comment"># deb-src http://mirrors.ustc.edu.cn/debian bullseye-updates main contrib non-free</span></span><br><span class="line">deb https://mirrors.ustc.edu.cn/debian-security bullseye-security main contrib non-free</span><br><span class="line"><span class="comment"># deb-src http://mirrors.ustc.edu.cn/debian-security/ bullseye-security main non-free contrib</span></span><br></pre></td></tr></table></figure>
树莓派基金会源 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo sed -i <span class="string">&#x27;s|//archive.raspberrypi.org|//mirrors.ustc.edu.cn/archive.raspberrypi.org|g&#x27;</span> /etc/apt/sources.list.d/raspi.list</span><br></pre></td></tr></table></figure> #### Docker</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">20.04</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">set</span> -ex \ </span></span><br><span class="line">    &amp;&amp; sed -i <span class="string">&#x27;s/archive.ubuntu.com/mirrors.ustc.edu.cn/g&#x27;</span> /etc/apt/sources.list \</span><br><span class="line">    &amp;&amp; sed -i <span class="string">&#x27;s/security.ubuntu.com/mirrors.ustc.edu.cn/g&#x27;</span> /etc/apt/sources.list \</span><br><span class="line">    &amp;&amp; apt-get update \</span><br><span class="line">    &amp;&amp; apt-get install tzdata curl procps -y \</span><br><span class="line">    &amp;&amp; groupadd -g <span class="number">1000</span> admin -o -f \</span><br><span class="line">    &amp;&amp; useradd -m -G admin --uid <span class="number">1000</span> --gid <span class="number">1000</span> admin \</span><br><span class="line">    &amp;&amp; apt-get clean</span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /home/admin</span></span><br><span class="line"><span class="keyword">USER</span> admin</span><br></pre></td></tr></table></figure>
<h3 id="安装最新版nginx">安装最新版nginx</h3>
<h4 id="ubuntu-2">ubuntu</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install curl gnupg2 ca-certificates lsb-release ubuntu-keyring -y</span><br><span class="line">curl https://nginx.org/keys/nginx_signing.key | gpg --dearmor \</span><br><span class="line">    | sudo <span class="built_in">tee</span> /usr/share/keyrings/nginx-archive-keyring.gpg &gt;/dev/null</span><br><span class="line">gpg --dry-run --quiet --import --import-options import-show /usr/share/keyrings/nginx-archive-keyring.gpg</span><br><span class="line"></span><br><span class="line"><span class="comment"># stable</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb [signed-by=/usr/share/keyrings/nginx-archive-keyring.gpg] \</span></span><br><span class="line"><span class="string">http://nginx.org/packages/ubuntu `lsb_release -cs` nginx&quot;</span> \</span><br><span class="line">    | sudo <span class="built_in">tee</span> /etc/apt/sources.list.d/nginx.list</span><br><span class="line"><span class="comment"># 优先级</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;Package: *\nPin: origin nginx.org\nPin: release o=nginx\nPin-Priority: 900\n&quot;</span> \</span><br><span class="line">    | sudo <span class="built_in">tee</span> /etc/apt/preferences.d/99nginx</span><br><span class="line"><span class="comment"># 安装</span></span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install nginx</span><br></pre></td></tr></table></figure>
<h4 id="debian-1">debian</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install curl gnupg2 ca-certificates lsb-release debian-archive-keyring -y</span><br><span class="line">curl https://nginx.org/keys/nginx_signing.key | gpg --dearmor \</span><br><span class="line">    | sudo <span class="built_in">tee</span> /usr/share/keyrings/nginx-archive-keyring.gpg &gt;/dev/null</span><br><span class="line">gpg --dry-run --quiet --import --import-options import-show /usr/share/keyrings/nginx-archive-keyring.gpg</span><br><span class="line"><span class="comment"># stable</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb [signed-by=/usr/share/keyrings/nginx-archive-keyring.gpg] \</span></span><br><span class="line"><span class="string">http://nginx.org/packages/debian `lsb_release -cs` nginx&quot;</span> \</span><br><span class="line">    | sudo <span class="built_in">tee</span> /etc/apt/sources.list.d/nginx.list</span><br><span class="line"><span class="comment"># 优先级</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;Package: *\nPin: origin nginx.org\nPin: release o=nginx\nPin-Priority: 900\n&quot;</span> \</span><br><span class="line">    | sudo <span class="built_in">tee</span> /etc/apt/preferences.d/99nginx</span><br><span class="line"><span class="comment"># 安装</span></span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install nginx</span><br></pre></td></tr></table></figure>
<h3 id="nginx基本配置">nginx基本配置</h3>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">  <span class="attribute">charset</span> utf-<span class="number">8</span>;</span><br><span class="line">  <span class="comment">#listen unix:/dev/shm/default.sock proxy_protocol;</span></span><br><span class="line">  <span class="comment">#listen unix:/dev/shm/h2c.sock http2 proxy_protocol;</span></span><br><span class="line">  <span class="attribute">listen</span> <span class="number">443</span> default_server ssl;</span><br><span class="line">  <span class="attribute">server_name</span> harbor.lo;</span><br><span class="line">  <span class="attribute">ssl_session_cache</span> shared:SSL:<span class="number">10m</span>;</span><br><span class="line">  <span class="attribute">ssl_certificate</span>     /home/ubuntu/.ssl/cert.cer;</span><br><span class="line">  <span class="attribute">ssl_certificate_key</span>  /home/ubuntu/.ssl/cert.key;</span><br><span class="line"></span><br><span class="line">  <span class="comment">#ssl_stapling on;</span></span><br><span class="line">  <span class="comment">#ssl_stapling_verify on;</span></span><br><span class="line"></span><br><span class="line">  <span class="attribute">ssl_session_timeout</span> <span class="number">10m</span>;</span><br><span class="line">  <span class="attribute">ssl_ciphers</span> HIGH:!aNULL:!MD5;</span><br><span class="line">  <span class="attribute">ssl_prefer_server_ciphers</span> <span class="literal">on</span>;</span><br><span class="line">  <span class="attribute">ssl_protocols</span> TLSv1 TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span> TLSv1.<span class="number">3</span>;</span><br><span class="line">  <span class="section">location</span> / &#123;</span><br><span class="line">    <span class="comment">#proxy_redirect off;</span></span><br><span class="line">    <span class="comment">#proxy_pass https://wf09.github.io/;</span></span><br><span class="line">    <span class="comment">#alias /home/ubuntu/tmp/;</span></span><br><span class="line">    <span class="attribute">return</span> <span class="number">403</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="gitlab配置">gitlab配置</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> server &#123;</span><br><span class="line">   charset utf-8;</span><br><span class="line">   <span class="comment">#listen unix:/dev/shm/default.sock proxy_protocol;</span></span><br><span class="line">   <span class="comment">#listen unix:/dev/shm/h2c.sock http2 proxy_protocol;</span></span><br><span class="line">   listen 443  ssl;</span><br><span class="line">   server_name gitlab.lo;</span><br><span class="line">   ssl_session_cache shared:SSL:10m;</span><br><span class="line">   ssl_certificate     /usr/local/ssl/gitlab.lo.crt;</span><br><span class="line">   ssl_certificate_key  /usr/local/ssl/gitlab.lo.key;</span><br><span class="line"></span><br><span class="line">   <span class="comment">#ssl_stapling on;</span></span><br><span class="line">   <span class="comment">#ssl_stapling_verify on;</span></span><br><span class="line"></span><br><span class="line">   ssl_session_timeout 10m;</span><br><span class="line">   ssl_ciphers HIGH:!aNULL:!MD5;</span><br><span class="line">   ssl_prefer_server_ciphers on;</span><br><span class="line">   ssl_protocols TLSv1 TLSv1.1 TLSv1.2 TLSv1.3;</span><br><span class="line"></span><br><span class="line">   location / &#123;</span><br><span class="line">     <span class="comment">#proxy_redirect off;</span></span><br><span class="line">     <span class="comment">#proxy_pass https://wf09.github.io/;</span></span><br><span class="line">     <span class="comment">#alias /home/ubuntu/tmp/;</span></span><br><span class="line">     <span class="comment">#return 403;</span></span><br><span class="line">     client_max_body_size 0;</span><br><span class="line">     proxy_pass http://192.168.15.200:8880;</span><br><span class="line">     proxy_set_header Host <span class="variable">$host</span>; <span class="comment"># required for docker client&#x27;s sake</span></span><br><span class="line">     proxy_set_header X-Real-IP <span class="variable">$remote_addr</span>; <span class="comment"># pass on real client&#x27;s IP</span></span><br><span class="line">     proxy_set_header X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">     proxy_set_header X-Forwarded-Proto <span class="variable">$scheme</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="其他配置">其他配置</h4>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">worker_processes</span> auto;</span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">  <span class="attribute">worker_connections</span> <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">  <span class="attribute">proxy_headers_hash_max_size</span> <span class="number">51200</span>;</span><br><span class="line">  <span class="attribute">proxy_headers_hash_bucket_size</span> <span class="number">6400</span>;</span><br><span class="line">  <span class="attribute">log_format</span> main <span class="string">&#x27;<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] &quot;<span class="variable">$request</span>&quot; &#x27;</span></span><br><span class="line">  <span class="string">&#x27;<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> &quot;<span class="variable">$http_referer</span>&quot; &#x27;</span></span><br><span class="line">  <span class="string">&#x27;&quot;<span class="variable">$http_user_agent</span>&quot; &quot;<span class="variable">$http_x_forwarded_for</span>&quot; &#x27;</span></span><br><span class="line">  <span class="string">&#x27;<span class="variable">$proxy_protocol_addr</span>:<span class="variable">$proxy_protocol_port</span>&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">access_log</span> /var/log/nginx/access.log main;</span><br><span class="line">  <span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">charset</span> utf-<span class="number">8</span>;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> ssl http2;</span><br><span class="line">    <span class="attribute">server_name</span> ap-sg-do.fly97.dev;</span><br><span class="line">    <span class="attribute">ssl_session_cache</span> shared:SSL:<span class="number">10m</span>;</span><br><span class="line">    <span class="attribute">ssl_certificate</span>     /usr/local/bin/cert.pem;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span>  /usr/local/bin/key.pem;</span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">      <span class="comment">#proxy_redirect off;</span></span><br><span class="line">      <span class="comment">#proxy_pass https://wf09.github.io/;</span></span><br><span class="line">      <span class="comment">#alias /home/ubuntu/tmp/;</span></span><br><span class="line">      <span class="attribute">return</span> <span class="number">403</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span><span class="regexp"> ^~</span> /my/ &#123;</span><br><span class="line">      <span class="comment">#auth_basic &quot;Permission Denied&quot;;</span></span><br><span class="line">      <span class="comment">#auth_basic_user_file /usr/local/passwd;</span></span><br><span class="line">      <span class="attribute">alias</span> /mnt/volume_sgp1_01/;</span><br><span class="line">      <span class="attribute">autoindex</span> <span class="literal">on</span>;</span><br><span class="line">      <span class="attribute">proxy_force_ranges</span> <span class="literal">on</span>;</span><br><span class="line">      <span class="attribute">max_ranges</span> <span class="number">32</span>;</span><br><span class="line">      <span class="attribute">autoindex_exact_size</span> <span class="literal">off</span>;</span><br><span class="line">      <span class="attribute">add_header</span> Strict-Transport-Security <span class="string">&quot;max-age=31536000; includeSubDomains&quot;</span> always;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> /qb/ &#123;</span><br><span class="line">      <span class="attribute">proxy_redirect</span> <span class="literal">off</span>;</span><br><span class="line">      <span class="attribute">proxy_pass</span> http://127.0.0.1:8090/;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">      <span class="attribute">add_header</span> Strict-Transport-Security <span class="string">&quot;max-age=31536000; includeSubDomains&quot;</span> always;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> X-Forwarded-Proto <span class="variable">$scheme</span>;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> REMOTE-HOST <span class="variable">$remote_addr</span>;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> Range <span class="variable">$http_range</span>;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> If-Range <span class="variable">$http_if_range</span>;</span><br><span class="line">      <span class="attribute">proxy_no_cache</span> <span class="variable">$http_range</span> <span class="variable">$http_if_range</span>;</span><br><span class="line">      <span class="comment"># 如果server_name不是公网域名，这个地方可以设置成ip</span></span><br><span class="line">      <span class="attribute">proxy_set_header</span> X-Forwarded-Host <span class="variable">$host</span>;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> X-Forwarded-Proto <span class="variable">$scheme</span>;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> Upgrade <span class="variable">$http_upgrade</span>;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> Connection <span class="string">&quot;upgrade&quot;</span>;</span><br><span class="line">      <span class="attribute">http2_push_preload</span> <span class="literal">on</span>;</span><br><span class="line">      <span class="comment">#这个是设置为0表示不管上传多大的文件都不会报request too large的问题，直接转发过去</span></span><br><span class="line">      <span class="attribute">client_max_body_size</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="service模版">service模版</h3>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line">[<span class="string">Unit</span>]</span><br><span class="line"><span class="string">Description=Lightweight</span> <span class="string">Kubernetes</span></span><br><span class="line"><span class="string">Documentation=https://k3s.io</span></span><br><span class="line"><span class="string">Wants=network-online.target</span></span><br><span class="line"><span class="string">After=network-online.target</span></span><br><span class="line"></span><br><span class="line">[<span class="string">Install</span>]</span><br><span class="line"><span class="string">WantedBy=multi-user.target</span></span><br><span class="line"></span><br><span class="line">[<span class="string">Service</span>]</span><br><span class="line"><span class="string">Type=notify</span></span><br><span class="line"><span class="string">EnvironmentFile=-/etc/default/%N</span></span><br><span class="line"><span class="string">EnvironmentFile=-/etc/sysconfig/%N</span></span><br><span class="line"><span class="string">EnvironmentFile=-/etc/systemd/system/k3s.service.env</span></span><br><span class="line"><span class="string">KillMode=process</span></span><br><span class="line"><span class="string">Delegate=yes</span></span><br><span class="line"><span class="comment"># Having non-zero Limit*s causes performance problems due to accounting overhead</span></span><br><span class="line"><span class="comment"># in the kernel. We recommend using cgroups to do container-local accounting.</span></span><br><span class="line"><span class="string">LimitNOFILE=1048576</span></span><br><span class="line"><span class="string">LimitNPROC=infinity</span></span><br><span class="line"><span class="string">LimitCORE=infinity</span></span><br><span class="line"><span class="string">TasksMax=infinity</span></span><br><span class="line"><span class="string">TimeoutStartSec=0</span></span><br><span class="line"><span class="string">Restart=always</span></span><br><span class="line"><span class="string">RestartSec=5s</span></span><br><span class="line"><span class="string">ExecStartPre=/bin/sh</span> <span class="string">-xc</span> <span class="string">&#x27;! /usr/bin/systemctl is-enabled --quiet nm-cloud-setup.service&#x27;</span></span><br><span class="line"><span class="string">ExecStartPre=-/sbin/modprobe</span> <span class="string">br_netfilter</span></span><br><span class="line"><span class="string">ExecStartPre=-/sbin/modprobe</span> <span class="string">overlay</span></span><br><span class="line"><span class="string">ExecStart=/usr/local/bin/k3s</span> <span class="string">server</span> <span class="string">--node-ip</span> <span class="number">192.168</span><span class="number">.7</span><span class="number">.2</span> <span class="string">--node-external-ip</span> <span class="number">192.168</span><span class="number">.15</span><span class="number">.201</span> <span class="string">--tls-san</span> <span class="number">192.168</span><span class="number">.7</span><span class="number">.2</span> <span class="string">--flannel-backend</span> <span class="string">host-gw</span> <span class="string">--flannel-iface</span> <span class="string">wg0</span> <span class="string">--no-deploy</span> <span class="string">servicelb</span> <span class="string">--write-kubeconfig-mode</span> <span class="number">644</span> <span class="string">--kube-proxy-arg</span> <span class="string">&#x27;proxy-mode=ipvs&#x27;</span> <span class="string">--kube-proxy-arg</span> <span class="string">&#x27;ipvs-scheduler=rr&#x27;</span> <span class="string">--kube-proxy-arg</span> <span class="string">&#x27;masquerade-all=true&#x27;</span> <span class="string">--kube-proxy-arg</span> <span class="string">&#x27;metrics-bind-address=0.0.0.0:10249&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="docker-compose常用配置">docker-compose常用配置</h3>
<h4 id="node-exporter">node exporter</h4>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">        <span class="attr">node_exporter:</span></span><br><span class="line">                <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">                <span class="attr">image:</span> <span class="string">prom/node-exporter</span></span><br><span class="line">                <span class="attr">volumes:</span></span><br><span class="line">                        <span class="bullet">-</span> <span class="string">/run:/run</span></span><br><span class="line">                        <span class="bullet">-</span> <span class="string">/proc:/host/proc:ro</span></span><br><span class="line">                        <span class="bullet">-</span> <span class="string">/sys:/host/sys:ro</span></span><br><span class="line">                        <span class="bullet">-</span> <span class="string">/:/rootfs:ro</span></span><br><span class="line">                <span class="attr">command:</span></span><br><span class="line">                        <span class="bullet">-</span> <span class="string">&quot;--web.listen-address=:9100&quot;</span></span><br><span class="line">                        <span class="bullet">-</span> <span class="string">&quot;--path.procfs=/host/proc&quot;</span></span><br><span class="line">                        <span class="bullet">-</span> <span class="string">&quot;--path.sysfs=/host/sys&quot;</span></span><br><span class="line">                        <span class="bullet">-</span> <span class="string">&quot;--path.rootfs=/rootfs&quot;</span> <span class="comment"># Necessary for collecting host filesystem metrics.</span></span><br><span class="line">                        <span class="bullet">-</span> <span class="string">&quot;--collector.filesystem.ignored-mount-points=&#x27;^/(sys|proc|dev|host|etc|rootfs/var/lib/docker/containers|rootfs/var/lib/docker/overlay2|rootfs/run/docker/netns|rootfs/var/lib/docker/aufs)($$|/)&#x27;&quot;</span></span><br><span class="line">                <span class="attr">ports:</span></span><br><span class="line">                        <span class="bullet">-</span> <span class="number">9100</span><span class="string">:9100</span></span><br><span class="line">                <span class="attr">restart:</span> <span class="string">always</span></span><br></pre></td></tr></table></figure>
<h4 id="普罗米修斯">普罗米修斯</h4>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">        <span class="attr">prometheus:</span></span><br><span class="line">                <span class="attr">image:</span> <span class="string">prom/prometheus</span></span><br><span class="line">                <span class="attr">ports:</span></span><br><span class="line">                        <span class="bullet">-</span> <span class="number">9091</span><span class="string">:9090</span></span><br><span class="line">                <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">                <span class="attr">volumes:</span></span><br><span class="line">                        <span class="bullet">-</span> <span class="string">./conf:/etc/prometheus</span></span><br><span class="line">                        <span class="bullet">-</span> <span class="string">./data:/prometheus</span></span><br></pre></td></tr></table></figure>
<h4 id="grafana">grafana</h4>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">        <span class="attr">grafana:</span></span><br><span class="line">                <span class="attr">image:</span> <span class="string">grafana/grafana:9.3.1-ubuntu</span></span><br><span class="line">                <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">                <span class="attr">volumes:</span></span><br><span class="line">                        <span class="bullet">-</span> <span class="string">./sample.ini:/etc/grafana/grafana.ini</span></span><br><span class="line">                        <span class="bullet">-</span> <span class="string">./data:/var/lib/grafana</span></span><br><span class="line">                <span class="attr">ports:</span></span><br><span class="line">                        <span class="bullet">-</span> <span class="number">3000</span><span class="string">:3000</span></span><br></pre></td></tr></table></figure>
<h4 id="alertmanager">alertManager</h4>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">        <span class="attr">alert:</span></span><br><span class="line">                <span class="attr">image:</span> <span class="string">prom/alertmanager</span></span><br><span class="line">                <span class="attr">ports:</span></span><br><span class="line">                        <span class="bullet">-</span> <span class="number">9093</span><span class="string">:9093</span></span><br><span class="line">                <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">                <span class="attr">volumes:</span></span><br><span class="line">                        <span class="bullet">-</span> <span class="string">./conf:/etc/alertmanager</span></span><br></pre></td></tr></table></figure>
<h4 id="jenkins">jenkins</h4>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.6&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">jenkins:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">&#x27;jenkins/jenkins&#x27;</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">jenkins</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="comment"># hostname: &#x27;gitlab.lo&#x27;                          # ssh hostname</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;127.0.0.1:8882:8080&#x27;</span></span><br><span class="line">    <span class="attr">shm_size:</span> <span class="string">&#x27;256m&#x27;</span></span><br><span class="line">    <span class="attr">ulimits:</span></span><br><span class="line">      <span class="attr">nofile:</span></span><br><span class="line">        <span class="attr">soft:</span> <span class="number">1000000</span></span><br><span class="line">        <span class="attr">hard:</span> <span class="number">1000000</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">resources:</span></span><br><span class="line">        <span class="attr">limits:</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">8G</span></span><br></pre></td></tr></table></figure>
<h4 id="gitlab">gitlab</h4>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.6&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">gitlab:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">&#x27;registry.gitlab.cn/omnibus/gitlab-jh:latest&#x27;</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">gitlab-cn</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">&#x27;gitlab.lo&#x27;</span>                          <span class="comment"># ssh hostname</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">       <span class="attr">GITLAB_OMNIBUS_CONFIG:</span> <span class="string">|</span></span><br><span class="line"><span class="string">         external_url &#x27;https://gitlab.lo&#x27;          # git httpsname</span></span><br><span class="line"><span class="string">         nginx[&#x27;redirect_http_to_https&#x27;] = false</span></span><br><span class="line"><span class="string">         nginx[&#x27;listen_port&#x27;] = 8880</span></span><br><span class="line"><span class="string">         nginx[&#x27;listen_https&#x27;] = false</span></span><br><span class="line"><span class="string">         prometheus_monitoring[&#x27;enable&#x27;] = false</span></span><br><span class="line"><span class="string"></span>    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;127.0.0.1:8881:8880&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;22:22&#x27;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;./config:/etc/gitlab&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;./logs:/var/log/gitlab&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;./data:/var/opt/gitlab&#x27;</span></span><br><span class="line">    <span class="attr">shm_size:</span> <span class="string">&#x27;256m&#x27;</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">resources:</span></span><br><span class="line">        <span class="attr">limits:</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">8G</span></span><br></pre></td></tr></table></figure>
<h3 id="mysql备份脚本">MySQL备份脚本</h3>
<p>将MySQL文件逻辑备份文件以Docker镜像的形式推送到Docker私有镜像服务器</p>
<h4 id="bash脚本">bash脚本</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">day=`<span class="built_in">date</span> <span class="string">&quot;+%Y%m%d&quot;</span>`</span><br><span class="line"><span class="built_in">cd</span> $(<span class="built_in">dirname</span> $(<span class="built_in">readlink</span> -f <span class="string">&quot;<span class="variable">$0</span>&quot;</span>))/data</span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$day</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$day</span></span><br><span class="line">mysqldump -h192.168.31.28 -uroot -proot -A | gzip &gt; <span class="variable">$day</span>.tar.gz</span><br><span class="line"><span class="keyword">if</span> [ $? -ne 0 ]; <span class="keyword">then</span> </span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;MySQL备份失败&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> -1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;FROM busybox\nADD <span class="variable">$day</span>.tar.gz /mysql/<span class="variable">$day</span>.tar.gz&quot;</span> &gt; Dockerfile</span><br><span class="line"><span class="keyword">if</span> [ $? -ne 0 ]; <span class="keyword">then</span> </span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Dockerfile生成失败&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> -1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">[ -f Dockerfile ] &amp;&amp; docker build . -t hub.deepsoft-tech.com/wf09/jixiaobackup:<span class="variable">$day</span></span><br><span class="line"><span class="keyword">if</span> [ $? -ne 0 ]; <span class="keyword">then</span> </span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;镜像生成构建失败&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> -1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">docker login -uadmin -pdeepsoft hub.deepsoft-tech.com</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ $? -ne 0 ]; <span class="keyword">then</span> </span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;登录成功&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> -1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">docker push hub.deepsoft-tech.com/wf09/jixiaobackup:<span class="variable">$day</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ $? -ne 0 ]; <span class="keyword">then</span> </span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;带TAG的镜像推送失败&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> -1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">docker tag hub.deepsoft-tech.com/wf09/jixiaobackup:<span class="variable">$day</span> hub.deepsoft-tech.com/wf09/mysqlbackup</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ $? -ne 0 ]; <span class="keyword">then</span> </span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;镜像推送失败&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> -1</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<h4 id="service单元文件">service单元文件</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Backup MySQL Service</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">ExecStart=/usr/bin/bash -c /home/deepsoft/backup/mysql/backup.sh </span><br><span class="line">StandardError=journal</span><br></pre></td></tr></table></figure>
<h4 id="timer单元文件">timer单元文件</h4>
<p>每周备份两次</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Backup MySQL Timer</span><br><span class="line"></span><br><span class="line">[Timer]</span><br><span class="line">OnCalendar=Sun,Wed 03:30:00</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派常见操作</title>
    <url>/p/use-usb-wifi-with-raspberry-pi/</url>
    <content><![CDATA[<p><strong>摘要：本文主要介绍树莓派的一些常见设置。</strong></p>
<p><strong>关键词：树莓派</strong></p>
<span id="more"></span>
<h2 id="安装外置usb网卡">安装外置USB网卡</h2>
<p>由于树莓派自带的网卡性能不太好，因此就想着用第三方网卡。
使用的网卡如图所示。 <img data-src="微信图片_20221211193757.jpg" /></p>
<p>网卡芯片型号是Realtek 8211CU。</p>
<blockquote>
<p>来源 https://github.com/brektrou/rtl8821CU/issues/184</p>
</blockquote>
<p>依次执行以下操作即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install dkms bc -y</span><br><span class="line">sudo apt-get update &amp;&amp; sudo apt-get install --reinstall raspberrypi-bootloader raspberrypi-kernel</span><br><span class="line">sudo apt-get install raspberrypi-kernel-headers</span><br><span class="line">reboot</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/brektrou/rtl8821CU.git</span><br><span class="line"><span class="built_in">cd</span> rtl8821CU</span><br><span class="line">sudo ./dkms-install.sh</span><br></pre></td></tr></table></figure>
<p>执行完毕以后可以修改一下系统配置，这样系统就可以自动启动WIFI网卡了。</p>
<p>修改一下文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo nano /lib/udev/rules.d/40-usb_modeswitch.rules</span><br></pre></td></tr></table></figure>
<p>添加以下内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Realtek 8211CU Wifi AC USB</span></span><br><span class="line">ATTR&#123;idVendor&#125;==<span class="string">&quot;0bda&quot;</span>, ATTR&#123;idProduct&#125;==<span class="string">&quot;1a2b&quot;</span>, RUN+=<span class="string">&quot;/usr/sbin/usb_modeswitch -K -v 0bda -p 1a2b&quot;</span></span><br></pre></td></tr></table></figure>
<p>然后重启即可</p>
<p>重启完毕以后查看usb：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsusb</span><br></pre></td></tr></table></figure>
<p><img data-src="Snipaste_2022-12-11_19-52-59.png" />
此时就可以发现网卡已经正常工作了。</p>
<h2 id="禁用板载wifi">禁用板载WIFI</h2>
<p>修改boot分区下的config.txt文件</p>
<p>在<code>[all]</code>片段下添加以下配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[all]</span><br><span class="line">dtoverlay=disable-wifi</span><br></pre></td></tr></table></figure>
<p>这样就可以禁用板载WIFI网卡</p>
<h2 id="开启wifi自动登录">开启WIFI自动登录</h2>
<p>在boot分区下添加<code>wpa_supplicant.conf</code>文件</p>
<p>按照以下格式：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">country</span>=CN</span><br><span class="line"><span class="attr">ctrl_interface</span>=DIR=/var/run/wpa_supplicant GROUP=netdev</span><br><span class="line"><span class="attr">update_config</span>=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="attr">network</span>=&#123;</span><br><span class="line"><span class="attr">ssid</span>=<span class="string">&quot;WiFi-A&quot;</span></span><br><span class="line"><span class="attr">psk</span>=<span class="string">&quot;12345678&quot;</span></span><br><span class="line"><span class="attr">key_mgmt</span>=WPA-PSK</span><br><span class="line"><span class="attr">priority</span>=<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="开启ssh登录">开启SSH登录</h2>
<p>在boot分区下新建<code>ssh</code>文件即可</p>
<h2 id="更换为国内源">更换为国内源</h2>
<p>arm64架构的树莓派可以直接用debian的源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo su</span><br><span class="line"><span class="built_in">echo</span> &gt; /etc/apt/sources.list</span><br><span class="line">sudo vim /etc/apt/sources.list</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deb https://mirrors.ustc.edu.cn/debian/ bullseye main contrib non-free</span><br><span class="line"><span class="comment"># deb-src http://mirrors.ustc.edu.cn/debian bullseye main contrib non-free</span></span><br><span class="line">deb https://mirrors.ustc.edu.cn/debian/ bullseye-updates main contrib non-free</span><br><span class="line"><span class="comment"># deb-src http://mirrors.ustc.edu.cn/debian bullseye-updates main contrib non-free</span></span><br><span class="line">deb https://mirrors.ustc.edu.cn/debian-security bullseye-security main contrib non-free</span><br><span class="line"><span class="comment"># deb-src http://mirrors.ustc.edu.cn/debian-security/ bullseye-security main non-free contrib</span></span><br></pre></td></tr></table></figure>
<p>树莓派基金会源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo sed -i <span class="string">&#x27;s|//archive.raspberrypi.org|//mirrors.ustc.edu.cn/archive.raspberrypi.org|g&#x27;</span> /etc/apt/sources.list.d/raspi.list</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>pi</tag>
      </tags>
  </entry>
  <entry>
    <title>DevOps实战（二）使用Docker搭建nexus3私有镜像仓库</title>
    <url>/p/install-nexus3-with-docker/</url>
    <content><![CDATA[<p>什么是DevOps？</p>
<p>DevOps的哲学暂且不表，使用Docker搭建nexus3私有镜像仓库。</p>
<p>关键词：<strong>nexus3</strong></p>
<span id="more"></span>
<h2 id="前言">前言</h2>
<p>在搭建K8s容器平台时，有些镜像需要经常性的被拉取，有时候外网带宽会被大量占用，这在业务上线后是不可取的，为了方便镜像的拉取，私有仓库的概念应运而生。</p>
<p>本文主要介绍使用nexus3搭建私有仓库。</p>
<h2 id="安装">安装</h2>
<p>为了方便起见我们这里直接使用Docker进行快速搭建。</p>
<p>为节省时间，我们这里先拉取好了镜像：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.6&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">nexus3:</span></span><br><span class="line">    <span class="comment">#user: root</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">sonatype/nexus3</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">nexus3</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">https_proxy=http://192.168.31.75:7890</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">http_proxy=http://192.168.31.75:7890</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./nexus-data:/nexus-data</span></span><br><span class="line">    <span class="attr">ulimits:</span></span><br><span class="line">      <span class="attr">nofile:</span></span><br><span class="line">        <span class="attr">soft:</span> <span class="number">1000000</span></span><br><span class="line">        <span class="attr">hard:</span> <span class="number">1000000</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">38081</span><span class="string">:8081</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">7890</span><span class="string">:7890</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">7891</span><span class="string">:7891</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8891</span><span class="string">:8891</span></span><br></pre></td></tr></table></figure>
<p>这里的端口分别是nexus3界面的端口，和。。。。。。。 ##
设置代理类型</p>
<p>Nexus3可以被称为是一个全能型的选手，可以代理几乎所有类型的仓库。</p>
<p><img data-src="image-20221109103319038.png" /></p>
<p>这里介绍几种类型，首先介绍Docker</p>
<h3 id="docker">docker</h3>
<p>docker类型分为docker(group)、docker(hosted)、docker(proxy)三种类型。</p>
<p>docker(proxy)：顾名思义就是代理外部仓库，创建设置可以参考以下</p>
<p><img data-src="image-20221109111325590.png" /></p>
<ul>
<li>这里的HTTP连接器不用选，因为我们后面会通过docker(group)类型聚合这docker(hosted)、docker(proxy)这两种类型的仓库。</li>
<li>远程仓库地址可以使用公开的镜像源，如：
<ul>
<li>https://hub-mirror.c.163.com</li>
<li>https://mirror.baidubce.com</li>
<li>http://f1361db2.m.daocloud.io</li>
<li>https://ustc-edu-cn.mirror.aliyuncs.com</li>
</ul></li>
<li>如果网络条件允许，最好还是使用官方的源：<code>https://registry-1.docker.io</code>，这样会避免由于镜像不更新而导致的错误。</li>
</ul>
<p>docker(hosted)：允许将本地镜像推送到私有仓库的仓库类型，创建设置可以参考以下</p>
<p><img data-src="image-20221109111712080.png" /></p>
<ul>
<li>这里需要选择HTTP连接器，我们通过此HTTP连接器向仓库推送本地镜像</li>
</ul>
<p>docker(group)：将两者类型或者更多种类型的仓库聚合在一起，一起向外部提供服务</p>
<p><img data-src="image-20221109133813885.png" /></p>
<p><img data-src="image-20221109133917141.png" /></p>
<ul>
<li>这里需要选择HTTP连接器，我们通过此HTTP连接器拉取proxy代理的镜像和经过hosted上传的镜像；</li>
<li>这里选择的聚合仓库包含proxy和hosted类型的仓库，我们就可以通过此聚合仓库上传和下载镜像了；</li>
</ul>
<h4 id="nginx代理">Nginx代理</h4>
<p>因为某些原因，我们需要使用nginx反向代理，这里给出使用SSL证书的例子：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> hub.deepsoft-tech.com;</span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">301</span> https://<span class="variable">$host</span><span class="variable">$request_uri</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">charset</span> utf-<span class="number">8</span>;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line">    <span class="attribute">server_tokens</span> <span class="literal">off</span>;</span><br><span class="line">    <span class="attribute">server_name</span> hub.deepsoft-tech.com;</span><br><span class="line">    <span class="attribute">ssl_session_cache</span> shared:SSL:<span class="number">10m</span>;</span><br><span class="line">    <span class="attribute">ssl_certificate</span> /ssl/idocker.crt;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> /ssl/idocker.key;</span><br><span class="line">    <span class="attribute">access_log</span> /var/log/nginx/docker.io.log main;</span><br><span class="line">    <span class="attribute">client_max_body_size</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">chunked_transfer_encoding</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">ssl_session_cache</span> shared:SSL:<span class="number">10m</span>;</span><br><span class="line">    <span class="attribute">ssl_session_timeout</span> <span class="number">10m</span>;</span><br><span class="line">    <span class="attribute">ssl_ciphers</span> HIGH:!aNULL:!MD5;</span><br><span class="line">    <span class="attribute">ssl_prefer_server_ciphers</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">ssl_protocols</span> TLSv1 TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span> TLSv1.<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> <span class="regexp">~ ^/(v1|v2)/[^/]+/?[^/]+/blobs/</span> &#123;</span><br><span class="line">        <span class="attribute">if</span> (<span class="variable">$request_method</span> <span class="regexp">~* (POST|PUT|DELETE|PATCH|HEAD)</span> ) &#123;</span><br><span class="line">            <span class="attribute">rewrite</span><span class="regexp"> ^/(.*)$</span> /repository/docker-local/<span class="variable">$1</span> <span class="literal">last</span>;   <span class="comment"># docker-local是hosted类型的仓库名称</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="attribute">rewrite</span><span class="regexp"> ^/(.*)$</span> /repository/docker/<span class="variable">$1</span> <span class="literal">last</span>;             <span class="comment"># docker是group类型的仓库名称</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> <span class="regexp">~ ^/(v1|v2)/</span> &#123;</span><br><span class="line">        <span class="attribute">if</span> (<span class="variable">$request_method</span> <span class="regexp">~* (POST|PUT|DELETE|PATCH)</span> ) &#123;</span><br><span class="line">            <span class="attribute">rewrite</span><span class="regexp"> ^/(.*)$</span> /repository/docker-local/<span class="variable">$1</span> <span class="literal">last</span>;  <span class="comment"># docker-local是hosted类型的仓库名称</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="attribute">rewrite</span><span class="regexp"> ^/(.*)$</span> /repository/docker/<span class="variable">$1</span> <span class="literal">last</span>;            <span class="comment"># docker是group类型的仓库名称</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://127.0.0.1:38081/;                   <span class="comment"># 38081是nexus对外暴露的端口</span></span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">        <span class="attribute">proxy_connect_timeout</span> <span class="number">3600</span>;</span><br><span class="line">        <span class="attribute">proxy_send_timeout</span> <span class="number">3600</span>;</span><br><span class="line">        <span class="attribute">proxy_read_timeout</span> <span class="number">3600</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        <span class="attribute">proxy_buffering</span> <span class="literal">off</span>;</span><br><span class="line">        <span class="attribute">proxy_request_buffering</span> <span class="literal">off</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-Proto <span class="variable">$scheme</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这么看，hosted类型和group类型的仓库就不需要设置HTTP连接器了；</li>
<li>经过以上设置，推送请求就全部被hosted类型的仓库接管了，而拉取请求则被group类型的仓库接管了；</li>
</ul>
<p>经过上面的一顿操作，就可以通过一个URL拉取所有的镜像了</p>
<h3 id="apt仓库">APT仓库</h3>
<p>有时候需要缓存apt的包，所有就有了下面的文章，幸运的是nexus支持apt类型，稍加设置即可</p>
<p><img data-src="image-20221109152407070.png" /></p>
<ul>
<li>Distribution：发行版的代号，这里以Ubuntu LTS 20.04 为例：focal</li>
<li>Remote storage：代理仓库地址，可以使用镜像源</li>
</ul>
<h4 id="nginx代理-1">Nginx代理</h4>
<p>使用上文的配置文件即可</p>
<h4 id="一键替换">一键替换</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo sed -i <span class="string">&#x27;s|http://mirrors.aliyun.com|https://repo.deepsoft-tech.com/repository|g&#x27;</span> /etc/apt/sources.list</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo sed -i <span class="string">&#x27;s|https://mirrors.aliyun.com/docker-ce/linux/ubuntu|https://repo.deepsoft-tech.com/repository/docker-apt&#x27;</span> /etc/apt/sources.list.d/docker.list</span><br></pre></td></tr></table></figure>
<h3 id="yum仓库">yum仓库</h3>
<p>可以省略Singing Key和Passphrase</p>
<h4 id="kubernetes">kubernetes</h4>
<p>设置Remote storage</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https://packages.cloud.google.com/yum/</span><br></pre></td></tr></table></figure>
<p><img data-src="image-20230827160859581.png" /></p>
<p>在/etc/yum.repos.d下面新建repo文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes Repository</span><br><span class="line">baseurl=https://repo.fly97.fun/repository/kubernetes-yum/repos/kubernetes-el7-<span class="variable">$basearch</span></span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=https://repo.fly97.fun/repository/kubernetes-yum/doc/rpm-package-key.gpg</span><br><span class="line">exclude=kubelet kubeadm kubectl</span><br></pre></td></tr></table></figure>
<h4 id="centos">CentOS</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[CentOS]</span><br><span class="line">name=CentOS Repository</span><br><span class="line">baseurl=https://repo.fly97.fun/repository/yum/<span class="variable">$releasever</span>/os/<span class="variable">$basearch</span>/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>devops</tag>
        <tag>nexus3</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言基础（三）输入输出接口</title>
    <url>/p/input-output-interface/</url>
    <content><![CDATA[<p>本文主要介绍了Go语言输入输出接口。</p>
<p>关键词：<strong>golang</strong></p>
<span id="more"></span>
<h1 id="基本的io接口">基本的IO接口</h1>
<h2 id="reader接口">Reader接口</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>将len(p)个字节读入到p中，返回读取的字节数n以及任何的错误。即使Read返回的n&lt;len(p)，他也会在调用过程中占用len(p)个字节作为暂存空间。若可读取的数据不到len(p)个字节，会返回可用数据，而不是等待更多数据。</p>
<p>当Read在成功读取n个字节后，遇到一个错误或者EOF，会返回读取的字节数，可能会在本次的调用中返回一个non-nil错误，或者在下一次调用中返回这个错误（n为0）。一般情况下，Reader会返回非0字节数n，若n=len(p)个字节从输入源内的结尾处由Read返回，Read可能返回err==EOF或者err==nil，并且之后的Read()都应该返回(n:0,
err:EOF).</p>
<p>调用者在考虑错误之前应当首先处理返回的数据。这样做可以正确的处理在读取一些字节后产生的I/O，允许EOF出现。</p>
</blockquote>
<p>Reader的接口方法集只包含一个Read方法，实现了Read方法的类型都满足io.Reader接口，也就是说在需要io.Reader的地方，可以传递实现了Read()方法的实例。</p>
<p>举例说明Reader接口的方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadFrom</span><span class="params">(reader io.Reader, num <span class="type">int</span>)</span></span>([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    p := <span class="built_in">make</span>([]<span class="type">byte</span>, num)</span><br><span class="line">    n, err := reader.Read(p)</span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> p[:n], <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ReadFrom函数将io.Reader作为参数，ReadForm可以从任意的地方读取数据，只要来源实现了io.Reader接口。可以从标准输入、文件、字符串读取数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 标准输入</span><br><span class="line">data, err = ReadFrom(os.Stdin, 11)</span><br><span class="line">// 普通文件读取，其中file是os.File的实例</span><br><span class="line">data, err = ReadFrom(file, 9)</span><br><span class="line">// 从字符串读取</span><br><span class="line">data, err = ReadFrom(strings.NewReader(&quot;form string&quot;), 12)</span><br></pre></td></tr></table></figure>
<h2 id="writer-接口">Writer 接口</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Wirte(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>将len(p)个字节写入基本数据流中，返回从p中被写入的字节数n，以及任何遇到的引起的提前停止的错误。若Write返回的n&lt;len(p)，就必须返回一个非nil的错误。</p>
</blockquote>
<p>所有实现了Write方法的类型都实现了io.Writer接口。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Println</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span></span>(n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> Fprintln(os.Stdout, a...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2
id="实现了reader接口或者writer接口的类型">实现了Reader接口或者Writer接口的类型</h2>
<ul>
<li>os.File同时实现了io.Reader和io.Writer</li>
<li>strings.Reader实现了io.Reader</li>
<li>bufio.Reader/Writer 分别实现了 io.Reader 和 io.Writer</li>
<li>bytes.Buffer同时实现了io.Reader和io.Writer</li>
<li>bytes.Reader实现了io.Reader</li>
<li>compress/gzip.Reader/Writer 分别实现了io.Reader和io.Writer</li>
<li>crypto/cipher.StreamReader/StreamWriter 分别实现了 io.Reader 和
io.Writer</li>
<li>crypto/tls.Conn同时实现了io.Reader和io.Writer</li>
<li>encoding/csv.Reader/Writer 分别实现了 io.Reader 和 io.Writer</li>
<li>mine/multpart.Part实现了io.Reader</li>
<li>net/conn分别实现了io.Reader和io.Writer（Conn接口定义了Read/Write）</li>
</ul>
<h2 id="closer接口">Closer接口</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Closer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Close() <span class="type">error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该接口比较简单，只有一个close()方法，用于关闭数据流；</p>
<p>文件、归档、数据库链接、Socket等需要手动关闭的资源都实现了Closer接口；</p>
<p>实际编程中通常将Close方法的调用放在defer语句中。</p>
<h1 id="ioutil-方便的io操作函数集">ioutil 方便的IO操作函数集</h1>
<h2 id="nopcloser函数">NopCloser函数</h2>
<p>有时候我们需要传递一个io.ReadCloser实例，而我们现在有一个io.Reader实例。</p>
<p>使用NopCloser包装一个Reader，返回一个io.ReaderCloser，相应的Close方法什么也不做，只是返回nil；</p>
<p>比如在标准库net/http包中的NewRequest，接收一个io.Reader的body，实际上Request的Body的类型是io.ReadCloser，因此代码内部做了判断：</p>
<p>如果传入的io.Reader也实现了io.ReaderCloser接口，则转换，否则通过ioutil.NopCloser包装一下。</p>
<h2 id="readall函数">ReadAll函数</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadAll</span><span class="params">(r io.Reader)</span></span>([]<span class="type">byte</span>, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>
<p>一次性读取io.Reader中的所有数据</p>
<h2 id="readdir函数">ReadDir函数</h2>
<p>输出某目录下面的所有文件（包括子目录）</p>
<h2 id="readfile和writefile函数">ReadFile和WriteFile函数</h2>
<p>ReadFile读取整个文件的内容。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadFile</span><span class="params">(filename <span class="type">string</span>)</span></span>([]<span class="type">byte</span>, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>从指定的filename的文件中读取数据并返回文件的内容，成功的调用返回的err为nil而非EOF。因为本函数定义为读取整个文件不会将读取的EOF视为报告的错误</p>
</blockquote>
<p>WriteFile将data写入filename文件中，当文件不存在时会根据perm指定的权限创建一个，文件存在时会先清空内容，对于perm参数，可以指定为0666.</p>
<h2 id="tempdir和tempfile函数">TempDir和TempFile函数</h2>
<p>一般操作系统都会允许创建临时目录，比如linux下的/tmp目录。</p>
<p>通过TempDir可以创建一个临时目录，用于存放编译过程的临时目录</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">b.work, err = ioutil.TempDir(<span class="string">&quot;&quot;</span>, <span class="string">&quot;tmp&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>如果第一个参数为空，表面在系统默认的临时目录中创建临时目录，第二个参数指定临时目录的前缀，函数返回临时目录的路径；</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">f1, err := ioutil.TempFile(<span class="string">&quot;&quot;</span>, <span class="string">&quot;gofmt&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>创建者创建的临时变量和临时目录要负责删除这些临时目录和文件，比如删除临时文件：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f.<span class="built_in">close</span>()</span><br><span class="line">    os.Remove(f.Name())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes集群实践（十二）如何恢复etcd集群并重建k3s集群</title>
    <url>/p/restoring-etcd-cluster/</url>
    <content><![CDATA[<p>本文主要介绍在etcd集群崩溃时如何恢复。</p>
<p>关键词：<strong>k8s</strong></p>
<span id="more"></span>
<h2 id="背景">背景</h2>
<p>本人在实习公司主要负责管理k8s集群工作。使用的发行版是v1.24.3+k3s1。</p>
<p>为什么使用k3s呢，主要因为这个搭建比较方便，只需要一个二进制文件就可以起来一个集群。</p>
<p>在搭建集群的时候，考虑要保证集群高可用，因此使用了官网提供的<strong><a
href="https://docs.rancher.cn/docs/k3s/installation/ha-embedded/_index/">嵌入式DB的高可用
| Rancher文档</a></strong>方案。</p>
<p>网站上写了<strong>需要奇数的 server
节点，并且建议从三个节点开始</strong>。</p>
<p>因为我们现在管理的集群比较小，因此就<strong>使用了两个节点作为server节点</strong>。<strong>这为下文集群出现故障埋下了伏笔。</strong></p>
<p>⚠<strong>etcd 为了避免脑裂，采用了 raft
算法，规定只有过半数节点在线才能提供服务，即 N/2+1 节点在线才能选出
Leader。即如果有一个server挂了，那么集群就挂掉了！！</strong></p>
<p>因为某些原因，我将集群中的一个server踢出了集群，此时集群就不可用了。具体表现为：</p>
<p>在master节点上执行<code>kubectl get node</code>无法正常回显。</p>
<p>于是就有了本文。</p>
<h2 id="etcd集群恢复">etcd集群恢复</h2>
<p>当集群超过半数节点宕机，此时集群出于无法正常工作的状态，需要尽快恢复。</p>
<p>若机器宕机重启，IP保持不变，则证书无需重新生成；若IP更换，则还需要重新生成证书。</p>
<p>集群恢复还需要生成etcd的备份数据：使用<code>etcdctl snapshot save</code>命令备份或者从etcd数据目录复制<code>snap/db</code>文件。</p>
<h3 id="将备份数据恢复至集群">将备份数据恢复至集群</h3>
<p>首先明确k3s内置的etcd数据在<code>/var/lib/rancher/k3s/server/db/etcd</code>这个目录；</p>
<p>和etcd相关的证书在<code>/var/lib/rancher/k3s/server/tls/etcd</code>这个目录；</p>
<p>etcd配置文件在<code>/var/lib/rancher/k3s/server/db/etcd/config</code>这个文件。</p>
<p>以下操作都是在matser节点上执行的</p>
<ol type="1">
<li><p>将k3s相关服务先关闭</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl stop k3s</span><br></pre></td></tr></table></figure></li>
<li><p>安装一个etcd集群</p>
<p>这里为了简化操作，使用一个etcd服务端代替集群。</p>
<p>这里配置文件大部分还是使用原来k3s集群的配置文件，将数据的保存路径修改一下，安装完毕以后，将原有的etcd目录删除，然后启动etcd服务。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo etcd --config-file /newpath/etcd/config</span><br></pre></td></tr></table></figure></li>
<li><p>使用etcd客户端执行恢复etcd数据命令，这里的证书还是原来k3s集群使用的证书</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo etcdctl --endpoints=https://x.x.x.x:2379 --cert=client.crt --key=client.key --cacert=server-ca.crt --data-dir=/newpath/etcd/data snapshot restore snap/db</span><br></pre></td></tr></table></figure></li>
<li><p>修改k3s服务端相关配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ExecStart=/usr/local/bin/k3s \</span><br><span class="line">    server \</span><br><span class="line">        <span class="string">&#x27;--disable=metrics-server&#x27;</span> \</span><br><span class="line">        <span class="string">&#x27;--flannel-backend=host-gw&#x27;</span> \</span><br><span class="line">        <span class="string">&#x27;--write-kubeconfig-mode=644&#x27;</span> \</span><br><span class="line">        <span class="string">&#x27;--datastore-endpoint=https://192.168.31.29:2379&#x27;</span> \</span><br><span class="line">        <span class="string">&#x27;--datastore-cafile=/var/lib/rancher/k3s/server/tls/etcd/server-ca.crt&#x27;</span> \</span><br><span class="line">        <span class="string">&#x27;--datastore-certfile=/var/lib/rancher/k3s/server/tls/etcd/server-client.crt&#x27;</span> \</span><br><span class="line">        <span class="string">&#x27;--datastore-keyfile=/var/lib/rancher/k3s/server/tls/etcd/server-client.key&#x27;</span> \</span><br><span class="line">        <span class="string">&#x27;--bind-address=192.168.31.29&#x27;</span> \</span><br><span class="line">        <span class="string">&#x27;--kube-scheduler-arg=&#x27;</span>config=/usr/local/etc/scheduler-policy-config.yaml<span class="string">&#x27;&#x27;</span> \</span><br></pre></td></tr></table></figure></li>
<li><p>重启k3s服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart k3s</span><br></pre></td></tr></table></figure>
<p>此时k3s
服务应该可以正常启动了，但是还会有些问题，如原来删除的节点的一些信息还存在etcd集群中，但是k3s
apiserver中不存在相应的数据，此时只能执行强制删除操作。</p>
<p>在master节点上执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl delete xxx --force --grace-period=0</span><br></pre></td></tr></table></figure></li>
</ol>
<p>​ 其中xxx代之相应的资源</p>
<ol start="6" type="1">
<li><p>如果还出现异常的话，需要链接到etcd服务端，直接执行删除操作：</p>
<p>先查找所有的etcd对象</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">etcdctl.exe --cacert=certs\server-ca.crt --cert=certs\client.crt --key=certs\client.key --endpoints=https://192.168.31.29:2379 get <span class="string">&quot;&quot;</span>  --prefix --keys-only</span><br></pre></td></tr></table></figure>
<p>然后删除和master节点有关的信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">etcdctl.exe --cacert=certs\server-ca.crt --cert=certs\client.crt --key=certs\client.key --endpoints=https://192.168.31.29:2379 del /registry/csinodes/pve-master</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">etcdctl.exe --cacert=certs\server-ca.crt --cert=certs\client.crt --key=certs\client.key --endpoints=https://192.168.31.29:2379 del /registry/csinodes/pve-master</span><br></pre></td></tr></table></figure></li>
</ol>
<p>完。</p>
]]></content>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>运维开发（一）MySQL备份</title>
    <url>/p/MySQL-backup/</url>
    <content><![CDATA[<p>本文主要介绍MySQL备份。</p>
<p>关键词：<strong>MySQL</strong></p>
<span id="more"></span>
<h2 id="逻辑备份">逻辑备份</h2>
<p>数据库对象级备份，备份内容是表、索引、存储过程等数据库对象，常见工具为MySQL
mysqldump、Oracle exp/imp等。</p>
<p>逻辑备份备份速度较慢，恢复速度较慢，体积较大，需要数据库正常运行才可以执行逻辑备份。</p>
<p>优点是备份级别可控，即可以任意选择备份的数据库或者备份的表。</p>
<p>逻辑备份适用于任何存储引擎，一般使用<strong>mysqldump</strong>进行数据库的逻辑备份。</p>
<h3 id="常见参数">常见参数</h3>
<table>
<colgroup>
<col style="width: 22%" />
<col style="width: 4%" />
<col style="width: 66%" />
<col style="width: 6%" />
</colgroup>
<thead>
<tr class="header">
<th>参数名</th>
<th>缩写</th>
<th>含义</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>--user</td>
<td>-u</td>
<td>用户名</td>
<td></td>
</tr>
<tr class="even">
<td>--password</td>
<td>-p</td>
<td>密码</td>
<td></td>
</tr>
<tr class="odd">
<td>--host</td>
<td>-h</td>
<td>数据库地址</td>
<td></td>
</tr>
<tr class="even">
<td>--port</td>
<td>-P</td>
<td>数据库端口号</td>
<td></td>
</tr>
<tr class="odd">
<td>--databases</td>
<td>-B</td>
<td>指定要备份的数据库</td>
<td></td>
</tr>
<tr class="even">
<td>--all-databases</td>
<td>-A</td>
<td>备份mysql服务器上所有的数据库</td>
<td></td>
</tr>
<tr class="odd">
<td>--add-drop-database</td>
<td></td>
<td>每个数据库创建之前添加drop数据库语句</td>
<td>未开启</td>
</tr>
<tr class="even">
<td>--add-drop-table</td>
<td></td>
<td>创建表之前添加drop语句</td>
<td>开启</td>
</tr>
<tr class="odd">
<td>--event</td>
<td>-E</td>
<td>导出事件</td>
<td>未开启</td>
</tr>
<tr class="even">
<td>--routines</td>
<td>-R</td>
<td>导出存储过程以及自定义函数</td>
<td>未开启</td>
</tr>
<tr class="odd">
<td>--triggers</td>
<td></td>
<td>导出触发器</td>
<td>开启</td>
</tr>
<tr class="even">
<td>--extended-insert</td>
<td>-e</td>
<td>使用具有多个VALUES列的INSERT语法</td>
<td>开启</td>
</tr>
<tr class="odd">
<td>--ignore-table</td>
<td></td>
<td>指定不导出的表。需要忽略多个表时，需要重复多次</td>
<td></td>
</tr>
<tr class="even">
<td>--no-data</td>
<td>-d</td>
<td>不导出任何数据，只导出数据库表</td>
<td></td>
</tr>
<tr class="odd">
<td>--no-create-info</td>
<td>-t</td>
<td>只导出数据，不添加CREATE TABLE语句</td>
<td></td>
</tr>
<tr class="even">
<td>--force</td>
<td>-f</td>
<td>导出过程中忽略SQL错误</td>
<td></td>
</tr>
<tr class="odd">
<td>--tz-utc</td>
<td></td>
<td>导出顶部设置时区TIME_ZONE='+00:00'</td>
<td>开启</td>
</tr>
<tr class="even">
<td>--where</td>
<td>-w</td>
<td>只转储指定WHERE条件选择的记录</td>
<td></td>
</tr>
<tr class="odd">
<td>--set-gtid-purged</td>
<td></td>
<td>是否添加SET @<span class="citation"
data-cites="GLOBAL.GTID_PURGED输出">@GLOBAL.GTID_PURGED输出</span></td>
<td></td>
</tr>
<tr class="even">
<td>--single-transaction</td>
<td></td>
<td>通过在一个事务中导出所有表从而创建一个一致性的快照，适用于innodb引擎</td>
<td></td>
</tr>
<tr class="odd">
<td>--master-data</td>
<td></td>
<td>该选项将当前服务器的binlog的位置和文件名追加到输出文件中。如果为1，将会输出CHANGE
MASTER命令；如果为2，输出的CHANGE MASTER命令前添加注释信息</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="参考命令">参考命令</h3>
<p><strong>导出、导入所有的库</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -proot -hlocalhost -A &gt; all_mysql_data.sql</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -uroot -proot -hlocalhost &lt; all_muysql_data.sql</span><br></pre></td></tr></table></figure>
<p><strong>导出、导入指定库</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -proot -hlocalhost newcoder &gt; newcoder.sql</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -uroot -proot -hlocalhost &lt; newcoder.sql</span><br></pre></td></tr></table></figure>
<p><strong>导出、导入某几个库</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -proot -hlocalhost -B aaa bbb &gt; aaa_bbb.sql</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -uroot -proot -hlocalhost &lt; aaa_bbb.sql</span><br></pre></td></tr></table></figure>
<p><strong>导出、导入某个库的某些表数据</strong></p>
<p>比如操作aaa数据库的bbb表和ccc表</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可以在导出时加--add-locks参数，表示导出时锁定数据库表</span></span><br><span class="line">mysqldump -uroot -proot -hlocalhost aaa bbb ccc &gt; bbb_ccc.sql</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 要确保aaa库存在</span></span><br><span class="line">mysql -uroot -proot -hlocalhost aaa  &lt; bbb_ccc.sql</span><br></pre></td></tr></table></figure>
<p><strong>只导出数据库结构，不导出数据</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -proot -hlocalhost aaa -d &gt; bbb_ccc.sql</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 要确保aaa库存在</span></span><br><span class="line">mysql -uroot -proot -hlocalhost aaa &lt; bbb_ccc.sql</span><br></pre></td></tr></table></figure>
<h2 id="物理备份">物理备份</h2>
<p>数据库文件级备份，备份内容是操作系统上数据库文件，常见工具为MySQL
XtraBackup、Oracle RMAN等。</p>
<p>由存储数据库的内容和文件的副本组成，适用于大型数据库。</p>
<p>优点是备份速度快，恢复速度快，体积小。</p>
<p>如果数据库正在运行，需要先执行锁定数据库，防止在备份期间更改数据库的内容。</p>
<p>一般使用XtraBackup进行数据备份。</p>
<h3 id="xtrabackup优点">Xtrabackup优点</h3>
<ul>
<li><p>备份速度快，物理备份可靠</p></li>
<li><p>备份过程不会打断正在执行的事务（无需锁表）</p></li>
<li><p>能够基于压缩等功能节约磁盘空间和流量</p></li>
<li><p>自动备份校验</p></li>
<li><p>还原速度快</p></li>
<li><p>可以流传将备份传输到另外一台机器上</p></li>
<li><p>在不增加服务器负载的情况备份数据</p></li>
</ul>
<h3 id="xtrabackup常见参数">Xtrabackup常见参数</h3>
<table>
<colgroup>
<col style="width: 22%" />
<col style="width: 72%" />
<col style="width: 4%" />
</colgroup>
<thead>
<tr class="header">
<th>参数</th>
<th>含义</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>--backup</td>
<td>备份到指定目录</td>
<td></td>
</tr>
<tr class="even">
<td>--target-dir</td>
<td>指定目录</td>
<td></td>
</tr>
<tr class="odd">
<td>--stream</td>
<td>流式传输指定备份，参数xbstream</td>
<td></td>
</tr>
<tr class="even">
<td>--compress</td>
<td>是否启用压缩备份</td>
<td></td>
</tr>
<tr class="odd">
<td>--compress-threads</td>
<td>指定压缩线程</td>
<td></td>
</tr>
<tr class="even">
<td>--databases</td>
<td>指定要备份的数据库</td>
<td></td>
</tr>
<tr class="odd">
<td>--databases-exclude</td>
<td>排除要备份的数据库</td>
<td></td>
</tr>
<tr class="even">
<td>--user</td>
<td>用户名</td>
<td></td>
</tr>
<tr class="odd">
<td>--password</td>
<td>密码</td>
<td></td>
</tr>
<tr class="even">
<td>--host</td>
<td>数据库IP</td>
<td></td>
</tr>
<tr class="odd">
<td>--rsync</td>
<td>使用rsync工具优化本地传输，当指定这个选项，innobackupex使用rsync拷贝非Innodb文件而替换cp，当有很多DB和表的时候会快很多，不能--stream一起使用。</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="参考命令-1">参考命令</h3>
<p><strong>流式备份并压缩、解压</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xtrabackup --backup --user=root --password=root --host=192.168.31.75 --stream=xbstream | gzip  &gt; `<span class="built_in">date</span> +%Y%m%d`.gz</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gzip -f -d &lt; `<span class="built_in">date</span> +%Y%m%d`.gz  | xbstream -x -C mysql</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>SRE</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes集群实践（十一）编写一个自定义资源CRD</title>
    <url>/p/create-crd-in-kubernetes/</url>
    <content><![CDATA[<p>本文主要介绍如何在Kubernetes编写自定义资源CRD。</p>
<p>关键词：<strong>k8s</strong></p>
<span id="more"></span>
<h2 id="前言">前言</h2>
<p>Kubernetes的最大亮点之一必定是它的声明式API设计，所谓的声明式就是告诉Kubernetes你要什么，而不是告诉它怎么做命令。我们日常使用Kubernetes做编排工作的时候，经常会接触Deployment、Service、Pod等资源对象，我们可以很灵活地创建其定义配置，然后执行kubectl
apply命令，Kubernetes总能为我们创建相关资源对象并完成资源的注册，进而执行资源所负责的功能。</p>
<p>CRD，称之为自定义资源定义，本质上，它的表现形式是一段声明，用于定义用户定义的资源对象罢了。单单通过它还不能产生任何收益，因为开发者还要针对CRD定义提供关联的CRD对象CRD控制器（CRD
Controller）。CRD控制器通常可以通过Golang进行开发，只需要遵循Kubernetes的控制器开发规范，并基于client-go进行调用，并实现Informer、ResourceEventHandler、Workqueue等组件逻辑即可。听起来感觉很复杂的样子，不过其实真正开发的时候，并不困难，因为大部分繁琐的代码逻辑都能通过Kubernetes的code
generator代码生成出来。关于如何进行CRD控制器的开发，下面我们会通过一个例子慢慢地深入，希望通过实践来理解CRD的原理。</p>
<h2 id="声明式api">声明式API</h2>
<h3 id="命令式api">命令式API</h3>
<p>首先，声明式API是相对于命令式API而言的。</p>
<p>假设我们想创建一个deployment，可以创建一个下面的yaml文件：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>
<p>然后在master执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create -f nginx.yaml</span><br></pre></td></tr></table></figure>
<p>然后这两个Pod就跑起来了。</p>
<p>如果想修改上的资源清单，需要先修改资源文件，然后再执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl replace -f nginx.yaml</span><br></pre></td></tr></table></figure>
<p>以上基于yaml文件操作的方式，被称作命令式API。同样属于命令式API的还有Docker
Swarm的创建方式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker service create --name nginx --replicas 2  nginx</span><br></pre></td></tr></table></figure>
<h3 id="声明式api-1">声明式API</h3>
<p><strong>kubectl apply</strong> 的操作属于声明式API。</p>
<p>kubectl
replace的操作，可以看作是使用新的YAML文件的API对象，<strong>替换原有的API对象</strong>；kubectl
set image和 kubelctl edit也是对原有对象的修改，这些都属于命令式API。</p>
<p>kube-apiserver在响应命令式请求时，只能一次处理一个写请求，否则可能会出现冲突。</p>
<p>而对于apply的声明式请求，可以一次处理多个写操作，并且具备merge能力。</p>
<p>所谓声明式API，<strong>就是告诉kubernetes你要什么，而不是告诉他怎么做命令</strong>。在日常做容器编排时，经常会操作Deployment、Service、Pod等资源对象，我们可以很灵活的创建其自定义配置，然后执行kubectl
apply
命令，kubernetes可以创建相关资源对象并完成资源的注册，进而执行资源所负责的功能。</p>
<p>有了自定义API对象，开发者就不需要逐一进行Deployment、Service
、ConfigMap等步骤，而是创建一些可以表述整个应用程序或者软件服务的对象。除此之外，我们还可以在创建高阶对象的基础上创建底层对象。例如：我们想要创建一个backup资源，在定义yaml的同时，可以希望通过spec的定义进行日常的备份操作声明，当提交给k8s集群时，相关的Deployment、Service资源会被自动创建，很大程度上让业务扩展性加大。</p>
<h3 id="crd">CRD</h3>
<p>CRD，称之为自定义资源定义，本质上，它的表现形式是一段声明，用于定义用户定义的资源对象罢了。单单通过它还不能产生任何收益，因为开发者还要针对CRD定义提供关联的CRD对象CRD控制器（CRD
Controller）。CRD控制器通常可以通过Golang进行开发，只需要遵循Kubernetes的控制器开发规范，并基于client-go进行调用，并实现Informer、ResourceEventHandler、Workqueue等组件逻辑即可。听起来感觉很复杂的样子，不过其实真正开发的时候，并不困难，因为大部分繁琐的代码逻辑都能通过Kubernetes的code
generator代码生成出来。关于如何进行CRD控制器的开发，下面我们会通过一个例子慢慢地深入，希望通过实践来理解CRD的原理。</p>
<h2 id="api">API</h2>
<p>整个kubernetes里所有API对象都可以用下面的树形结构表示出来：</p>
<p><img data-src="NeatReader-1663224393771.png" /></p>
<p>可以看出，API对象的组织方式，是层层递进的。</p>
<p>如果现在想要创建一个CronJob对象，那么YAML文件的开始部分需要这样写：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiversion:</span> <span class="string">batch/v2alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">CronJob</span></span><br></pre></td></tr></table></figure>
<p>对于上文，Crontab是这个API对象的资源类型，batch是他的组，v2alpha1是版本；</p>
<p>当提交了这个yaml文件一行，kubernetes就会把这个YAML文件描述内容，转换成一个CronJob对象</p>
<p>apiserver会遵循以下的流程：</p>
<ol type="1">
<li><p>匹配API对象的组。</p>
<p>通常核心对象如Pod、Node不需要group，直接在/api这个层级下进行匹配；</p>
<p>而对于CronJob等非核心API对象来说，Kubernetes必须在
/apis这个层级下找到对应的Group，根据batch，找到/apis/batch。</p>
<p>API是根据对象功能为依据的。如Job和CronJob就属于batch这个Group。</p></li>
<li><p>匹配API对象的版本号</p>
<p>对于CronJob这个API对象来说，Kubernetes在batch这个Group下，匹配的版本号就是v2alpha1</p>
<p>K8s中同一种API对象可以由多个版本，这正是K8s进行API版本化管理的手段</p></li>
</ol>
]]></content>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes集群实践（十三）使用cfssl生成集群内部使用的证书</title>
    <url>/p/use-cfssl-create-certs/</url>
    <content><![CDATA[<p>本文主要介绍如何在Kubernetes中使用cfssl生成集群内部使用的证书。</p>
<p>关键词：<strong>k8s，证书</strong></p>
<span id="more"></span>
<h3 id="准备工作">准备工作</h3>
<p>项目地址：https://github.com/cloudflare/cfssl/</p>
<p>下载项目：<code>cfssl、cfssljson</code></p>
<h3 id="生成证书">生成证书</h3>
<p>通过证书请求文件，CSR参数生成CA证书和私钥，此步骤仅需进行一次，后续可以直接使用此步骤生成的文件，签发证书。</p>
<p><strong>生成csr默认模板</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cfssl print-defaults csr &gt; ca-csr.json</span><br></pre></td></tr></table></figure>
<p><strong>修改配置文件模板的内容</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;CN&quot;</span><span class="punctuation">:</span> <span class="string">&quot;kubernetes&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;algo&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ecdsa&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">256</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;names&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;C&quot;</span><span class="punctuation">:</span> <span class="string">&quot;CN&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;L&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HangZhou&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;O&quot;</span><span class="punctuation">:</span> <span class="string">&quot;k8s&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;OU&quot;</span><span class="punctuation">:</span> <span class="string">&quot;System&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li><p>CN：Common Name，kube-apiserver
从证书中提取该字段作为请求的用户名 (User
Name)；浏览器使用该字段验证网站是否合法</p>
<p>​ names的O表示Organization ，kube-apiserver
从证书中提取该字段作为请求用户所属的组 (Group)</p></li>
<li><p>C：Country， 国家</p></li>
<li><p>L：Locality，地区，城市</p></li>
<li><p>O：Organization Name，组织名称，公司名称</p></li>
<li><p>OU：Organization Unit Name，组织单位名称，公司部门</p></li>
<li><p>ST： State，州，省</p></li>
</ul>
<p><strong>生成CA证书和私钥</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cfssl gencert -initca ca-csr.json | cfssljson -bare ca </span><br></pre></td></tr></table></figure>
<p><img data-src="image-20231018194227550.png" /></p>
<h3
id="通过ca-config.json配置证书生成策略">通过ca-config.json配置证书生成策略</h3>
<p>容器的相关证书类型：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">client certificate 用于服务端认证客户端, 例如etcdctl/etcd-proxy/fleetctl/docker客户端</span><br><span class="line">server certificate 服务端使用，客户端用此验证服务端身份，如dockerd/kube-apiserver</span><br><span class="line">peer certificate 双向证书，用于集群中etcd成员间进行通信</span><br></pre></td></tr></table></figure>
<p>生成签发证书的配置文件模板</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cfssl print-defaults config &gt; ca-config.json</span><br></pre></td></tr></table></figure>
<p>修改配置文件，分别配置针对三种不同证书类型的配置文件，有效期为43800h为5年</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;signing&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;default&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;expiry&quot;</span>: <span class="string">&quot;43800h&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;profiles&quot;</span>: &#123;    <span class="comment"># ca-config.jso: 可以定义多个profiles, 分别指定不同的过期时间， 使用场景等参数，下面</span></span><br><span class="line">            <span class="string">&quot;server&quot;</span>: &#123;  <span class="comment"># 这个字段名称任意，把server字段改成 aaa, bbb, ccc都可以，但是网上没有一篇博客有说这个字段任意</span></span><br><span class="line">                <span class="string">&quot;expiry&quot;</span>: <span class="string">&quot;43800h&quot;</span>,</span><br><span class="line">                <span class="string">&quot;usages&quot;</span>: [</span><br><span class="line">                    <span class="string">&quot;signing&quot;</span>,  <span class="comment"># signing : 表示该证书可用于签名其它证书，生成的ca.pem证书中，CA=TRUE</span></span><br><span class="line">                    <span class="string">&quot;key encipherment&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;server auth&quot;</span> <span class="comment"># server auth : 表示client可以使用该CA对server提供的证书进行验证</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;client&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;expiry&quot;</span>: <span class="string">&quot;43800h&quot;</span>,</span><br><span class="line">                <span class="string">&quot;usages&quot;</span>: [</span><br><span class="line">                    <span class="string">&quot;signing&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;key encipherment&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;client auth&quot;</span>  <span class="comment"># client auth : 表示server 可以用该CA对client提供的证书进行验证</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;peer&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;expiry&quot;</span>: <span class="string">&quot;43800h&quot;</span>,</span><br><span class="line">                <span class="string">&quot;usages&quot;</span>: [</span><br><span class="line">                    <span class="string">&quot;signing&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;key encipherment&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;server auth&quot;</span>,   <span class="comment"># server auth : 表示client可以使用该CA对server提供的证书进行验证</span></span><br><span class="line">                    <span class="string">&quot;client auth&quot;</span>    <span class="comment"># client auth : 表示server 可以用该CA对client提供的证书进行验证</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="证书生成">证书生成</h3>
<p>CFSSL提供了两个命令：gencert和sign。gencert将自动处理整个证书生成过程。该过程需要两个文件，一个告诉CFSSL本地客户端CA的位置以及如何验证请求，即config文件，另一个为CSR配置信息，用于填充CSR
即csr文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cfssl print-defaults csr &gt; kubernetes-csr.json</span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;CN&quot;</span><span class="punctuation">:</span> <span class="string">&quot;kubernetes&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;hosts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;127.0.0.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;10.116.137.196&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;10.116.82.28&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;10.116.36.57&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;10.254.0.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;kubernetes&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;kubernetes.default&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;kubernetes.default.svc&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;kubernetes.default.svc.cluster&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;kubernetes.default.svc.cluster.local&quot;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;algo&quot;</span><span class="punctuation">:</span><span class="string">&quot;rsa&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span><span class="number">2048</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;names&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;C&quot;</span><span class="punctuation">:</span> <span class="string">&quot;CN&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;L&quot;</span><span class="punctuation">:</span> <span class="string">&quot;BeiJing&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;ST&quot;</span><span class="punctuation">:</span> <span class="string">&quot;BeiJing&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;O&quot;</span><span class="punctuation">:</span> <span class="string">&quot;k8s&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;OU&quot;</span><span class="punctuation">:</span> <span class="string">&quot;System&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如果 hosts 字段不为空则需要指定授权使用该证书的 IP
或域名列表，由于该证书后续被 etcd 集群和 kubernetes master
集群使用，所以上面分别指定了etcd 集群、kubernetes master 集群的主机 IP和
kubernetes 服务的服务 IP（一般是 kube-apiserver 指定的
service-cluster-ip-range 网段的第一个IP，如10.254.0.1。</li>
<li>hosts
中的内容可以为空，即使按照上面的配置，向集群中增加新节点后也不需要重新生成证书。
执行下面命令, 生成 kubernetes.csr, kubernetes-key.pem, kubernetes.pem
文件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes kubernetes-csr.json | cfssljson -bare kubernetes</span><br></pre></td></tr></table></figure>
<p>注：命令中的-profile参数要和ca-config.json中的profiles字段需要签名的证书一致</p>
<p><img data-src="image-20231019104850283.png" /></p>
]]></content>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes集群实践（十）在Kubernetes部署MinIO对象存储服务器</title>
    <url>/p/Install-MinIO-on-k8s/</url>
    <content><![CDATA[<p>本文主要介绍如何安装和使用云原生对象存储服务器MinIO。</p>
<p>关键词：<strong>k8s</strong></p>
<span id="more"></span>
<h2 id="前言">前言</h2>
<p>MinIO 是在 GNU Affero 通用公共许可证 v3.0
下发布的高性能对象存储。它与 Amazon S3 云存储服务 API 兼容。使用 MinIO
为机器学习、分析和应用程序数据工作负载构建高性能基础架构。</p>
<p>本文主要介绍如何使用<a
href="https://github.com/minio/operator/blob/master/README.md">MinIO
Kubernetes Operator</a>部署和安装MinIO。</p>
<h2 id="准备工作">准备工作</h2>
<p>正常运行的K8s集群，这里使用三个master节点，两个worker节点进行演示；</p>
<p><img data-src="2022-08-12-14-15-48-image.png" /></p>
<p>在K8s上部署MinIO一般有两种方式，一种是通过Helm进行自动安装，还有一种是通过<strong>MinIO
Kubernetes
Operator</strong>部署安装。处于学习的角度考虑，这里采用Operator进行手动安装</p>
<h2 id="部署minio-operator">部署MinIO Operator</h2>
<h3 id="安装kubectl-minio插件">安装kubectl-minio插件</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://github.com/minio/operator/releases/latest/download/kubectl-minio_linux_amd64.zip</span><br><span class="line">sudo unzip kubectl-minio_linux_amd64.zip -d /usr/local/bin/</span><br></pre></td></tr></table></figure>
<p>检查是否正常安装</p>
<p>如果显示版本号则说明插件安装成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wf09@amd-server ➜  ~ kubectl minio version</span><br><span class="line">v4.4.28</span><br></pre></td></tr></table></figure>
<h3 id="初始化minio-operator">初始化MinIO Operator</h3>
<h4 id="部署">部署</h4>
<p><code>--image</code>、<code>--console-image</code>分别指定私有仓库的镜像，这样可以节约部署的时间</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl minio init \</span><br><span class="line">--image=hub.deepsoft-tech.com/minio/operator \</span><br><span class="line">--console-image=hub.deepsoft-tech.com/minio/console</span><br></pre></td></tr></table></figure>
<p>稍候片刻，可以看到下面的回显，说明部署完毕</p>
<p><img data-src="2022-08-12-15-04-50-image.png" /></p>
<h4 id="查看部署的资源">查看部署的资源</h4>
<p>可以查看minio-operator命名空间下的资源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get all -n minio-operator</span><br></pre></td></tr></table></figure>
<p><img data-src="2022-08-12-15-06-13-image.png" /></p>
<p>当所有Pod都为Running时，表示服务已经Ready了</p>
<h4 id="登录operator控制台">登录operator控制台</h4>
<p>可以通过kube-proxy访问控制台</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl minio proxy </span><br></pre></td></tr></table></figure>
<p><img data-src="2022-08-12-15-41-52-image.png" /></p>
<p>记录JWT，并输入打开的浏览器页面</p>
<p><img data-src="2022-08-12-15-43-33-image.png" /></p>
<p>输入JWT，跳转到下一步</p>
<p><img data-src="2022-08-12-15-46-50-image.png" /></p>
<h2 id="部署多租户minio-tenant集群">部署多租户MinIO tenant集群</h2>
<h3 id="创建storangeclass">创建StorangeClass</h3>
<p>可以通过外部StorangeClass+PVC可以实现自动生成PV。</p>
<h4 id="k3s-local-path-provisioner-storangeclass">K3s
local-path-provisioner StorangeClass</h4>
<p>K3s Local PV 可以在本机通过PV控制器与Scheduler的结合，会对local
PV做针对性的逻辑处理，从而，让Pod在多次调度时，能够调度到同一个Node上。</p>
<p>安装方式也很简单，默认在K3s集群中就自动安装完毕了。</p>
<p>若之前禁用了此安装，只需删除<code>--disable=local-storage</code>即可。</p>
<h4 id="minio-directpv-storangeclass">MinIO directpv StorangeClass</h4>
<p>DirectPV是用于直连存储的CSI驱动程序。从更简单的意义上讲，它是一个分布式持久卷管理器，而不是像SAN或NAS这样的存储系统。跨服务器发现、格式化、装载、调度和监视驱动器非常有用。由于<strong>Kubernetes
hostPath和Local
PV</strong>是静态配置的，并且功能有限，因此创建DirectPV就是为了解决这一限制。</p>
<p>以下是安装步骤</p>
<ol type="1">
<li><p>安装kubectl directpv插件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://github.com/minio/directpv/releases/latest/download/kubectl-directpv_linux_amd64.zip</span><br><span class="line">sudo unzip kubectl-directpv_linux_amd64.zip -d /usr/local/bin/</span><br></pre></td></tr></table></figure></li>
<li><p>检查是否安装成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl directpv --version</span><br></pre></td></tr></table></figure></li>
</ol>
<p>    如显示版本号说明安装成功了</p>
<ol start="3" type="1">
<li><p>初始化 directpv</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl directpv init </span><br></pre></td></tr></table></figure></li>
<li><p>检查是否初始化成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get all -n direct-csi-min-io</span><br></pre></td></tr></table></figure>
<p>查看上述命令的回显，如果Pod
Status全部显示Running说明初始化成功</p></li>
<li><p>格式化磁盘</p>
<p>以下命令可以格式化所有磁盘，当所有磁盘格式化完毕以后，就可以分配PV了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl directpv drives format -a</span><br></pre></td></tr></table></figure>
<p>如果想释放某个节点，即不让该节点的设备分配PV，可以执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl directpv drives release --nodes amd-server</span><br></pre></td></tr></table></figure></li>
<li><p>查看节点磁盘状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl directpv drives <span class="built_in">ls</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>    显示为Ready的节点，可以分配PV</p>
<p>    <img title="" data-src="2022-08-12-18-24-17-image.png" alt="" data-align="inline" width="611"></p>
<h3 id="创建-minio-tenant集群">创建 MinIO tenant集群</h3>
<h4 id="创建命名空间">创建命名空间</h4>
<p>需要将minio租户放在一个特定的命名空间中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create ns minio</span><br></pre></td></tr></table></figure>
<h4 id="创建-minio-tenant集群-1">创建 MinIO tenant集群</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl minio tenant create minio  \</span><br><span class="line">  --servers 4 \</span><br><span class="line">  --volumes 8 \</span><br><span class="line">  --capacity 200Gi \</span><br><span class="line">  --storage-class direct-csi-min-io \</span><br><span class="line">  --namespace minio \</span><br><span class="line">  --disable-tls</span><br></pre></td></tr></table></figure>
<table>
<colgroup>
<col style="width: 46%" />
<col style="width: 53%" />
</colgroup>
<thead>
<tr class="header">
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a
href="https://docs.min.io/minio/k8s/reference/minio-kubectl-plugin.html#kubectl-minio-tenant-create-servers"><code>--servers</code></a></td>
<td><code>minio</code>要跨 Kubernetes 集群部署的服务器数量。</td>
</tr>
<tr class="even">
<td><a
href="https://docs.min.io/minio/k8s/reference/minio-kubectl-plugin.html#kubectl-minio-tenant-create-volumes"><code>--volumes</code></a></td>
<td>集群中的卷数。通过将确定每个服务器的卷数通过。<a
href="https://docs.min.io/minio/k8s/reference/minio-kubectl-plugin.html#command-kubectl-minio"><code>kubectl minio</code></a><code>volumes``servers</code></td>
</tr>
<tr class="odd">
<td><a
href="https://docs.min.io/minio/k8s/reference/minio-kubectl-plugin.html#kubectl-minio-tenant-create-capacity"><code>--capacity</code></a></td>
<td>集群的总容量。确定每个体积的通过划分容量通过。<a
href="https://docs.min.io/minio/k8s/reference/minio-kubectl-plugin.html#command-kubectl-minio"><code>kubectl minio</code></a><code>capacity``volumes</code></td>
</tr>
<tr class="even">
<td><a
href="https://docs.min.io/minio/k8s/reference/minio-kubectl-plugin.html#kubectl-minio-tenant-create-storage-class"><code>--storage-class</code></a></td>
<td><code>StorageClass</code>创建每个 PVC 时要使用的 Kubernetes
。此示例使用 MinIO <a
href="https://github.com/minio/direct-csi">DirectCSI</a> 存储类。</td>
</tr>
<tr class="odd">
<td><a
href="https://docs.min.io/minio/k8s/reference/minio-kubectl-plugin.html#kubectl-minio-tenant-create-namespace"><code>--namespace</code></a></td>
<td>用于部署 MinIO 租户的 Kubernetes 命名空间。</td>
</tr>
</tbody>
</table>
<p>注释：我们的集群有4个节点，<code>--servers=4</code>；总共4个卷，即每个节点上各有一个卷<code>--volumes 4</code>；总共容量是100G（由于奇偶校验等原因，最大可以存50G的数据）<code>-capacity 100Gi</code>；</p>
<p><img data-src="2022-08-15-14-00-42-image.png" /></p>
<h3 id="将集群暴露至外部">将集群暴露至外部</h3>
<p>将对应的service连接至ingress即可。</p>
<h4 id="s3-api">s3 API</h4>
<p>s3 API对应的是 minio Service</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">minio</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">minio</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">s3.deepsoft-tech.com</span></span><br><span class="line">      <span class="attr">http:</span></span><br><span class="line">        <span class="attr">paths:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">            <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">            <span class="attr">backend:</span></span><br><span class="line">              <span class="attr">service:</span></span><br><span class="line">                <span class="attr">name:</span> <span class="string">minio</span></span><br><span class="line">                <span class="attr">port:</span></span><br><span class="line">                  <span class="attr">number:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>
<h4 id="minio-控制台">MinIO 控制台</h4>
<p>控制台对应的是 minio-console Service</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">minio-console</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">minio</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">minio-console.deepsoft-tech.com</span></span><br><span class="line">      <span class="attr">http:</span></span><br><span class="line">        <span class="attr">paths:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">            <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">            <span class="attr">backend:</span></span><br><span class="line">              <span class="attr">service:</span></span><br><span class="line">                <span class="attr">name:</span> <span class="string">minio-console</span></span><br><span class="line">                <span class="attr">port:</span></span><br><span class="line">                  <span class="attr">number:</span> <span class="number">9090</span></span><br></pre></td></tr></table></figure>
<h4 id="检查">检查</h4>
<p>登录控制台，查看s3存储桶信息</p>
<p><img data-src="2022-08-15-14-07-09-image.png" /></p>
<h2 id="使用-minio-client-连接-minio-集群">使用 MinIO Client 连接 minio
集群</h2>
<h3 id="binary-download-gnulinux">Binary Download (GNU/Linux)</h3>
<table>
<colgroup>
<col style="width: 12%" />
<col style="width: 16%" />
<col style="width: 71%" />
</colgroup>
<thead>
<tr class="header">
<th>Platform</th>
<th>Architecture</th>
<th>URL</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>GNU/Linux</td>
<td>64-bit Intel</td>
<td>https://dl.min.io/client/mc/release/linux-amd64/mc</td>
</tr>
<tr class="even">
<td></td>
<td>64-bit PPC</td>
<td>https://dl.min.io/client/mc/release/linux-ppc64le/mc</td>
</tr>
</tbody>
</table>
<h3 id="docker">Docker</h3>
<h4 id="docker-stable">Docker Stable</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull minio/mc </span><br><span class="line">docker run minio/mc <span class="built_in">ls</span> play</span><br></pre></td></tr></table></figure>
<h4 id="docker-edge">Docker Edge</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull minio/mc:edge</span><br><span class="line">docker run minio/mc:edge <span class="built_in">ls</span> play</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong> Above examples run <code>mc</code> against
MinIO <a
href="https://docs.min.io/docs/minio-client-complete-guide.html#test-your-setup"><em>play</em> environment</a> by
default. To run <code>mc</code> against other S3 compatible servers,
start the container this way:</p>
<p>Copy<code>docker run -it --entrypoint=/bin/sh minio/mc</code></p>
<p>then use the <a
href="https://docs.min.io/docs/minio-client-complete-guide.html#3-add-a-cloud-storage-service"><code>mc alias</code> command</a>.</p>
<h3 id="添加集群">添加集群</h3>
<p>账户名：root，密码：rootroot</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mc config host add k8s http://s3.deepsoft-tech.com root rootroot --api s3v4</span><br></pre></td></tr></table></figure>
<h4 id="查看集群的桶">查看集群的桶</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mc <span class="built_in">ls</span> k8s</span><br></pre></td></tr></table></figure>
<p><img data-src="2022-08-15-14-46-20-image.png" /></p>
<h4 id="备份文件到指定集群">备份文件到指定集群</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mc mirror -a textbook/ k8s/textbook</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>-a</code> ：属性同步备份</p></li>
<li><p><code>-w</code>：阻塞备份，<code>--watch</code></p></li>
</ul>
]]></content>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes集群实践（九）使用StatefulSet 搭建高可用的MySQL集群</title>
    <url>/p/install-mysql-ha-on-k8s/</url>
    <content><![CDATA[<p>本文主要介绍如何使用StatefulSet搭建高可用的MySQL集群。</p>
<p>关键词：<strong>k8s</strong></p>
<span id="more"></span>
<h2 id="前言">前言</h2>
<p>为什么要用K8s搭建MySQL集群？</p>
<ul>
<li>在业务全面上云的背景下，为了要使用现有的设备快速搭建高可用的MySQL集群，K8s无非是一种比较方便的方案。</li>
</ul>
<h2 id="statefulset">StatefulSet</h2>
<p>StatefulSet被用来管理<strong>有状态应用</strong>的工作负载API对象。MySQL服务就是一个典型的有状态应用。</p>
<p>和Deployment类似，StatefulSet也是用来管理基于相同容器Spec的一组Pod。但和Deployment不同的是，StatefulSet为他们的Pod维护了一个<strong>有粘性的ID</strong>。这些Pod是基于相同的Spec来创建的，但是不能替换：无论怎么调度，他们Pod都有一个永久不变的ID。</p>
<p>如果使用PV卷为Pod提供持久存储，可以使用StatefulSet作为解决方案的一部分，尽管StatefulSet中的单个Pod仍可能出现故障，但持久的
Pod 标识符使得将现有卷与替换已失败 Pod 的新 Pod 相匹配变得更加容易。</p>
<p>StatefulSet主要用于以下状态的应用更新：</p>
<ul>
<li>需要稳定的、唯一的网络标识符；</li>
<li>需要稳定的、持久的存储；</li>
<li>需要有序的、优雅的部署和扩缩；</li>
<li>需要有序的、自动的滚动更新。</li>
</ul>
<p>稳定意味着Pod的调度或者重新调度的整个过程是持久性的；</p>
<p>如果应用程序不需要任何稳定的标识符或者有序的部署、删除或扩缩，则应该使用无状态的副本控制提供的工作负载来部署应用程序，如Deployment或者ReplicaSet；</p>
<ul>
<li>StatefulSet的应用都是一个一个<strong>依次创建</strong>的；</li>
</ul>
<h3 id="限制">限制</h3>
<ul>
<li><p>Pod存储必须要由PV驱动基于StrongeClass来提供，或者由管理员预先提供；</p></li>
<li><p>删除或者扩缩StatefulSet<strong>不会删除它关联的PVC</strong>；</p></li>
<li><p>StatefulSet需要<strong>无头服务（headless
service）</strong>来负责创建Pod的网络标识，管理员需要创建此服务；</p></li>
<li><p>当删除一个StatefulSet时，StatefulSet不提供任何终止Pod的保证。为了实现StatefulSet有序终止，可以在删除之前将StatefulSet缩容至0；</p></li>
<li><p>默认Pod管理策略是滚动更新，出现异常时可能<strong>需要人工干预</strong>才能恢复</p></li>
</ul>
<h3 id="组件">组件</h3>
<p>下面的示例演示了StatefulSet的组件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="string">None</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StatefulSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span> <span class="comment"># 必须匹配 .spec.template.metadata.labels</span></span><br><span class="line">  <span class="attr">serviceName:</span> <span class="string">&quot;nginx&quot;</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span> <span class="comment"># 默认值是 1</span></span><br><span class="line">  <span class="attr">minReadySeconds:</span> <span class="number">10</span> <span class="comment"># 默认值是 0</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span> <span class="comment"># 必须匹配 .spec.selector.matchLabels</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">terminationGracePeriodSeconds:</span> <span class="number">10</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">k8s.gcr.io/nginx-slim:0.8</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">www</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/usr/share/nginx/html</span></span><br><span class="line">  <span class="attr">volumeClaimTemplates:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">www</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">accessModes:</span> [ <span class="string">&quot;ReadWriteOnce&quot;</span> ]</span><br><span class="line">      <span class="attr">storageClassName:</span> <span class="string">&quot;my-storage-class&quot;</span></span><br><span class="line">      <span class="attr">resources:</span></span><br><span class="line">        <span class="attr">requests:</span></span><br><span class="line">          <span class="attr">storage:</span> <span class="string">1Gi</span></span><br></pre></td></tr></table></figure>
<h2 id="mysql-ha搭建">MySQL HA搭建</h2>
<p>普通MySQL集群的搭建可以参考：https://www.modb.pro/db/29214</p>
<p>主要就是以下几个步骤：</p>
<ol type="1">
<li>安装数据库</li>
<li>主库开启binlog</li>
<li>授权</li>
<li>登陆主库查看此时日子状态</li>
<li>导出主库当前数据</li>
<li>从库和指定serverid</li>
<li>从库写入主库数据</li>
<li>指定开始同步位置</li>
</ol>
<p>K8s集群上的MySQL集群搭建略有不同，主要通过StatefulSet+ConfigMap+initContainer的模式和xtrabackup+ncat软件来实现主从复制；</p>
<ol type="1">
<li>首先创建主库和从库的my.cnf文件，存入ConfigMap。这样可以持久化配置文件；</li>
<li>然后创建InitContainer。InitContainer容器是首先创建的容器，且该容器成功推出是Pod
Ready的比较条件；
<ul>
<li>InitContainer：init-mysql
主要任务是根据hostname，选择拷贝主库的配置文件还是从库的文件到Volume中，这样就区分了Master和Slave；</li>
<li>InitContainer：clone-mysql
任务是为<strong>级联复制</strong>做准备。如果存在数据，跳过克隆；跳过主库的克隆；从上一个Ready的Pod克隆数据来；准备备份为后面的节点服务；</li>
</ul></li>
<li>创建Container。这里的Container就是正常业务的MySQL容器了；</li>
<li>创建<strong>Sicar</strong>
Container：backup-sql，主要任务是：调整当前节点的主从设置；准备为下一个节点提供复制的文件</li>
</ol>
<h3 id="资源清单文件">资源清单文件</h3>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mysql-ha</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/name:</span> <span class="string">mysql</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">init.sql:</span> <span class="string">|</span></span><br><span class="line"><span class="string">    use mysql;</span></span><br><span class="line"><span class="string">    /* update user set host = &#x27;%&#x27; where user =&#x27;root&#x27;;</span></span><br><span class="line"><span class="string">    flush privileges; */</span></span><br><span class="line"><span class="string">    grant all privileges on *.* to &#x27;root&#x27;@&#x27;%&#x27;;</span></span><br><span class="line"><span class="string">    flush privileges;</span></span><br><span class="line"><span class="string"></span>  <span class="attr">primary.cnf:</span> <span class="string">|</span></span><br><span class="line"><span class="string">    # 仅在主服务器上应用此配置</span></span><br><span class="line"><span class="string">    [mysqld]</span></span><br><span class="line"><span class="string">    lower_case_table_names=1</span></span><br><span class="line"><span class="string">    relay-log=mysql-relay</span></span><br><span class="line"><span class="string">    log-bin=mysql-bin</span></span><br><span class="line"><span class="string">    gtid_mode=on</span></span><br><span class="line"><span class="string">    enforce_gtid_consistency</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">    <span class="string">max_connections=1000</span></span><br><span class="line">    <span class="string">character_set_server=utf8mb4</span></span><br><span class="line">    <span class="string">collation_server=utf8mb4_general_ci</span></span><br><span class="line">    <span class="string">default_authentication_plugin=mysql_native_password</span></span><br><span class="line">  <span class="attr">replica.cnf:</span> <span class="string">|</span></span><br><span class="line"><span class="string">    # 仅在副本服务器上应用此配置</span></span><br><span class="line"><span class="string">    [mysqld]</span></span><br><span class="line"><span class="string">    lower_case_table_names=1</span></span><br><span class="line"><span class="string">    log_replica_updates=1</span></span><br><span class="line"><span class="string">    relay-log=mysql-relay</span></span><br><span class="line"><span class="string">    log-bin=mysql-bin</span></span><br><span class="line"><span class="string">    gtid_mode=on</span></span><br><span class="line"><span class="string">    enforce_gtid_consistency</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">    <span class="string">max_connections=1000</span></span><br><span class="line">    <span class="string">character_set_server=utf8mb4</span></span><br><span class="line">    <span class="string">collation_server=utf8mb4_general_ci</span></span><br><span class="line">    <span class="string">default_authentication_plugin=mysql_native_password</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># 为 StatefulSet 成员提供稳定的 DNS 表项的无头服务（Headless Service）</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mysql</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/name:</span> <span class="string">mysql</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">3306</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="string">None</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">mysql</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># 用于连接到任一 MySQL 实例执行读操作的客户端服务</span></span><br><span class="line"><span class="comment"># 对于写操作，你必须连接到主服务器：mysql-0.mysql</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mysql-read</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/name:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">readonly:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">3306</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">mysql</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StatefulSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mysql</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">mysql</span></span><br><span class="line">      <span class="attr">app.kubernetes.io/name:</span> <span class="string">mysql</span></span><br><span class="line">  <span class="attr">serviceName:</span> <span class="string">mysql</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">mysql</span></span><br><span class="line">        <span class="attr">app.kubernetes.io/name:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">securityContext:</span></span><br><span class="line">        <span class="attr">runAsUser:</span> <span class="number">999</span></span><br><span class="line">        <span class="attr">runAsGroup:</span> <span class="number">999</span></span><br><span class="line">        <span class="attr">fsGroup:</span> <span class="number">999</span></span><br><span class="line">      <span class="attr">initContainers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">label-pod</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">hub.deepsoft-tech.com/wf09/curl</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">PODNAME</span></span><br><span class="line">            <span class="attr">valueFrom:</span></span><br><span class="line">              <span class="attr">fieldRef:</span></span><br><span class="line">                <span class="attr">fieldPath:</span> <span class="string">metadata.name</span></span><br><span class="line">        <span class="attr">command:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">bash</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">&quot;-c&quot;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">|</span></span><br><span class="line"><span class="string">          set -ex</span></span><br><span class="line"><span class="string">          APISERVER=https://kubernetes.default.svc</span></span><br><span class="line"><span class="string">          # 服务账号令牌的路径</span></span><br><span class="line"><span class="string">          SERVICEACCOUNT=/var/run/secrets/kubernetes.io/serviceaccount</span></span><br><span class="line"><span class="string">          # 读取 Pod 的名字空间</span></span><br><span class="line"><span class="string">          NAMESPACE=$(cat $&#123;SERVICEACCOUNT&#125;/namespace)</span></span><br><span class="line"><span class="string">          # 读取服务账号的持有者令牌</span></span><br><span class="line"><span class="string">          TOKEN=$(cat $&#123;SERVICEACCOUNT&#125;/token)</span></span><br><span class="line"><span class="string">          # 引用内部证书机构（CA）</span></span><br><span class="line"><span class="string">          CACERT=$&#123;SERVICEACCOUNT&#125;/ca.crt</span></span><br><span class="line"><span class="string">          # 使用令牌访问 API</span></span><br><span class="line"><span class="string">          # 基于 Pod 序号生成 MySQL 服务器的 ID。</span></span><br><span class="line"><span class="string">          [[ `hostname` =~ -([0-9]+)$ ]] || exit 1</span></span><br><span class="line"><span class="string">          ordinal=$&#123;BASH_REMATCH[1]&#125;</span></span><br><span class="line"><span class="string">          if [[ $ordinal -eq 0 ]]; then</span></span><br><span class="line"><span class="string">            FLAG=false</span></span><br><span class="line"><span class="string">          else</span></span><br><span class="line"><span class="string">            FLAG=true</span></span><br><span class="line"><span class="string">          fi</span></span><br><span class="line"><span class="string">          curl -X PATCH  \</span></span><br><span class="line"><span class="string">            --cacert $&#123;CACERT&#125; \</span></span><br><span class="line"><span class="string">            -H &quot;Content-Type:application/json-patch+json&quot; \</span></span><br><span class="line"><span class="string">            -H &quot;Authorization: Bearer $&#123;TOKEN&#125;&quot; $&#123;APISERVER&#125;/api \</span></span><br><span class="line"><span class="string">            -d \</span></span><br><span class="line"><span class="string">            &#x27;[</span></span><br><span class="line"><span class="string">                &#123; </span></span><br><span class="line"><span class="string">                  &quot;op&quot;: &quot;add&quot;,</span></span><br><span class="line"><span class="string">                  &quot;path&quot;: &quot;/metadata/labels/readonly&quot;,</span></span><br><span class="line"><span class="string">                  &quot;value&quot;: &quot;&#x27;&quot;$FLAG&quot;&#x27;&quot; </span></span><br><span class="line"><span class="string">                &#125; </span></span><br><span class="line"><span class="string">            ]&#x27; \</span></span><br><span class="line"><span class="string">            $&#123;APISERVER&#125;/api/v1/namespaces/$&#123;NAMESPACE&#125;/pods/$&#123;PODNAME&#125;</span></span><br><span class="line"><span class="string"></span>      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">init-mysql</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">ubuntu</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">        <span class="attr">command:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">bash</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">&quot;-c&quot;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">|</span></span><br><span class="line"><span class="string">          set -ex</span></span><br><span class="line"><span class="string">          # 基于 Pod 序号生成 MySQL 服务器的 ID。</span></span><br><span class="line"><span class="string">          [[ `hostname` =~ -([0-9]+)$ ]] || exit 1</span></span><br><span class="line"><span class="string">          ordinal=$&#123;BASH_REMATCH[1]&#125;</span></span><br><span class="line"><span class="string">          echo [mysqld] &gt; /mnt/conf.d/server-id.cnf</span></span><br><span class="line"><span class="string">          # 添加偏移量以避免使用 server-id=0 这一保留值。</span></span><br><span class="line"><span class="string">          echo server-id=$((100 + $ordinal)) &gt;&gt; /mnt/conf.d/server-id.cnf</span></span><br><span class="line"><span class="string">          # 将合适的 conf.d 文件从 config-map 复制到 emptyDir。</span></span><br><span class="line"><span class="string">          if [[ $ordinal -eq 0 ]]; then</span></span><br><span class="line"><span class="string">            cp /mnt/config-map/primary.cnf /mnt/conf.d/</span></span><br><span class="line"><span class="string">          else</span></span><br><span class="line"><span class="string">            cp /mnt/config-map/replica.cnf /mnt/conf.d/</span></span><br><span class="line"><span class="string">          fi</span></span><br><span class="line"><span class="string">          echo &quot;Find init.sql...&quot;</span></span><br><span class="line"><span class="string">          cp /mnt/config-map/init.sql /docker-entrypoint-initdb.d/init.sql</span></span><br><span class="line"><span class="string">          [[ $? -eq 0 ]] || exit 1</span></span><br><span class="line"><span class="string">          cat /docker-entrypoint-initdb.d/init.sql</span></span><br><span class="line"><span class="string">          ls -l /var/lib/mysql</span></span><br><span class="line"><span class="string">          [[ $? -eq 0 ]] || exit 1</span></span><br><span class="line"><span class="string"></span>        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">data</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/var/lib/mysql</span></span><br><span class="line">          <span class="attr">subPath:</span> <span class="string">mysql</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">init-sql</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/docker-entrypoint-initdb.d/</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">conf</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/mnt/conf.d</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config-map</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/mnt/config-map</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">clone-mysql</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">hub.deepsoft-tech.com/wf09/backupsql</span></span><br><span class="line">        <span class="attr">command:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">bash</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">&quot;-c&quot;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">|</span></span><br><span class="line"><span class="string">          set -ex</span></span><br><span class="line"><span class="string">          # 如果已有数据，则跳过克隆。</span></span><br><span class="line"><span class="string">          [[ -d /var/lib/mysql/mysql ]] &amp;&amp; exit 0</span></span><br><span class="line"><span class="string">          # 跳过主实例（序号索引 0）的克隆。</span></span><br><span class="line"><span class="string">          [[ `hostname` =~ -([0-9]+)$ ]] || exit 1</span></span><br><span class="line"><span class="string">          ordinal=$&#123;BASH_REMATCH[1]&#125;</span></span><br><span class="line"><span class="string">          [[ $ordinal -eq 0 ]] &amp;&amp; exit 0</span></span><br><span class="line"><span class="string">          # 从原来的对等节点克隆数据。</span></span><br><span class="line"><span class="string">          ncat --recv-only mysql-$(($ordinal-1)).mysql 3307 | xbstream -x -C /var/lib/mysql</span></span><br><span class="line"><span class="string">          # 准备备份。</span></span><br><span class="line"><span class="string">          xtrabackup --prepare --target-dir=/var/lib/mysql          </span></span><br><span class="line"><span class="string"></span>        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">data</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/var/lib/mysql</span></span><br><span class="line">          <span class="attr">subPath:</span> <span class="string">mysql</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">conf</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/etc/mysql/conf.d</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mysql</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">mysql:8.0.29-debian</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MYSQL_ROOT_PASSWORD</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">&quot;root&quot;</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mysql</span></span><br><span class="line">          <span class="attr">containerPort:</span> <span class="number">3306</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">socket</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/var/run/mysqld</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">init-sql</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/docker-entrypoint-initdb.d/</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">data</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/var/lib/mysql</span></span><br><span class="line">          <span class="attr">subPath:</span> <span class="string">mysql</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">conf</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/etc/mysql/conf.d</span></span><br><span class="line">        <span class="attr">resources:</span></span><br><span class="line">          <span class="attr">requests:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">500m</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">1Gi</span></span><br><span class="line">        <span class="attr">livenessProbe:</span></span><br><span class="line">          <span class="attr">exec:</span></span><br><span class="line">            <span class="attr">command:</span> [<span class="string">&quot;mysqladmin&quot;</span>, <span class="string">&quot;ping&quot;</span>, <span class="string">&quot;-uroot&quot;</span>, <span class="string">&quot;-proot&quot;</span>]</span><br><span class="line">          <span class="attr">initialDelaySeconds:</span> <span class="number">150</span></span><br><span class="line">          <span class="attr">failureThreshold:</span> <span class="number">10</span></span><br><span class="line">        <span class="attr">readinessProbe:</span></span><br><span class="line">          <span class="attr">exec:</span></span><br><span class="line">            <span class="comment"># 检查我们是否可以通过 TCP 执行查询（skip-networking 是关闭的）。</span></span><br><span class="line">            <span class="attr">command:</span> [<span class="string">&quot;mysql&quot;</span>, <span class="string">&quot;-uroot&quot;</span>, <span class="string">&quot;-proot&quot;</span>, <span class="string">&quot;-e&quot;</span>, <span class="string">&quot;SELECT 1&quot;</span>]</span><br><span class="line">          <span class="attr">initialDelaySeconds:</span> <span class="number">60</span></span><br><span class="line">          <span class="attr">failureThreshold:</span> <span class="number">5</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">backup-sql</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">hub.deepsoft-tech.com/wf09/backupsql</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">xtrabackup</span></span><br><span class="line">          <span class="attr">containerPort:</span> <span class="number">3307</span></span><br><span class="line">        <span class="attr">command:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">bash</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">&quot;-c&quot;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">|</span></span><br><span class="line"><span class="string">          set -ex</span></span><br><span class="line"><span class="string">          cd /var/lib/mysql</span></span><br><span class="line"><span class="string">          [[ `hostname` =~ -([0-9]+)$ ]] || exit 1</span></span><br><span class="line"><span class="string">          ordinal=$&#123;BASH_REMATCH[1]&#125;</span></span><br><span class="line"><span class="string">          # 如果是第0个说明是Master，跳过设置主从的部分</span></span><br><span class="line"><span class="string">          [[ $ordinal -eq 0 ]] &amp;&amp; exec ncat --listen --keep-open --send-only --max-conns=1 3307 -c \</span></span><br><span class="line"><span class="string">            &quot;xtrabackup --backup --slave-info --stream=xbstream --user=root --password=root&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">          <span class="string">echo</span> <span class="string">&quot;Waiting for mysqld to be ready (accepting connections)&quot;</span></span><br><span class="line">          <span class="string">until</span> <span class="string">mysql</span> <span class="string">-uroot</span> <span class="string">-proot</span> <span class="string">-e</span> <span class="string">&quot;SELECT 1&quot;</span> <span class="string">;</span> <span class="string">do</span> <span class="string">sleep</span> <span class="number">1</span><span class="string">;</span> <span class="string">done</span></span><br><span class="line"></span><br><span class="line">          <span class="string">echo</span> <span class="string">&quot;Initializing replication from clone position&quot;</span></span><br><span class="line">          <span class="string">mysql</span> <span class="string">-uroot</span> <span class="string">-proot</span> <span class="string">\</span></span><br><span class="line">                  <span class="string">-e</span> <span class="string">&quot;STOP SLAVE;&quot;</span>  <span class="string">\</span></span><br><span class="line">                  <span class="string">-e</span> <span class="string">&quot;RESET SLAVE;&quot;</span> <span class="string">\</span></span><br><span class="line">                  <span class="string">-e</span> <span class="string">&quot;CHANGE MASTER TO \</span></span><br><span class="line"><span class="string">                          MASTER_HOST=&#x27;mysql-0.mysql&#x27;, \</span></span><br><span class="line"><span class="string">                          MASTER_USER=&#x27;root&#x27;, \</span></span><br><span class="line"><span class="string">                          MASTER_PASSWORD=&#x27;root&#x27;, \</span></span><br><span class="line"><span class="string">                          MASTER_AUTO_POSITION = 1;&quot;</span> <span class="string">\</span></span><br><span class="line">                  <span class="string">-e</span> <span class="string">&quot;START SLAVE;&quot;</span> <span class="string">||</span> <span class="string">exit</span> <span class="number">1</span></span><br><span class="line">          <span class="string">exec</span> <span class="string">ncat</span> <span class="string">--listen</span> <span class="string">--keep-open</span> <span class="string">--send-only</span> <span class="string">--max-conns=1</span> <span class="number">3307</span> <span class="string">-c</span> <span class="string">\</span></span><br><span class="line">            <span class="string">&quot;xtrabackup --backup --slave-info --stream=xbstream --user=root --password=root&quot;</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">socket</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/var/run/mysqld</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">data</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/var/lib/mysql</span></span><br><span class="line">          <span class="attr">subPath:</span> <span class="string">mysql</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">conf</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/etc/mysql/conf.d</span></span><br><span class="line">        <span class="attr">resources:</span></span><br><span class="line">          <span class="attr">requests:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">100m</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">100Mi</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">socket</span></span><br><span class="line">        <span class="attr">emptyDir:</span> &#123;&#125;</span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">conf</span></span><br><span class="line">        <span class="attr">emptyDir:</span> &#123;&#125;</span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">init-sql</span></span><br><span class="line">        <span class="attr">emptyDir:</span> &#123;&#125;</span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config-map</span></span><br><span class="line">        <span class="attr">configMap:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">mysql-ha</span></span><br><span class="line">  <span class="attr">volumeClaimTemplates:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">data</span>          </span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">storageClassName:</span> <span class="string">rook-ceph-block</span></span><br><span class="line">      <span class="attr">accessModes:</span> [<span class="string">&quot;ReadWriteOnce&quot;</span>]</span><br><span class="line">      <span class="attr">resources:</span></span><br><span class="line">        <span class="attr">requests:</span></span><br><span class="line">          <span class="attr">storage:</span> <span class="string">1Gi</span></span><br></pre></td></tr></table></figure>
<h2 id="如何给pod动态的增加label">如何给Pod动态的增加Label</h2>
<p>现在要求Service
A可以直接连接主库，即可以直接连接到StatefulSet创建的第一个Pod；Service
B可以直接连接所有的从库，即除去第一个Pod都可以通过Service负载均衡到后端Pod。</p>
<p>现在思路是通过 initContainerd 容器，在work
Pod起来之前中执行以下逻辑：</p>
<ul>
<li>判断hostname，如果带0，说明是第一个主库，通过REST API请求K8s API
Server，根据每一个Pod都会<strong>自动挂载默认Service
Account（投射卷）</strong>的机制，可以获取到请求K8s API
Server的密钥。</li>
</ul>
<p>部分资源清单：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">initContainers:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">label-pod</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">hub.deepsoft-tech.com/wf09/curl</span></span><br><span class="line">  <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">  <span class="attr">env:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">PODNAME</span></span><br><span class="line">      <span class="attr">valueFrom:</span></span><br><span class="line">        <span class="attr">fieldRef:</span></span><br><span class="line">          <span class="attr">fieldPath:</span> <span class="string">metadata.name</span></span><br><span class="line">  <span class="attr">command:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">bash</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;-c&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">|</span></span><br><span class="line"><span class="string">    set -ex</span></span><br><span class="line"><span class="string">    APISERVER=https://kubernetes.default.svc</span></span><br><span class="line"><span class="string">    # 服务账号令牌的路径</span></span><br><span class="line"><span class="string">    SERVICEACCOUNT=/var/run/secrets/kubernetes.io/serviceaccount</span></span><br><span class="line"><span class="string">    # 读取 Pod 的名字空间</span></span><br><span class="line"><span class="string">    NAMESPACE=$(cat $&#123;SERVICEACCOUNT&#125;/namespace)</span></span><br><span class="line"><span class="string">    # 读取服务账号的持有者令牌</span></span><br><span class="line"><span class="string">    TOKEN=$(cat $&#123;SERVICEACCOUNT&#125;/token)</span></span><br><span class="line"><span class="string">    # 引用内部证书机构（CA）</span></span><br><span class="line"><span class="string">    CACERT=$&#123;SERVICEACCOUNT&#125;/ca.crt</span></span><br><span class="line"><span class="string">    # 使用令牌访问 API</span></span><br><span class="line"><span class="string">    # 基于 Pod 序号生成 MySQL 服务器的 ID。</span></span><br><span class="line"><span class="string">    [[ `hostname` =~ -([0-9]+)$ ]] || exit 1</span></span><br><span class="line"><span class="string">    ordinal=$&#123;BASH_REMATCH[1]&#125;</span></span><br><span class="line"><span class="string">    if [[ $ordinal -eq 0 ]]; then</span></span><br><span class="line"><span class="string">      FLAG=false</span></span><br><span class="line"><span class="string">    else</span></span><br><span class="line"><span class="string">      FLAG=true</span></span><br><span class="line"><span class="string">    fi</span></span><br><span class="line"><span class="string">    curl -X PATCH  \</span></span><br><span class="line"><span class="string">      --cacert $&#123;CACERT&#125; \</span></span><br><span class="line"><span class="string">      -H &quot;Content-Type:application/json-patch+json&quot; \</span></span><br><span class="line"><span class="string">      -H &quot;Authorization: Bearer $&#123;TOKEN&#125;&quot; $&#123;APISERVER&#125;/api \</span></span><br><span class="line"><span class="string">      -d \</span></span><br><span class="line"><span class="string">      &#x27;[</span></span><br><span class="line"><span class="string">          &#123; </span></span><br><span class="line"><span class="string">            &quot;op&quot;: &quot;add&quot;,</span></span><br><span class="line"><span class="string">            &quot;path&quot;: &quot;/metadata/labels/readonly&quot;,</span></span><br><span class="line"><span class="string">            &quot;value&quot;: &quot;&#x27;&quot;$FLAG&quot;&#x27;&quot; </span></span><br><span class="line"><span class="string">          &#125; </span></span><br><span class="line"><span class="string">      ]&#x27; \</span></span><br><span class="line"><span class="string">      $&#123;APISERVER&#125;/api/v1/namespaces/$&#123;NAMESPACE&#125;/pods/$&#123;PODNAME&#125;</span></span><br></pre></td></tr></table></figure>
<p>上面</p>
<p>⚠️默认情况下默认服务账号是不能更改Pod
Label的，需要执行一下资源清单开放权限</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">patch-my-pods</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">patch-my-pods</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>] <span class="comment"># &quot;&quot; indicates the core API group</span></span><br><span class="line">  <span class="attr">resources:</span> [<span class="string">&quot;pods&quot;</span>]</span><br><span class="line">  <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;list&quot;</span>, <span class="string">&quot;watch&quot;</span>, <span class="string">&quot;create&quot;</span>, <span class="string">&quot;update&quot;</span>, <span class="string">&quot;patch&quot;</span>, <span class="string">&quot;delete&quot;</span>]</span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">RoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">patch-my-pods</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">patch-my-pods</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br></pre></td></tr></table></figure>
<p>apply以后可以检查一下自己是否有权限</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl auth can-i patch pods --as=system:serviceaccount:default:default -n default</span><br></pre></td></tr></table></figure>
<p>执行完以上操作就可以动态的Pod添加标签啦～</p>
<h2 id="问题">问题</h2>
<h3 id="error-my-010544-repl-failed-to-open-the-relay-log">[ERROR]
[MY-010544] [Repl] Failed to open the relay log</h3>
<p>当使用xtrabackup对<strong>从库</strong>进行冷备份时，并使用这个从库的备份创建一个新的从库实例时，会出现此问题。</p>
<p>通过relay
log介绍，很容易知道由于mysql.slave_relay_log_info表中保留了以前的复制信息，导致新从库启动时无法找到对应文件。</p>
<p>此时需要登陆到从库的MySQL实例，重置一下slave即可</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> stop slave;</span><br><span class="line">mysql<span class="operator">&gt;</span> reset slave;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">start</span> slave;</span><br></pre></td></tr></table></figure>
<h3
id="the-slave-io-thread-stops-because-master-and-slave-have-equal-mysql-server-uuids">The
slave I/O thread stops because master and slave have equal MySQL server
UUIDs</h3>
<p>这个问题通常是因为备份数据库时，把数据库的UUID也复制了下来。而主从关系要求这个UUID<strong>必须唯一</strong>。这个uuid通常存在<code>/var/log/mysql/auto.cnf</code>文件夹下，通常删除该文件，重启一下数据库即可。</p>
<p>PS：在开启<strong>GTID</strong>复制时，貌似不会自动复制auto.cnf此文件。</p>
<h2 id="引用">引用</h2>
<ul>
<li><p><a href="https://mp.weixin.qq.com/s/UzmWEnE13Fet1sxfuJm5Kg">MySQL
基于GTID主从复制</a></p></li>
<li><p><a
href="https://mp.weixin.qq.com/s/g9M69oJwuMOUI3J-_QoFsQ">XtraBackup
搭建从库的一般步骤及 XtraBackup 8.0 的注意事项</a></p></li>
</ul>
]]></content>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes集群实践（八）Kubernetes安装云原生存储系统Rook</title>
    <url>/p/Install-Rook-on-k8s/</url>
    <content><![CDATA[<p>本文主要介绍如何安装和使用云原生存储系统Rook。</p>
<p>关键词：<strong>k8s</strong></p>
<span id="more"></span>
<h2 id="准备工作">准备工作</h2>
<ul>
<li>Ubuntu 20.04 LTS amd64，32GB，作为Master节点</li>
</ul>
<p>假定已经安装了K8s集群，这里以单节点集群为例</p>
<h2 id="rook">Rook</h2>
<ul>
<li>Rook是一个开源的云原生存储协调器，提供平台、框架和对各种存储解决方案的支持，以与云原生环境进行本地集成。</li>
<li>Rook将存储软件转变为自我管理，自我扩展和自我修复的存储服务。它通过自动化部署、引导、配置、供应、扩展、升级、迁移、灾难恢复、监视和资源管理来实现。Rook使用底层云原生容器管理，调度和编排平台提供的功能来执行其职责。</li>
<li>Rook利用扩展点将其深度集成到云原生环境中，并为调度、生命周期管理、资源管理、安全性、监视和用户体验提供无缝的体验。</li>
</ul>
<h3 id="部署rook">部署Rook</h3>
<p>下载源码，项目地址：https://github.com/rook/rook/releases</p>
<p>最新源码为1.9.7</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --single-branch --branch v1.9.7 https://github.com/rook/rook.git</span><br></pre></td></tr></table></figure>
<h4 id="以块存储rbd为例">以块存储RBD为例</h4>
<p>部署准备工作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> rook/deploy/examples</span><br><span class="line">kubectl create -f crds.yaml -f common.yaml -f operator.yaml</span><br></pre></td></tr></table></figure>
<p>确保存储设备没有文件系统</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">sudo fdisk -<span class="keyword">l</span></span><br></pre></td></tr></table></figure>
<p><img data-src="image-20220727110451053.png" /></p>
<p>如果有GPT或者dos等描述文字，说明存在分区表，需要把这个删掉</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo wipefs /dev/sda</span><br></pre></td></tr></table></figure>
<p>可以看到分区表</p>
<p>执行删除命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo wipefs -a -f /dev/sda</span><br></pre></td></tr></table></figure>
<p>根据需要修改一下集群</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim cluster.yaml</span><br></pre></td></tr></table></figure>
<p>主要是指定设备，设定mon为1，mgr为1等操作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#################################################################################################################</span></span><br><span class="line"><span class="comment"># Define the settings for the rook-ceph cluster with common settings for a small test cluster.</span></span><br><span class="line"><span class="comment"># All nodes with available raw devices will be used for the Ceph cluster. One node is sufficient</span></span><br><span class="line"><span class="comment"># in this example.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># For example, to create the cluster:</span></span><br><span class="line"><span class="comment">#   kubectl create -f crds.yaml -f common.yaml -f operator.yaml</span></span><br><span class="line"><span class="comment">#   kubectl create -f cluster-test.yaml</span></span><br><span class="line"><span class="comment">#################################################################################################################</span></span><br><span class="line">kind: ConfigMap</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  name: rook-config-override</span><br><span class="line">  namespace: rook-ceph <span class="comment"># namespace:cluster</span></span><br><span class="line">data:</span><br><span class="line">  config: |</span><br><span class="line">    [global]</span><br><span class="line">    osd_pool_default_size = 1</span><br><span class="line">    mon_warn_on_pool_no_redundancy = <span class="literal">false</span></span><br><span class="line">    bdev_flock_retry = 20</span><br><span class="line">    bluefs_buffered_io = <span class="literal">false</span></span><br><span class="line">---</span><br><span class="line">apiVersion: ceph.rook.io/v1</span><br><span class="line">kind: CephCluster</span><br><span class="line">metadata:</span><br><span class="line">  name: my-cluster</span><br><span class="line">  namespace: rook-ceph <span class="comment"># namespace:cluster</span></span><br><span class="line">spec:</span><br><span class="line">  dataDirHostPath: /var/lib/rook</span><br><span class="line">  cephVersion:</span><br><span class="line">    image: quay.io/ceph/ceph:v17</span><br><span class="line">    allowUnsupported: <span class="literal">true</span></span><br><span class="line">  mon:</span><br><span class="line">    count: 1</span><br><span class="line">    allowMultiplePerNode: <span class="literal">true</span></span><br><span class="line">  mgr:</span><br><span class="line">    count: 1</span><br><span class="line">    allowMultiplePerNode: <span class="literal">true</span></span><br><span class="line">  dashboard:</span><br><span class="line">    enabled: <span class="literal">true</span></span><br><span class="line">  crashCollector:</span><br><span class="line">    <span class="built_in">disable</span>: <span class="literal">true</span></span><br><span class="line">  storage:</span><br><span class="line">    useAllNodes: <span class="literal">false</span></span><br><span class="line">    useAllDevices: <span class="literal">false</span></span><br><span class="line">    <span class="comment">#deviceFilter:</span></span><br><span class="line">    config:</span><br><span class="line">      <span class="comment"># crushRoot: &quot;custom-root&quot; # specify a non-default root label for the CRUSH map</span></span><br><span class="line">      <span class="comment"># metadataDevice: &quot;md0&quot; # specify a non-rotational storage so ceph-volume will use it as block db device of bluestore.</span></span><br><span class="line">      <span class="comment"># databaseSizeMB: &quot;1024&quot; # uncomment if the disks are smaller than 100 GB</span></span><br><span class="line">      <span class="comment"># journalSizeMB: &quot;1024&quot;  # uncomment if the disks are 20 GB or smaller</span></span><br><span class="line">      osdsPerDevice: <span class="string">&quot;1&quot;</span> <span class="comment"># this value can be overridden at the node or device level</span></span><br><span class="line">      <span class="comment"># encryptedDevice: &quot;true&quot; # the default value for this option is &quot;false&quot;</span></span><br><span class="line"><span class="comment"># Individual nodes and their config can be specified as well, but &#x27;useAllNodes&#x27; above must be set to false. Then, only the named</span></span><br><span class="line"><span class="comment"># nodes below will be used as storage resources.  Each node&#x27;s &#x27;name&#x27; field should match their &#x27;kubernetes.io/hostname&#x27; label.</span></span><br><span class="line">    nodes:</span><br><span class="line">      - name: <span class="string">&quot;amd-5700g&quot;</span></span><br><span class="line">        devices: <span class="comment"># specific devices to use for storage can be specified for each node</span></span><br><span class="line">          - name: <span class="string">&quot;sda&quot;</span></span><br><span class="line">    deviceFilter:</span><br><span class="line">  healthCheck:</span><br><span class="line">    daemonHealth:</span><br><span class="line">      mon:</span><br><span class="line">        interval: 45s</span><br><span class="line">        <span class="built_in">timeout</span>: 600s</span><br><span class="line">  priorityClassNames:</span><br><span class="line">    all: system-node-critical</span><br><span class="line">    mgr: system-cluster-critical</span><br><span class="line">  disruptionManagement:</span><br><span class="line">    managePodBudgets: <span class="literal">true</span></span><br><span class="line">---</span><br><span class="line">apiVersion: ceph.rook.io/v1</span><br><span class="line">kind: CephBlockPool</span><br><span class="line">metadata:</span><br><span class="line">  name: builtin-mgr</span><br><span class="line">  namespace: rook-ceph <span class="comment"># namespace:cluster</span></span><br><span class="line">spec:</span><br><span class="line">  name: .mgr</span><br><span class="line">  replicated:</span><br><span class="line">    size: 1</span><br><span class="line">    requireSafeReplicaSize: <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>现在可以部署了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f cluster.yaml</span><br></pre></td></tr></table></figure>
<p>安装ceph工具</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl applt -f toolbox.yaml</span><br></pre></td></tr></table></figure>
<p>等待相关操作执行完毕</p>
<p><img data-src="image-20220727120539317.png" /></p>
<p>此时进入ceph-tools，查看ceph集群工作状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl -n rook-ceph <span class="built_in">exec</span> -it deploy/rook-ceph-tools -- bash</span><br></pre></td></tr></table></figure>
<p><img data-src="image-20220727120713981.png" /></p>
<h3 id="挂载rook块存储到pod容器">挂载Rook块存储到Pod容器</h3>
<p>首先需要创建strongeClass，才可以让k8s控制器根据声明的PVC创建PV</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mysql-standalone-pvc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">rook-ceph-block</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">1Gi</span></span><br></pre></td></tr></table></figure>
<p>然后在Pod里创建PVC</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mysql-standalone-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:8-debian</span></span><br><span class="line">    <span class="attr">args:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--max_connections=10000</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--character-set-server=utf8mb4</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--collation-server=utf8mb4_general_ci</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--default-authentication-plugin=mysql_native_password</span></span><br><span class="line">    <span class="attr">env:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MYSQL_ROOT_PASSWORD</span></span><br><span class="line">      <span class="attr">value:</span> <span class="string">&quot;root&quot;</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mysql-standalone-data</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/var/lib/mysql</span>             <span class="comment"># 容器挂载路径</span></span><br><span class="line">      <span class="attr">subPath:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mysql-conf</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/etc/mysql/conf.d</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mysql-standalone-data</span></span><br><span class="line">    <span class="attr">persistentVolumeClaim:</span></span><br><span class="line">      <span class="attr">claimName:</span> <span class="string">mysql-standalone-pvc</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mysql-conf</span></span><br><span class="line">    <span class="attr">configMap:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">mysql-standalone-config</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>应用编排与管理：核心原理</title>
    <url>/p/core-concept-about-App-stores-and-persists-data/</url>
    <content><![CDATA[<p>本文是CNCF × Alibaba
云原生技术公开课的<strong>第九章应用存储和持久化数据卷：核心知识</strong>学习笔记。</p>
<p>关键词：<strong>k8s</strong></p>
<span id="more"></span>
<p>本文主要介绍以下部分：</p>
<ol type="1">
<li>K8s Volume使用场景</li>
<li>PVC/PV/StrongeClass基本操作和概念解析</li>
<li>PVC+PV体系的设计和实现原理</li>
</ol>
<h3 id="volumes介绍">Volumes介绍</h3>
<h4 id="pod-volumes">Pod Volumes</h4>
<p>首先来看Pod Volumes的使用场景：</p>
<ul>
<li>当Pod中的某一个容器在运行时异常退出，被kubelet重新拉起以后，如果保证之前容器产生的重要数据没有丢失？</li>
<li>如果 同一个Pod的多个Pod容器想要共享数据，应该如何去做？</li>
</ul>
<p>以上两个场景，可以使用Volumes来很好解决，接下来来看一下Pod
Volumes的常见类型：</p>
<ol type="1">
<li>本地存储：常见的有emptydir和hostpath；</li>
<li>网络存储：网络存储的实现方式有两种，一种是<strong>in-tree</strong>，就是实现的代码是在k8s代码仓库中的，随着k8s对存储类型的增多，这种方式会给k8s本身的维护和发展带来很大的负担；另一种是out-in-tree，首先方式是给k8s<strong>解耦</strong>的，通过抽象接口将不同存储的driver实现从k8s代码仓库中剥离，因此out-of-tree是CNCF社区中主推的实现网络存储插件的方式；</li>
<li>Project
Volumes：将一些配置信息，如secret/configmap用卷的形式挂载到容器中，让容器中的程序可以通过POSIX接口（系统调用）来访问配置数据；</li>
<li>PV和PVC</li>
</ol>
<h4 id="persistent-volumes">Persistent Volumes</h4>
<p><img data-src="image-20220714164531327.png" /></p>
<p>以下的几种场景，Pod Volumes是不能解决的：</p>
<ul>
<li>Pod销毁重建，如用Deployment管理的Pod，在做镜像升级的时候，会产生新的Pod并删除旧的Pod，那新Pod和旧Pod如何复用数据？</li>
<li>宿主机宕机，要迁移Pod，此时StatefulSet管理的Pod，其实是已经实现了带卷迁移的语义。此时Pod
Volumes显然是无法做到；</li>
<li>多个Pod之间想要共享数据，如何声明？同一个Pod中多个容器想要共享数据，可以借助Pod
Volumes来解决；当多个Pod共享数据时，就很难表达这种语义。</li>
<li>如果相对数据卷做一些功能扩展性，如snapshot、resize这些功能，又应该怎么实现？</li>
</ul>
<p>以上场景中，<strong>Pod
Volume</strong>很难表达复用的语义，对其扩展也比较困难，因此K8s又引入了<strong>Persistent
Volume</strong>概念。通过Persistent
Volume，可以将计算和存储分离，通过不同的组件来管理存储资源和计算资源，然后解耦Pod和Volume之间声明周期的关联，这样把Pod删除以后，使用的PV依然存在，还可以被新建的Pod复用。</p>
<h4 id="persistent-volumes-claim">Persistent Volumes Claim</h4>
<p><img data-src="image-20220714171037554.png" /></p>
<p>用户在使用PV时实际上是通过PVC，PVC简化了k8s用户对存储的使用方式，做到了职责分离。通常用户在使用存储时，只需要声明存储大小和访问方式即可。</p>
<p>访问模式指的是使用的存储可以被多个ndoe共享还是只能单node独占访问？只读访问还是读写访问？用户只关心这些东西，与存储相关的实现细节是不关心的。</p>
<p>通过PV和PVC的概念，将用户需求与实现细节解耦，用户只需要通过PVC声明自己的存储需求。PV是由集群管理员和存储相关团队来统一运维和管控，这样的话，就简化了用户使用存储的方式，可以看到，PV和PVC的设计其实有点像面向对象的接口与实现的关系。用户在使用其功能时，只关心用户接口，不需关心内部复杂的实现细节。</p>
<p>由于PV是由集群管理员统一管控的，接下来就看这个PV对象是如何产生的。</p>
<h5 id="static-volume-provisioning">Static Volume Provisioning</h5>
<p>静态PV</p>
<p><img data-src="image-20220715134705456.png" /></p>
<ul>
<li><p>静态PV：集群管理员事先去规划这个集群中的用户会怎样使用存储，它会先预分配一些存储，也就是预先创建一些
PV；然后用户在提交自己的存储需求（也就是 PVC）的时候，K8s
内部相关组件会帮助它把 PVC 和 PV 做绑定；之后用户再通过 pod
去使用存储的时候，就可以通过 PVC 找到相应的
PV，它就可以使用了。</p></li>
<li><p>不足：静态产生方式有什么不足呢？可以看到，首先需要集群管理员预分配，预分配其实是很难预测用户真实需求的。举一个最简单的例子：如果用户需要的是
20G，然而集群管理员在分配的时候可能有 80G 、100G 的，但没有 20G
的，这样就很难满足用户的真实需求，也会造成资源浪费。有没有更好的方式呢？</p></li>
</ul>
<h5 id="dynamic-volume-provisioning">Dynamic Volume Provisioning</h5>
<p>动态PV</p>
<p><img data-src="image-20220715134954652.png" /></p>
<ul>
<li>动态PV：集群管理员不预先分配PV，他写了一个配置文件，这个模版文件是用来表示创建某一类型存储（块存储和文件存储等）所需要的一些参数，这些参数是用户不关心的，给存储本身实现有关的参数，用户只需要提交自身的存储需求，也就是PVC文件，并在PVC中指定的存储模版（StorageClass）。</li>
<li>apiServer结合PVC和StorageClass的信息，动态生成用户所需要的存储（PV），将PVC和PV进行绑定后，Pod可以使用PV了。通过StorageClass配置生成存储需要的存储模版，结合用户的需求创建PV对象，做到按需分配，在没有增加用户使用难度的同时也解放了集群管理员的运维工作。</li>
</ul>
<h3 id="用例解读">用例解读</h3>
<p>来看一下Pod Volumes、PV、PVC、StrongeClass具体如何使用的？</p>
<h4 id="pod-volumes-1">Pod Volumes</h4>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mysql-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mysql-pod-1</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:5</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mysql-data</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/data</span>             <span class="comment"># 容器挂载路径</span></span><br><span class="line">      <span class="attr">subPath:</span> <span class="string">cache</span>               <span class="comment"># 挂载路径内部建立子目录</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">host-data</span>                 </span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/host</span></span><br><span class="line">      <span class="attr">readOnly:</span> <span class="literal">true</span>               <span class="comment"># 只读挂载</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mysql-pod-2</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:5</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mysql-data</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/data</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mysql-data</span></span><br><span class="line">    <span class="attr">emptyDir:</span> &#123;&#125;                   <span class="comment"># 当Pod被分配至节点时，节点自动分配的目录。当Pod删除以后该目录也会被删除</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">host-data</span></span><br><span class="line">    <span class="attr">hostPath:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/tmp/host-data</span>         <span class="comment"># 指定宿主机的目录，当Pod删除以后，该目录依然存在</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>.spec.volumes</code>：声明Pod的volume信息</li>
<li><code>.spec.volumes.volumeMounts</code>：声明container如何使用Pod的Volumes</li>
<li>当多个container共享同一个volume时，可以通过<code>spec.containers.volumeMounts.subPath</code>隔离不同容器在同一个volume上数据存储的路径。</li>
</ul>
<p>emptyDir、hostPath 都是本地存储，它们之间有什么细微的差别呢？</p>
<ul>
<li>emptyDir 其实是在 pod 创建的过程中会临时创建的一个目录，这个目录随着
pod 删除也会被删除，里面的数据会被清空掉；hostPath
顾名思义，其实就是宿主机上的一个路径，在 pod
删除之后，这个目录还是存在的，它的数据也不会被丢失。这就是它们两者之间一个细微的差别。</li>
</ul>
<h4 id="静态pv使用">静态PV使用</h4>
<p>静态PV首先是有管理员创建的，这里使用hostPath类型作为演示。</p>
<p>⚠️在生产集群中，你不会使用
hostPath。集群管理员会提供网络存储资源，比如 Google Compute Engine
持久盘卷、NFS 共享卷或 Amazon Elastic Block Store 卷。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mysql-pv-volume</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">local</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">manual</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">10Gi</span>                          <span class="comment"># 该Volume的总容量大小</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span>                        <span class="comment"># 设置该Volume只能被当前node挂载且都具有读写权限</span></span><br><span class="line">  <span class="attr">persistentVolumeReclaimPolicy:</span> <span class="string">Retain</span>    <span class="comment"># 设置该Volume使用后被release之后的回收策略</span></span><br><span class="line">  <span class="attr">hostPath:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">&quot;/mnt/data&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>persistentVolumeReclaimPolicy</code>的意思就是这块存在被使用后，如果使用方Pod以及PVC都被删除，这个PV的回收策略。</li>
</ul>
<p>首先，用户需要创建一个<strong>PVC对象</strong>，PVC对象只需要指定<strong>存储需求</strong>，而不用关心存储本身的具体实现细节。</p>
<p>存储需求包括：</p>
<ul>
<li>需要的volume大小</li>
<li>访问方式：即这个存储的访问方式：这里声明为ReadWriteOnce，即只能在给node上读写
<ul>
<li>一般情况下文件存储的读写方式是ReadWriteMany，也就是多node读写访问；这里由于使用的是hostPath，因此只能设置ReadWriteOnce。</li>
</ul></li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mysql-pv-claim</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">manual</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">3Gi</span></span><br></pre></td></tr></table></figure>
<p>上文中可以看到，PVC的size和access
mode和刚刚创建的PV其实是匹配的；当用户在提交PVC的时候，K8s集群的相关组件就会把PV和PVC
bound一起。之后用户在提交Pod
yaml时，在volumes上写PVC声明，通过claimName声明要用那个PVC。然后挂载方式就喝前面讲的一样了，当提交完yaml，api
server可以通过PVC找到对应的PV， 然后就可以使用存储了。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">nodeName:</span> <span class="string">master</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mysql-pod-1</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:5</span></span><br><span class="line">    <span class="attr">env:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MYSQL_ROOT_PASSWORD</span></span><br><span class="line">      <span class="attr">value:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mysql-data</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/data</span>             <span class="comment"># 容器挂载路径</span></span><br><span class="line">      <span class="attr">subPath:</span> <span class="string">cache</span>               <span class="comment"># 挂载路径内部建立子目录</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">host-data</span>               </span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/host</span></span><br><span class="line">      <span class="attr">readOnly:</span> <span class="literal">true</span>               <span class="comment"># 只读挂载</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mysql-pod-2</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:5</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mysql-data</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/data</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mysql-data</span></span><br><span class="line">    <span class="attr">emptyDir:</span> &#123;&#125;                   <span class="comment"># 当Pod被分配至节点时，节点自动分配的目录。当Pod删除以后该目录也会被删除</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">host-data</span></span><br><span class="line">    <span class="attr">hostPath:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/tmp/host-data</span>         <span class="comment"># 指定宿主机的目录，当Pod删除以后，该目录依然存在</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="动态pv使用">动态PV使用</h4>
<p>动态PV模式下系统管理员不在预分配PV，只是创建一个模版文件。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">storage.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StorageClass</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nfs-sc</span></span><br><span class="line"><span class="attr">provisioner:</span> <span class="string">example.com/external-nfs</span></span><br><span class="line"><span class="attr">parameters:</span></span><br><span class="line">  <span class="attr">server:</span> <span class="string">nfs-server.example.com</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">/share</span></span><br><span class="line">  <span class="attr">readOnly:</span> <span class="string">&quot;false&quot;</span></span><br><span class="line"><span class="attr">reclaimPolicy:</span> <span class="string">Delete</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>模版文件叫做StorageClass</p></li>
<li><p>上述模版问卷需要填写一个是provisioner，这个就是创建PV对应的存储插件，使用StorageClass时需要提前安装存储插件</p>
<ul>
<li>上述模版文件对应的驱动是 NFS文件系统</li>
</ul></li>
<li><p><code>parameters</code>：是通过K8s创建存储时需要指定的一些细节参数，而这些参数是用户不需要关心的：像server、path、readOnly分别就是NFS文件服务器的地址、文件分享路径、是否只读等的一些参数</p></li>
<li><p><code>reclaimPolicy</code>：是PV在Pod以及PVC被删除后的回收策略</p></li>
</ul>
<p>当向系统提交完StorageClass，也就是提交创建PV的模版之后，还是需要写一个PVC的资源清单：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mysql-pv-claim</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">nfs-sc</span>  <span class="comment"># </span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">3Gi</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>storageClassName</code>：指定后端storageClassName，如不指定则使用默认的storageClassName；默认的sc通过注解<code>storageclass.kubernetes.io/is-default-class: true</code>标示。</li>
</ul>
]]></content>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS实战（七）Jetson Xavier NX 高级操作</title>
    <url>/p/Advanced-operations-on-Jetson-Xavier/</url>
    <content><![CDATA[<p>最近的生活真的是一塌糊涂，秋招不像秋招，面试没有面试。</p>
<p>好久没有好好静下心来写文章了，今天就把最近折腾的东西记录一下吧。</p>
<p><strong>关键词：</strong>Jetson</p>
<span id="more"></span>
<h2 id="前言">前言</h2>
<p>Jeston是NVIDIA开发的嵌入式平台，支持CUDA。这款板子是笔者拿来用来做毕业设计的。</p>
<p>以下是他们的参数指标，可以看到性能还是不错的，除了有些鸡肋的armv8
CPU。</p>
<p><img data-src="image-20220707210050935.png" /></p>
<h2 id="安装镜像到nvme硬盘">安装镜像到nvme硬盘</h2>
<p>NX自带一个NVMe M.2 SSD的插槽，还带一个M.2
key的无线网卡插槽。我将自带的realtek网卡拿下来，换上了intel ax201
wifi6无线网卡。并把闲置的SSD也放了上去。</p>
<p>从Jetpack
4.6开始，官方就支持将系统写入固态硬盘。而之前是只能向SD卡里写的。固态硬盘的速度和SD卡里相比那可快多啦。下面就介绍以下如何安装镜像到nvme硬盘。</p>
<h3 id="下载sdk">下载SDK</h3>
<p>首先要准备一台ubuntu的电脑，或者使用docker，这个官网有说明：</p>
<p><img data-src="image-20220707212251884.png" /></p>
<ul>
<li>如果想装最新版的Jetpack DP 5.0.1，需要使用ubuntu
18.04或者20.04，而5.0.1之前的版本只能使用ubuntu 18.04.</li>
</ul>
<h3 id="安装sdk">安装SDK</h3>
<p>下载完毕后，执行以下命令安装sdk</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install ./sdkmanager.deb</span><br></pre></td></tr></table></figure>
<p>安装完毕以后是这个样子的</p>
<p><img data-src="image-20220707213053772.png" /></p>
<p>现在还没有检测到Xavier NX，用一根普通的usb线将板子的micro
usb口连接到电脑，然后就能检测到了。</p>
<p><img data-src="image-20220707213322544.png" /></p>
<p>点击CONTIUNE，进入下一步</p>
<h3 id="选择下载的部分">选择下载的部分</h3>
<p>第一次安装时，要把HOST的部分的内容全部下载下来，然后根据自己的需要安装Target。我这里为了方便起见就全部安装了。</p>
<p><img data-src="image-20220707213951561.png" /></p>
<p>为了方便起见，可以选择先下载后安装，这样即节约了时间，由减少了因下载数据丢失而出现的错误。</p>
<p>连接好Xariver，勾选协议，选择下一步</p>
<h3 id="安装步骤">安装步骤</h3>
<p>首先是输入ubuntu的密码，方便sdk安装一些Host主机没有的软件包。</p>
<p><img data-src="image-20220707214328696.png" /></p>
<p>接下来是选择刷入的存储设备，并连接到板子进行刷机。</p>
<p><img data-src="image-20220707214519814.png" /></p>
<ul>
<li>第一个箭头的位置是输入Xavier
NX现在的账户和密码，方便SDK自动设置NX进入恢复模式；如果此时NX已经无法是打开，那么也没有关系，将<strong>Automatic
Setup</strong>选项修改为<strong>Manal
Setup</strong>，并根据给出的提示将NX手动设置恢复模式；具体请看下图</li>
<li>第二个箭头的位置是选择刷入的设备，这里选择NVMe设备，SDK会自动选择</li>
</ul>
<p><img data-src="image-20220707214838394.png" /></p>
<p>输入完毕以后，就可开始刷机了，点击Flash，耐心等待流程结束。</p>
<p><img data-src="image-20220707215020923.png" /></p>
<p>耐心等待刷机结束。</p>
<p><img data-src="image-20220707215219174.png" /></p>
<p>Ooooops：翻车了，刷机竟然失败。后来重新刷了一下就可以了。</p>
<h2 id="启用国内源">启用国内源</h2>
<p>这个老生常谈了，国内速度比较快的应该是中科大的源了.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">mv</span> /etc/apt/source.list /etc/apt/source.list.bak</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu-ports/ focal main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.ustc.edu.cn/ubuntu-ports/ focal main main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu-ports/ focal-updates main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.ustc.edu.cn/ubuntu-ports/ focal-updates main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu-ports/ focal-backports main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.ustc.edu.cn/ubuntu-ports/ focal-backports main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu-ports/ focal-security main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.ustc.edu.cn/ubuntu-ports/ focal-security main restricted universe multiverse</span></span><br></pre></td></tr></table></figure>
<h2 id="安装smb文件共享服务器">安装smb文件共享服务器</h2>
<p>安装smb就可直接在windows上挂载NAS的硬盘了。</p>
<p>smb在linux上有一个开源的实现就是samba，这个软件通常在软件包管理器中。</p>
<h3 id="安装软件包">安装软件包</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install samba</span><br></pre></td></tr></table></figure>
<p>查看启动状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl status nmbd</span><br></pre></td></tr></table></figure>
<h3 id="修改配置文件">修改配置文件</h3>
<p>备份默认的配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">cp</span> /etc/samba/smb.conf&#123;,.backup&#125;</span><br></pre></td></tr></table></figure>
<h4 id="设置绑定网络接口">设置绑定网络接口</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># The specific set of interfaces / networks to bind to</span></span><br><span class="line"><span class="comment"># This can be either the interface name or an IP address/netmask;</span></span><br><span class="line"><span class="comment"># interface names are normally preferred</span></span><br><span class="line">interfaces = 127.0.0.0/8 eth0</span><br><span class="line"></span><br><span class="line"><span class="comment"># Only bind to the named interfaces and/or networks; you must use the</span></span><br><span class="line"><span class="comment"># &#x27;interfaces&#x27; option above to use this.</span></span><br><span class="line"><span class="comment"># It is recommended that you enable this feature if your Samba machine is</span></span><br><span class="line"><span class="comment"># not protected by a firewall or is a firewall itself.  However, this</span></span><br><span class="line"><span class="comment"># option cannot handle dynamic or non-broadcast interfaces correctly.</span></span><br><span class="line"><span class="built_in">bind</span> interfaces only = no</span><br></pre></td></tr></table></figure>
<ul>
<li>这里根据自己的网络接口确定，通过<code>ip a</code>命令可以查看。</li>
</ul>
]]></content>
      <tags>
        <tag>Jetson</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins实战（四）构建hexo博客</title>
    <url>/p/build-hexo-blog-with-jenkins/</url>
    <content><![CDATA[<p>本文主要介绍如何在Jenkins上构建hexo博客。</p>
<p>关键词：<strong>Jenkins</strong></p>
<span id="more"></span>
<h2 id="使用二进制文件进行构建">使用二进制文件进行构建</h2>
<h3 id="需求来源">需求来源</h3>
<p>博客源码是使用git托管在GitHub上的，之前使用的github
action服务。由于滥用，github对actions的限制越发严格。</p>
<p>自己有几台闲置的Linux主机，可以拿来构建博客。</p>
<p>jenkins是著名的自动化构建软件，本次就拿构建博客做个小例子。</p>
<h3 id="准备">准备</h3>
<p>安装好jenkins的linux服务器，并运行jenkins。</p>
<h3 id="创建项目">创建项目</h3>
<h4 id="名称">名称</h4>
<p>这里的名称可以任选。</p>
<h4 id="源码管理">源码管理</h4>
<p>源码管理选择Git，这里写我自己的仓库的链接。</p>
<p><img data-src="image-20220630141619409.png" /></p>
<ul>
<li>注意Creditials要选择对应协议。如果是ssh协议就选ssh
key，如果是https协议且是私有仓库，那就需要personal token。</li>
</ul>
<p>测试一下是否成功链接上了仓库：</p>
<p>点一下运行，看看最后的结果</p>
<p><img data-src="image-20220630143750474.png" /></p>
<h4 id="设置构建触发器">设置构建触发器</h4>
<p>这里选择轮训的方式：每隔5分钟拉一次，看看有没有更新，如果有更新了就继续运行下面的脚本。</p>
<p><img data-src="image-20220630143959280.png" /></p>
<h4 id="构建环境">构建环境</h4>
<p>这里根据自己的需要选择即可。</p>
<p><img data-src="image-20220630144212882.png" /></p>
<h4 id="构建">构建</h4>
<p>这里是整个流程的核心，这里运行bash脚本，执行生成博客静态文件的操作。</p>
<p>首先需要安装好nodejs，然后安装hexo博客工具，这里不再赘述。</p>
<p>这里有个小技巧：一般在主用户上设置的PATH环境变量上在jenkins用户是无法读取的，这里需要在节点配置上设置环境变量：</p>
<p><strong>系统管理→Configure System→环境变量</strong></p>
<p><img data-src="image-20220630153832331.png" /></p>
<p>构建脚本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$WORKSPACE</span></span><br><span class="line"><span class="built_in">cp</span> -r /temp/node_modules .</span><br><span class="line">hexo g</span><br><span class="line"><span class="keyword">if</span> [ $? -ne 0 ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;构建失败&quot;</span></span><br><span class="line">  <span class="built_in">exit</span> 255</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">git <span class="built_in">clone</span> https://xxx</span><br><span class="line"><span class="keyword">if</span> [ $? -ne 0 ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;克隆失败&quot;</span></span><br><span class="line">  <span class="built_in">exit</span> 255</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">cp</span> -r flyzstu.github.io/.git public</span><br><span class="line"><span class="keyword">if</span> [ $? -ne 0 ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;复制失败&quot;</span></span><br><span class="line">  <span class="built_in">exit</span> 255</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">cd</span> public</span><br><span class="line">git config user.name <span class="string">&quot;flyzstu&quot;</span></span><br><span class="line">git config user.email <span class="string">&quot;flyzstu@gmail.com&quot;</span></span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;Jenkins Service Auto Builder at <span class="subst">$(date +&#x27;%Y-%m-%d %H:%M:%S&#x27;)</span>&quot;</span></span><br><span class="line">git push --force --quiet</span><br><span class="line"><span class="keyword">if</span> [ $? -ne 0 ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;推送成功&quot;</span></span><br><span class="line">  <span class="built_in">exit</span> 255</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>这里分开构建，国外的使用github pages，国内使用又拍云。</p>
<p>将生成好的静态文件通过upx的cli命令上传到又拍云。</p>
<p>这里主要有一个bash脚本交互输入的用法。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$WORKSPACE</span>/public</span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;ServiceName\nOperator\nPassword&quot;</span> | upx login</span><br><span class="line"><span class="keyword">if</span> [ $? -ne 0 ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;登录失败&quot;</span></span><br><span class="line">  <span class="built_in">exit</span> 255</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">upx <span class="built_in">sync</span> --strong</span><br><span class="line"><span class="keyword">if</span> [ $? -ne 0 ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;推送UPYUN成功&quot;</span></span><br><span class="line">  <span class="built_in">exit</span> 255</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Headscale搭建开源版Tailscale服务端</title>
    <url>/p/build-opensource-tailscale-with-Headscale/</url>
    <content><![CDATA[<p>相信大家对wireguard已经不陌生了。作为一种搭建虚拟局域网的工具，相比于传统VPN而言，所有节点之间都可以进行P2P连接，也就是<strong>全互联模式</strong>，效率更高。而wireguard本身只是一个内核级别的模块，只是一个数据平面，至于上层更高级的功能（比如密钥交换机制，UDP打洞，ACL等），需要通过用户空间的应用来实现。</p>
<p>本文主要介绍Headscale和Tailscale。</p>
<p>本文与2023年9月10日第二次更新。</p>
<p>本文与2023年10月5日第三次更新。</p>
<span id="more"></span>
<h2 id="前言">前言</h2>
<p>为了基于wireguard实现更完美的VPN工具，现在已经出现了很多项目，如<strong>Netmaker</strong>，通过可视化界面来配置全互联模式，并支持UDP打洞、多租户等高端功能，几乎适配所有平台。然而现实世界是复杂的，无法保证所有的NAT都能打洞成功，而且Netmaker目前不支持fallback机制，如打洞失败，无法fallback中继节点。而Tailscale支持fallback，可以尽最大努力实现全互联模式，部分节点即使打洞不成功，也可通过中继节点在虚拟局域网内畅通无阻。</p>
<h2 id="什么是tailscale">什么是Tailscale</h2>
<p>Tailscale是一种基于Wireguard的虚拟组网工具，和Netmaker最大的区别是在用户态实现了wireguard协议，而netmaker直接实现了内核态的wireguard。想比内核态的wireguard性能会有些损失，但是功能性和易用性上完爆其他工具：</p>
<ol type="1">
<li>开箱即用
<ul>
<li>无需配置防火墙</li>
<li>没有额外的配置</li>
</ul></li>
<li>高安全性/私密性
<ul>
<li>自动密钥轮换</li>
<li>点对点连接</li>
<li>支持用户审查端到端的访问记录</li>
</ul></li>
<li>在原有的ICE、STUN等UDP协议外，还实现了DERP TCP协议来实现NAT穿透</li>
<li>基于公网的控制服务器下发ACL和配置，实现了节点动态更新</li>
<li>通过第三方（如Google）SSO服务生成用户和私钥，实现身份认证。</li>
</ol>
<p>我们可以将Tailscale视为更易用、功能更完善的Wireguard</p>
<h3 id="安装tailscale">安装Tailscale</h3>
<ol type="1">
<li>打开<a
href="https://login.tailscale.com/start">Tailscale官网</a></li>
</ol>
<p><img data-src="image-20220623104333360.png" /></p>
<ol start="2" type="1">
<li>在不付费的情况下只能通过SSO进行登陆。</li>
</ol>
<p><img data-src="image-20220623104430056.png" /></p>
<h4 id="mac-os客户端接入">Mac OS客户端接入</h4>
<ol start="3" type="1">
<li>安装Tailscale客户端，mac系统下可能需要一个美区的ID。</li>
</ol>
<p><img data-src="image-20220623104927641.png" /></p>
<ul>
<li>如果没有美区ID，还可以下载安装包直接安装，<a
href="https://pkgs.tailscale.com/stable/#macos">传送门</a></li>
</ul>
<blockquote>
<p>⚠️两种方式只能安装一种。</p>
</blockquote>
<ul>
<li>还可以安装开源命令行工具 <code>tailscale</code> 和
<code>tailscaled</code>，<a
href="https://github.com/tailscale/tailscale/wiki/Tailscaled-on-macOS">传送门</a></li>
</ul>
<p><strong>三种安装方式的比较</strong></p>
<table>
<colgroup>
<col style="width: 7%" />
<col style="width: 30%" />
<col style="width: 31%" />
<col style="width: 31%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;"></th>
<th style="text-align: left;">应用商店</th>
<th style="text-align: left;">独立应用</th>
<th>命令行版本</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">是否可用</td>
<td style="text-align: left;"><a
href="https://apps.apple.com/ca/app/tailscale/id1475387142">yes</a></td>
<td style="text-align: left;">yes, <a
href="https://tailscale.com/kb/1167/release-stages/#beta">beta</a></td>
<td><a
href="https://github.com/tailscale/tailscale/wiki/Tailscaled-on-macOS">yes</a></td>
</tr>
<tr class="even">
<td style="text-align: left;">图形界面</td>
<td style="text-align: left;">yes</td>
<td style="text-align: left;">yes</td>
<td>no; CLI</td>
</tr>
<tr class="odd">
<td style="text-align: left;">macOS 最低版本</td>
<td style="text-align: left;">macOS 10.13</td>
<td style="text-align: left;">macOS 10.15</td>
<td>macOS 10.13</td>
</tr>
<tr class="even">
<td style="text-align: left;">后台运行</td>
<td style="text-align: left;">no; sandboxed</td>
<td style="text-align: left;">理论上支持; 尚未实现</td>
<td>yes</td>
</tr>
<tr class="odd">
<td style="text-align: left;">使用的钥匙串🔑</td>
<td style="text-align: left;">用户级</td>
<td style="text-align: left;">系统级</td>
<td>直接存放在文件中</td>
</tr>
<tr class="even">
<td style="text-align: left;">沙盒隔离</td>
<td style="text-align: left;">yes</td>
<td style="text-align: left;">no</td>
<td>no</td>
</tr>
<tr class="odd">
<td style="text-align: left;">自动更新</td>
<td style="text-align: left;">yes; 应用商店直接更新</td>
<td style="text-align: left;">yes; <a
href="https://sparkle-project.org/">Sparkle</a></td>
<td>no</td>
</tr>
<tr class="even">
<td style="text-align: left;">是否开源</td>
<td style="text-align: left;">no</td>
<td style="text-align: left;">no</td>
<td>yes</td>
</tr>
<tr class="odd">
<td style="text-align: left;">MagicDNS</td>
<td style="text-align: left;">yes</td>
<td style="text-align: left;">yes</td>
<td>yes</td>
</tr>
<tr class="even">
<td style="text-align: left;">Taildrop</td>
<td style="text-align: left;">yes</td>
<td style="text-align: left;">yes</td>
<td>未实现</td>
</tr>
</tbody>
</table>
<ol start="4" type="1">
<li>登陆成功的页面</li>
</ol>
<p><img data-src="image-20220623110856825.png" /></p>
<ol start="5" type="1">
<li>查看后台</li>
</ol>
<p><img data-src="image-20220623111031877.png" /></p>
<h4 id="linux-客户端接入">Linux 客户端接入</h4>
<ol start="6" type="1">
<li><p>下载编译好的Linux客户端，<a
href="https://pkgs.tailscale.com/stable/#static">传送门</a></p></li>
<li><p>解压</p></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deepsoft01@deepsoft-desktop:~$ tar zxvf tailscale*.tgz</span><br><span class="line">tailscale_1.26.1_amd64/</span><br><span class="line">tailscale_1.26.1_amd64/tailscale</span><br><span class="line">tailscale_1.26.1_amd64/tailscaled</span><br><span class="line">tailscale_1.26.1_amd64/systemd/</span><br><span class="line">tailscale_1.26.1_amd64/systemd/tailscaled.defaults</span><br><span class="line">tailscale_1.26.1_amd64/systemd/tailscaled.service</span><br></pre></td></tr></table></figure>
<ol start="8" type="1">
<li>复制二进制文件到PATH目录</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo install tailscale*/tailscaled /usr/sbin/tailscaled</span><br><span class="line">sudo install tailscale*/tailscale /usr/local/bin/tailscale</span><br></pre></td></tr></table></figure>
<ol start="9" type="1">
<li>设置systemd单元文件</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">cp</span> tailscale*/systemd/tailscaled.service /lib/systemd/system/tailscaled.service</span><br></pre></td></tr></table></figure>
<ol start="10" type="1">
<li>设置环境变量配置文件</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">cp</span> tailscale*/systemd/tailscaled.defaults /etc/default/tailscaled</span><br></pre></td></tr></table></figure>
<ol start="11" type="1">
<li>启动tailscaled服务并设置开机自动启动</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> --now tailscaled</span><br></pre></td></tr></table></figure>
<ol start="12" type="1">
<li>查看服务启动状态</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl status tailscaled</span><br></pre></td></tr></table></figure>
<ol start="13" type="1">
<li>接入网络</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo tailscale up --accept-routes=<span class="literal">true</span> --accept-dns=<span class="literal">false</span> --advertise-routes=192.168.31.0/24 --authkey xxx</span><br></pre></td></tr></table></figure>
<ul>
<li><p>accept-routes：允许别的设备路由到此设备</p></li>
<li><p>advertise-routes：向所有设备通告本地路由</p></li>
<li><p>authkey：非交互接入的key，在控制台Setting可以添加</p></li>
</ul>
<ol start="14" type="1">
<li>查看网络接入状态</li>
</ol>
<p><img data-src="image-20220623121154338.png" /></p>
<h4 id="windows-客户端接入">Windows 客户端接入</h4>
<p>下载地址：https://pkgs.tailscale.com/stable/#static</p>
<h2 id="什么是headscale">什么是Headscale</h2>
<p>Tailscale是一款商用产品，对个人提供免费服务，就个人而言完全够用，但是后端服务器全在国外，而且免费用户只能使用SSO登陆，非常不方便。</p>
<p>有人认为Tailscale后台不开源也不透明，于是自行开发了一套后端，命名为Headscale。这套后端完全开源，可自行部署。</p>
<h3 id="部署headscale">部署Headscale</h3>
<p>项目地址：https://github.com/juanfont/headscale</p>
<blockquote>
<p>理论上说只要你的Headscale服务可以暴露到公网出口就行，但是不要有NAT，所以推荐部署到有公网IP的云主机上。</p>
</blockquote>
<h4 id="systemd部署">systemd部署</h4>
<ol type="1">
<li>下载服务端</li>
</ol>
<p>这里请根据服务器的架构进行选择</p>
<p>https://github.com/juanfont/headscale/</p>
<ol start="2" type="1">
<li>创建配置</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建文件夹</span></span><br><span class="line"><span class="built_in">mkdir</span> -p /etc/headscale</span><br><span class="line"><span class="comment"># 存储数据与证书</span></span><br><span class="line"><span class="built_in">touch</span> /var/lib/headscale/db.sqlite</span><br><span class="line"><span class="comment"># 创建空的sqlite文件</span></span><br><span class="line"><span class="built_in">touch</span> /var/lib/headscale/db.sqlite</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>创建Headscale配置文件</li>
</ol>
<p>配置文件的示例</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># headscale will look for a configuration file named `config.yaml` (or `config.json`) in the following order:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># - `/etc/headscale`</span></span><br><span class="line"><span class="comment"># - `~/.headscale`</span></span><br><span class="line"><span class="comment"># - current working directory</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The url clients will connect to.</span></span><br><span class="line"><span class="comment"># Typically this will be a domain like:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># https://myheadscale.example.com:443</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="attr">server_url:</span> <span class="string">http://127.0.0.1:8080</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Address to listen to / bind to on the server</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># For production:</span></span><br><span class="line"><span class="comment"># listen_addr: 0.0.0.0:8080</span></span><br><span class="line"><span class="attr">listen_addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8080</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Address to listen to /metrics, you may want</span></span><br><span class="line"><span class="comment"># to keep this endpoint private to your internal</span></span><br><span class="line"><span class="comment"># network</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="attr">metrics_listen_addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9090</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Address to listen for gRPC.</span></span><br><span class="line"><span class="comment"># gRPC is used for controlling a headscale server</span></span><br><span class="line"><span class="comment"># remotely with the CLI</span></span><br><span class="line"><span class="comment"># <span class="doctag">Note:</span> Remote access _only_ works if you have</span></span><br><span class="line"><span class="comment"># valid certificates.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># For production:</span></span><br><span class="line"><span class="comment"># grpc_listen_addr: 0.0.0.0:50443</span></span><br><span class="line"><span class="attr">grpc_listen_addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:50443</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Allow the gRPC admin interface to run in INSECURE</span></span><br><span class="line"><span class="comment"># mode. This is not recommended as the traffic will</span></span><br><span class="line"><span class="comment"># be unencrypted. Only enable if you know what you</span></span><br><span class="line"><span class="comment"># are doing.</span></span><br><span class="line"><span class="attr">grpc_allow_insecure:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Private key used to encrypt the traffic between headscale</span></span><br><span class="line"><span class="comment"># and Tailscale clients.</span></span><br><span class="line"><span class="comment"># The private key file will be autogenerated if it&#x27;s missing.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="attr">private_key_path:</span> <span class="string">/var/lib/headscale/private.key</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The Noise section includes specific configuration for the</span></span><br><span class="line"><span class="comment"># TS2021 Noise protocol</span></span><br><span class="line"><span class="attr">noise:</span></span><br><span class="line">  <span class="comment"># The Noise private key is used to encrypt the</span></span><br><span class="line">  <span class="comment"># traffic between headscale and Tailscale clients when</span></span><br><span class="line">  <span class="comment"># using the new Noise-based protocol. It must be different</span></span><br><span class="line">  <span class="comment"># from the legacy private key.</span></span><br><span class="line">  <span class="attr">private_key_path:</span> <span class="string">/var/lib/headscale/noise_private.key</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># List of IP prefixes to allocate tailaddresses from.</span></span><br><span class="line"><span class="comment"># Each prefix consists of either an IPv4 or IPv6 address,</span></span><br><span class="line"><span class="comment"># and the associated prefix length, delimited by a slash.</span></span><br><span class="line"><span class="comment"># It must be within IP ranges supported by the Tailscale</span></span><br><span class="line"><span class="comment"># client - i.e., subnets of 100.64.0.0/10 and fd7a:115c:a1e0::/48.</span></span><br><span class="line"><span class="comment"># See below:</span></span><br><span class="line"><span class="comment"># IPv6: https://github.com/tailscale/tailscale/blob/22ebb25e833264f58d7c3f534a8b166894a89536/net/tsaddr/tsaddr.go#LL81C52-L81C71</span></span><br><span class="line"><span class="comment"># IPv4: https://github.com/tailscale/tailscale/blob/22ebb25e833264f58d7c3f534a8b166894a89536/net/tsaddr/tsaddr.go#L33</span></span><br><span class="line"><span class="comment"># Any other range is NOT supported, and it will cause unexpected issues.</span></span><br><span class="line"><span class="attr">ip_prefixes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">fd7a:115c:a1e0::/48</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">100.64</span><span class="number">.0</span><span class="number">.0</span><span class="string">/10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># DERP is a relay system that Tailscale uses when a direct</span></span><br><span class="line"><span class="comment"># connection cannot be established.</span></span><br><span class="line"><span class="comment"># https://tailscale.com/blog/how-tailscale-works/#encrypted-tcp-relays-derp</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># headscale needs a list of DERP servers that can be presented</span></span><br><span class="line"><span class="comment"># to the clients.</span></span><br><span class="line"><span class="attr">derp:</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="comment"># If enabled, runs the embedded DERP server and merges it into the rest of the DERP config</span></span><br><span class="line">    <span class="comment"># The Headscale server_url defined above MUST be using https, DERP requires TLS to be in place</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Region ID to use for the embedded DERP server.</span></span><br><span class="line">    <span class="comment"># The local DERP prevails if the region ID collides with other region ID coming from</span></span><br><span class="line">    <span class="comment"># the regular DERP config.</span></span><br><span class="line">    <span class="attr">region_id:</span> <span class="number">999</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Region code and name are displayed in the Tailscale UI to identify a DERP region</span></span><br><span class="line">    <span class="attr">region_code:</span> <span class="string">&quot;headscale&quot;</span></span><br><span class="line">    <span class="attr">region_name:</span> <span class="string">&quot;Headscale Embedded DERP&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Listens over UDP at the configured address for STUN connections - to help with NAT traversal.</span></span><br><span class="line">    <span class="comment"># When the embedded DERP server is enabled stun_listen_addr MUST be defined.</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># For more details on how this works, check this great article: https://tailscale.com/blog/how-tailscale-works/</span></span><br><span class="line">    <span class="attr">stun_listen_addr:</span> <span class="string">&quot;0.0.0.0:3478&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># List of externally available DERP maps encoded in JSON</span></span><br><span class="line">  <span class="attr">urls:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">https://controlplane.tailscale.com/derpmap/default</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Locally available DERP map files encoded in YAML</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment"># This option is mostly interesting for people hosting</span></span><br><span class="line">  <span class="comment"># their own DERP servers:</span></span><br><span class="line">  <span class="comment"># https://tailscale.com/kb/1118/custom-derp-servers/</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment"># paths:</span></span><br><span class="line">  <span class="comment">#   - /etc/headscale/derp-example.yaml</span></span><br><span class="line">  <span class="attr">paths:</span> []</span><br><span class="line"></span><br><span class="line">  <span class="comment"># If enabled, a worker will be set up to periodically</span></span><br><span class="line">  <span class="comment"># refresh the given sources and update the derpmap</span></span><br><span class="line">  <span class="comment"># will be set up.</span></span><br><span class="line">  <span class="attr">auto_update_enabled:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># How often should we check for DERP updates?</span></span><br><span class="line">  <span class="attr">update_frequency:</span> <span class="string">24h</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Disables the automatic check for headscale updates on startup</span></span><br><span class="line"><span class="attr">disable_check_updates:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Time before an inactive ephemeral node is deleted?</span></span><br><span class="line"><span class="attr">ephemeral_node_inactivity_timeout:</span> <span class="string">30m</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Period to check for node updates within the tailnet. A value too low will severely affect</span></span><br><span class="line"><span class="comment"># CPU consumption of Headscale. A value too high (over 60s) will cause problems</span></span><br><span class="line"><span class="comment"># for the nodes, as they won&#x27;t get updates or keep alive messages frequently enough.</span></span><br><span class="line"><span class="comment"># In case of doubts, do not touch the default 10s.</span></span><br><span class="line"><span class="attr">node_update_check_interval:</span> <span class="string">10s</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SQLite config</span></span><br><span class="line"><span class="attr">db_type:</span> <span class="string">sqlite3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># For production:</span></span><br><span class="line"><span class="attr">db_path:</span> <span class="string">/var/lib/headscale/db.sqlite</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # Postgres config</span></span><br><span class="line"><span class="comment"># If using a Unix socket to connect to Postgres, set the socket path in the &#x27;host&#x27; field and leave &#x27;port&#x27; blank.</span></span><br><span class="line"><span class="comment"># db_type: postgres</span></span><br><span class="line"><span class="comment"># db_host: localhost</span></span><br><span class="line"><span class="comment"># db_port: 5432</span></span><br><span class="line"><span class="comment"># db_name: headscale</span></span><br><span class="line"><span class="comment"># db_user: foo</span></span><br><span class="line"><span class="comment"># db_pass: bar</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># If other &#x27;sslmode&#x27; is required instead of &#x27;require(true)&#x27; and &#x27;disabled(false)&#x27;, set the &#x27;sslmode&#x27; you need</span></span><br><span class="line"><span class="comment"># in the &#x27;db_ssl&#x27; field. Refers to https://www.postgresql.org/docs/current/libpq-ssl.html Table 34.1.</span></span><br><span class="line"><span class="comment"># db_ssl: false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### TLS configuration</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">## Let&#x27;s encrypt / ACME</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># headscale supports automatically requesting and setting up</span></span><br><span class="line"><span class="comment"># TLS for a domain with Let&#x27;s Encrypt.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># URL to ACME directory</span></span><br><span class="line"><span class="attr">acme_url:</span> <span class="string">https://acme-v02.api.letsencrypt.org/directory</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Email to register with ACME provider</span></span><br><span class="line"><span class="attr">acme_email:</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Domain name to request a TLS certificate for:</span></span><br><span class="line"><span class="attr">tls_letsencrypt_hostname:</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Path to store certificates and metadata needed by</span></span><br><span class="line"><span class="comment"># letsencrypt</span></span><br><span class="line"><span class="comment"># For production:</span></span><br><span class="line"><span class="attr">tls_letsencrypt_cache_dir:</span> <span class="string">/var/lib/headscale/cache</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Type of ACME challenge to use, currently supported types:</span></span><br><span class="line"><span class="comment"># HTTP-01 or TLS-ALPN-01</span></span><br><span class="line"><span class="comment"># See [docs/tls.md](docs/tls.md) for more information</span></span><br><span class="line"><span class="attr">tls_letsencrypt_challenge_type:</span> <span class="string">HTTP-01</span></span><br><span class="line"><span class="comment"># When HTTP-01 challenge is chosen, letsencrypt must set up a</span></span><br><span class="line"><span class="comment"># verification endpoint, and it will be listening on:</span></span><br><span class="line"><span class="comment"># :http = port 80</span></span><br><span class="line"><span class="attr">tls_letsencrypt_listen:</span> <span class="string">&quot;:http&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Use already defined certificates:</span></span><br><span class="line"><span class="attr">tls_cert_path:</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="attr">tls_key_path:</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">log:</span></span><br><span class="line">  <span class="comment"># Output formatting for logs: text or json</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">text</span></span><br><span class="line">  <span class="attr">level:</span> <span class="string">info</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Path to a file containg ACL policies.</span></span><br><span class="line"><span class="comment"># ACLs can be defined as YAML or HUJSON.</span></span><br><span class="line"><span class="comment"># https://tailscale.com/kb/1018/acls/</span></span><br><span class="line"><span class="attr">acl_policy_path:</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## DNS</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># headscale supports Tailscale&#x27;s DNS configuration and MagicDNS.</span></span><br><span class="line"><span class="comment"># Please have a look to their KB to better understand the concepts:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># - https://tailscale.com/kb/1054/dns/</span></span><br><span class="line"><span class="comment"># - https://tailscale.com/kb/1081/magicdns/</span></span><br><span class="line"><span class="comment"># - https://tailscale.com/blog/2021-09-private-dns-with-magicdns/</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="attr">dns_config:</span></span><br><span class="line">  <span class="comment"># Whether to prefer using Headscale provided DNS or use local.</span></span><br><span class="line">  <span class="attr">override_local_dns:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># List of DNS servers to expose to clients.</span></span><br><span class="line">  <span class="attr">nameservers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># NextDNS (see https://tailscale.com/kb/1218/nextdns/).</span></span><br><span class="line">  <span class="comment"># &quot;abc123&quot; is example NextDNS ID, replace with yours.</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment"># With metadata sharing:</span></span><br><span class="line">  <span class="comment"># nameservers:</span></span><br><span class="line">  <span class="comment">#   - https://dns.nextdns.io/abc123</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment"># Without metadata sharing:</span></span><br><span class="line">  <span class="comment"># nameservers:</span></span><br><span class="line">  <span class="comment">#   - 2a07:a8c0::ab:c123</span></span><br><span class="line">  <span class="comment">#   - 2a07:a8c1::ab:c123</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Split DNS (see https://tailscale.com/kb/1054/dns/),</span></span><br><span class="line">  <span class="comment"># list of search domains and the DNS to query for each one.</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment"># restricted_nameservers:</span></span><br><span class="line">  <span class="comment">#   foo.bar.com:</span></span><br><span class="line">  <span class="comment">#     - 1.1.1.1</span></span><br><span class="line">  <span class="comment">#   darp.headscale.net:</span></span><br><span class="line">  <span class="comment">#     - 1.1.1.1</span></span><br><span class="line">  <span class="comment">#     - 8.8.8.8</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Search domains to inject.</span></span><br><span class="line">  <span class="attr">domains:</span> []</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Extra DNS records</span></span><br><span class="line">  <span class="comment"># so far only A-records are supported (on the tailscale side)</span></span><br><span class="line">  <span class="comment"># See https://github.com/juanfont/headscale/blob/main/docs/dns-records.md#Limitations</span></span><br><span class="line">  <span class="comment"># extra_records:</span></span><br><span class="line">  <span class="comment">#   - name: &quot;grafana.myvpn.example.com&quot;</span></span><br><span class="line">  <span class="comment">#     type: &quot;A&quot;</span></span><br><span class="line">  <span class="comment">#     value: &quot;100.64.0.3&quot;</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment">#   # you can also put it in one line</span></span><br><span class="line">  <span class="comment">#   - &#123; name: &quot;prometheus.myvpn.example.com&quot;, type: &quot;A&quot;, value: &quot;100.64.0.3&quot; &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Whether to use [MagicDNS](https://tailscale.com/kb/1081/magicdns/).</span></span><br><span class="line">  <span class="comment"># Only works if there is at least a nameserver defined.</span></span><br><span class="line">  <span class="attr">magic_dns:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Defines the base domain to create the hostnames for MagicDNS.</span></span><br><span class="line">  <span class="comment"># `base_domain` must be a FQDNs, without the trailing dot.</span></span><br><span class="line">  <span class="comment"># The FQDN of the hosts will be</span></span><br><span class="line">  <span class="comment"># `hostname.user.base_domain` (e.g., _myhost.myuser.example.com_).</span></span><br><span class="line">  <span class="attr">base_domain:</span> <span class="string">example.com</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Unix socket used for the CLI to connect without authentication</span></span><br><span class="line"><span class="comment"># <span class="doctag">Note:</span> for production you will want to set this to something like:</span></span><br><span class="line"><span class="attr">unix_socket:</span> <span class="string">/var/run/headscale/headscale.sock</span></span><br><span class="line"><span class="attr">unix_socket_permission:</span> <span class="string">&quot;0770&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># headscale supports experimental OpenID connect support,</span></span><br><span class="line"><span class="comment"># it is still being tested and might have some bugs, please</span></span><br><span class="line"><span class="comment"># help us test it.</span></span><br><span class="line"><span class="comment"># OpenID Connect</span></span><br><span class="line"><span class="comment"># oidc:</span></span><br><span class="line"><span class="comment">#   only_start_if_oidc_is_available: true</span></span><br><span class="line"><span class="comment">#   issuer: &quot;https://your-oidc.issuer.com/path&quot;</span></span><br><span class="line"><span class="comment">#   client_id: &quot;your-oidc-client-id&quot;</span></span><br><span class="line"><span class="comment">#   client_secret: &quot;your-oidc-client-secret&quot;</span></span><br><span class="line"><span class="comment">#   # Alternatively, set `client_secret_path` to read the secret from the file.</span></span><br><span class="line"><span class="comment">#   # It resolves environment variables, making integration to systemd&#x27;s</span></span><br><span class="line"><span class="comment">#   # `LoadCredential` straightforward:</span></span><br><span class="line"><span class="comment">#   client_secret_path: &quot;$&#123;CREDENTIALS_DIRECTORY&#125;/oidc_client_secret&quot;</span></span><br><span class="line"><span class="comment">#   # client_secret and client_secret_path are mutually exclusive.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   # The amount of time from a node is authenticated with OpenID until it</span></span><br><span class="line"><span class="comment">#   # expires and needs to reauthenticate.</span></span><br><span class="line"><span class="comment">#   # Setting the value to &quot;0&quot; will mean no expiry.</span></span><br><span class="line"><span class="comment">#   expiry: 180d</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   # Use the expiry from the token received from OpenID when the user logged</span></span><br><span class="line"><span class="comment">#   # in, this will typically lead to frequent need to reauthenticate and should</span></span><br><span class="line"><span class="comment">#   # only been enabled if you know what you are doing.</span></span><br><span class="line"><span class="comment">#   # <span class="doctag">Note:</span> enabling this will cause `oidc.expiry` to be ignored.</span></span><br><span class="line"><span class="comment">#   use_expiry_from_token: false</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   # Customize the scopes used in the OIDC flow, defaults to &quot;openid&quot;, &quot;profile&quot; and &quot;email&quot; and add custom query</span></span><br><span class="line"><span class="comment">#   # parameters to the Authorize Endpoint request. Scopes default to &quot;openid&quot;, &quot;profile&quot; and &quot;email&quot;.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   scope: [&quot;openid&quot;, &quot;profile&quot;, &quot;email&quot;, &quot;custom&quot;]</span></span><br><span class="line"><span class="comment">#   extra_params:</span></span><br><span class="line"><span class="comment">#     domain_hint: example.com</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   # List allowed principal domains and/or users. If an authenticated user&#x27;s domain is not in this list, the</span></span><br><span class="line"><span class="comment">#   # authentication request will be rejected.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   allowed_domains:</span></span><br><span class="line"><span class="comment">#     - example.com</span></span><br><span class="line"><span class="comment">#   # <span class="doctag">Note:</span> Groups from keycloak have a leading &#x27;/&#x27;</span></span><br><span class="line"><span class="comment">#   allowed_groups:</span></span><br><span class="line"><span class="comment">#     - /headscale</span></span><br><span class="line"><span class="comment">#   allowed_users:</span></span><br><span class="line"><span class="comment">#     - alice@example.com</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   # If `strip_email_domain` is set to `true`, the domain part of the username email address will be removed.</span></span><br><span class="line"><span class="comment">#   # This will transform `first-name.last-name@example.com` to the user `first-name.last-name`</span></span><br><span class="line"><span class="comment">#   # If `strip_email_domain` is set to `false` the domain part will NOT be removed resulting to the following</span></span><br><span class="line"><span class="comment">#   user: `first-name.last-name.example.com`</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   strip_email_domain: true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Logtail configuration</span></span><br><span class="line"><span class="comment"># Logtail is Tailscales logging and auditing infrastructure, it allows the control panel</span></span><br><span class="line"><span class="comment"># to instruct tailscale nodes to log their activity to a remote server.</span></span><br><span class="line"><span class="attr">logtail:</span></span><br><span class="line">  <span class="comment"># Enable logtail for this headscales clients.</span></span><br><span class="line">  <span class="comment"># As there is currently no support for overriding the log server in headscale, this is</span></span><br><span class="line">  <span class="comment"># disabled by default. Enabling this will make your clients send logs to Tailscale Inc.</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Enabling this option makes devices prefer a random port for WireGuard traffic over the</span></span><br><span class="line"><span class="comment"># default static port 41641. This option is intended as a workaround for some buggy</span></span><br><span class="line"><span class="comment"># firewall devices. See https://tailscale.com/kb/1181/firewalls/ for more information.</span></span><br><span class="line"><span class="attr">randomize_client_port:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<ol start="6" type="1">
<li>下载配置文件</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://github.com/juanfont/headscale/raw/main/config-example.yaml -O /etc/headscale/config.yaml</span><br></pre></td></tr></table></figure>
<ul>
<li><p>修改配置文件，将<code>server_url</code>改为公网域名或者IP，国内服务器域名必须要备案；</p></li>
<li><p>如果暂时用不到DNS功能，可以将<code>magin_dns</code>设置为false；</p></li>
<li><p><code>server_url</code> 设置为
<code>http://&lt;PUBLIC_IP&gt;:8080</code>，将
<code>&lt;PUBLIC_IP&gt;</code> 替换为公网 IP 或者域名；</p></li>
<li><p><del>可自定义私有网段，也可同时开启 IPv4 和 IPv6</del>：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">ip_prefixes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">fd7a:115c:a1e0::/48</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">100.64</span><span class="number">.0</span><span class="number">.0</span><span class="string">/10</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="7" type="1">
<li>创建SystemD service配置文件</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/systemd/system/headscale.service</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=headscale controller</span><br><span class="line">After=syslog.target</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">User=headscale</span><br><span class="line">Group=headscale</span><br><span class="line">ExecStart=/usr/local/bin/headscale serve</span><br><span class="line">Restart=always</span><br><span class="line">RestartSec=5</span><br><span class="line"></span><br><span class="line"><span class="comment"># Optional security enhancements</span></span><br><span class="line">NoNewPrivileges=<span class="built_in">yes</span></span><br><span class="line">PrivateTmp=<span class="built_in">yes</span></span><br><span class="line">ProtectSystem=strict</span><br><span class="line">ProtectHome=<span class="built_in">yes</span></span><br><span class="line">ReadWritePaths=/var/lib/headscale /var/run/headscale</span><br><span class="line">AmbientCapabilities=CAP_NET_BIND_SERVICE</span><br><span class="line">RuntimeDirectory=headscale</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>
<ol start="8" type="1">
<li>创建headscale用户</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">useradd headscale -d /home/headscale -m</span><br></pre></td></tr></table></figure>
<ol start="9" type="1">
<li>修改配置文件的owner</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chown</span> -R headscale:headscale /var/lib/headscale</span><br></pre></td></tr></table></figure>
<ol start="10" type="1">
<li>创建必须的文件夹</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /var/run/headscale/</span><br></pre></td></tr></table></figure>
<ol start="12" type="1">
<li>修改配置文件unix_socket</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">unix_socket:</span> <span class="string">/var/run/headscale/headscale.sock</span></span><br></pre></td></tr></table></figure>
<ol start="13" type="1">
<li>重载新的配置文件</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br></pre></td></tr></table></figure>
<ol start="14" type="1">
<li>启动Headscale并设置开机自动启动</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> --now headscale</span><br></pre></td></tr></table></figure>
<ol start="15" type="1">
<li>查看运行状态</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl status headscale</span><br></pre></td></tr></table></figure>
<ol start="16" type="1">
<li>查看占用端口</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ss -tulnp|grep headscale</span><br></pre></td></tr></table></figure>
<ol start="17" type="1">
<li>创建namespace</li>
</ol>
<p>Tailscale中有有一个概念叫做tailnet，可以理解为租户。租户和租户之间是相互隔离的，具体可查看<a
href="https://tailscale.com/kb/1136/tailnet/">tailscale的官方文档</a>.</p>
<p><del>Headscale中也有类似的实现叫做namespace.</del></p>
<p>Headcale类似的实现叫做user.</p>
<p>需要先创建一个user，以便后续客户端接入。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">headscale <span class="built_in">users</span> create fly97</span><br></pre></td></tr></table></figure>
<ol start="18" type="1">
<li>查看命名空间</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">headscale namespaces list</span><br></pre></td></tr></table></figure>
<h4 id="docker-compose部署">docker-compose部署</h4>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">headscale:</span></span><br><span class="line">    <span class="attr">user:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">headscale/headscale</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">headscale</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">host</span></span><br><span class="line">    <span class="attr">cap_add:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CAP_NET_BIND_SERVICE</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">headscale</span> <span class="string">serve</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./config.yaml:/etc/headscale/config.yaml</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./db.sqlite:/var/lib/headscale/db.sqlite</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./ssl/221.12.170.100.crt:/221.12.170.100.crt</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./ssl/221.12.170.100.key:/221.12.170.100.key</span></span><br><span class="line">      <span class="comment">#- ./headscale.sock:/var/run/headscale.sock</span></span><br></pre></td></tr></table></figure>
<h3 id="接入headscale">接入Headscale</h3>
<h4 id="mac-os客户端接入-1">Mac OS客户端接入</h4>
<p>首先需要在服务端创建命名空间</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">headscale <span class="built_in">users</span> create fly97</span><br></pre></td></tr></table></figure>
<p>客户端下载参考Tailscale。</p>
<p>安装完毕以后打开<code>http://&lt;headscale_ip&gt;:&lt;port&gt;/apple</code>，会出现如下页面</p>
<p><img data-src="image-20220625140617764.png" /></p>
<p>按照上图所说，安装描述文件，然后重新打开Tailscale
APP，点击登录，会自动打开如下的页面：</p>
<p><img data-src="image-20220625140757424.png" /></p>
<p>在安装headscale的机器上，执行上面所示的命令，就可以把节点加入到网络中。</p>
<h4 id="linux-客户端接入-1">Linux 客户端接入</h4>
<p>首先在headscale生成api key，-n 用于指定命名空间</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">headscale preauthkeys create -e 24h -u fly97</span><br></pre></td></tr></table></figure>
<p>然后在tailscale客户端接入，将authkey替换成上文生成的key</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">login_server=http://xx.xx</span><br><span class="line">authkey=xxxx</span><br><span class="line">route=xxxx</span><br><span class="line">sudo tailscale up --login-server=<span class="variable">$&#123;login_server&#125;</span> --accept-routes=<span class="literal">false</span> --accept-dns=<span class="literal">false</span> --advertise-routes=<span class="variable">$route</span> --authkey <span class="variable">$&#123;authkey&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="打通局域网">打通局域网</h4>
<p>假设内网有一台 Linux 主机（比如 OpenWrt）安装了 Tailscale
客户端，希望其他 Tailscale 客户端可以直接通过家中的局域网 IP（例如
<strong>192.168.100.0/24</strong>） 访问内网的任何一台设备；</p>
<p>配置方法很简单，首先需要设置 IPv4 与 IPv6 路由转发：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;net.ipv4.ip_forward = 1&#x27;</span> | <span class="built_in">tee</span> /etc/sysctl.d/ipforwarding.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;net.ipv6.conf.all.forwarding = 1&#x27;</span> | <span class="built_in">tee</span> -a /etc/sysctl.d/ipforwarding.conf</span><br><span class="line">sysctl -p /etc/sysctl.d/ipforwarding.conf</span><br></pre></td></tr></table></figure>
<p>客户端修改注册节点的命令，在原来命令的基础上加上参数
<code>--advertise-routes=192.168.100.0/24</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">login_server=http://xx.xx</span><br><span class="line">authkey=xxxx</span><br><span class="line">route=xxxx</span><br><span class="line">sudo tailscale up --login-server=<span class="variable">$&#123;login_server&#125;</span> --accept-routes=<span class="literal">false</span> --accept-dns=<span class="literal">false</span> --advertise-routes=<span class="variable">$route</span> --authkey <span class="variable">$&#123;authkey&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>PS：这里不能加入accept-routes=true，这样会导致当前节点访问当前路由时，强制走derp-server的流量。</strong></p>
<p>在headscale服务端启动路由，首先需要查看要启用节点的id，假设这个id是1</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">headscale routes list</span><br></pre></td></tr></table></figure>
<p>根据ID启动路由</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">headscale routes <span class="built_in">enable</span> -i 1</span><br></pre></td></tr></table></figure>
<h4 id="windows-客户端接入-1">Windows 客户端接入</h4>
<p>访问以下连接</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https://&lt;headscale_ip&gt;:&lt;port&gt;/windows</span><br></pre></td></tr></table></figure>
<h3 id="一些常见的命令">一些常见的命令</h3>
<h4 id="查看链接状态">查看链接状态</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$tailscale</span> status </span><br><span class="line">192.168.7.1     mac-mini-bj4beb75    default      macOS   -</span><br><span class="line">                deepsoft-ci-0cf7bgtj default      linux   active; direct 221.12.170.99:41642; offline, tx 24760 rx 98248</span><br><span class="line">                deepsoft-desktop-xdcbicir default      linux   active; direct 221.12.170.98:41641; offline, tx 16404 rx 21900</span><br></pre></td></tr></table></figure>
<h4 id="查看darp连接">查看darp连接</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$tailscale</span> status </span><br><span class="line">2022/06/25 14:17:34 portmap: [v1] Got PMP response; IP:xxx, epoch: 683007</span><br><span class="line">2022/06/25 14:17:34 portmap: [v1] Got PCP response: epoch: 683007</span><br><span class="line">2022/06/25 14:17:34 portmap: [v1] UPnP reply &#123;Location:http://192.168.15.1:5000/rootDesc.xml Server:OpenWRT/5.10.107 UPnP/1.1 MiniUPnPd/2.2.3 USN:uuid:d38cfa50-cc98-48d8-8e37-2c97c660b8aa::urn:schemas-upnp-org:device:InternetGatewayDevice:2&#125;, <span class="string">&quot;HTTP/1.1 200 OK\r\nCACHE-CONTROL: max-age=120\r\nST: urn:schemas-upnp-org:device:InternetGatewayDevice:2\r\nUSN: uuid:d38cfa50-cc98-48d8-8e37-2c97c660b8aa::urn:schemas-upnp-org:device:InternetGatewayDevice:2\r\nEXT:\r\nSERVER: OpenWRT/5.10.107 UPnP/1.1 MiniUPnPd/2.2.3\r\nLOCATION: http://192.168.15.1:5000/rootDesc.xml\r\nOPT: \&quot;http://schemas.upnp.org/upnp/1/0/\&quot;; ns=01\r\n01-NLS: 1655692518\r\nBOOTID.UPNP.ORG: 1655692518\r\nCONFIGID.UPNP.ORG: 1337\r\n\r\n&quot;</span></span><br><span class="line">2022/06/25 14:17:34 portmap: UPnP meta changed: &#123;Location:http://192.168.15.1:5000/rootDesc.xml Server:OpenWRT/5.10.107 UPnP/1.1 MiniUPnPd/2.2.3 USN:uuid:d38cfa50-cc98-48d8-8e37-2c97c660b8aa::urn:schemas-upnp-org:device:InternetGatewayDevice:2&#125;</span><br><span class="line"></span><br><span class="line">Report:</span><br><span class="line">	* UDP: <span class="literal">false</span></span><br><span class="line">	* IPv4: (no addr found)</span><br><span class="line">	* IPv6: no</span><br><span class="line">	* MappingVariesByDestIP:</span><br><span class="line">	* HairPinning:</span><br><span class="line">	* PortMapping: UPnP, NAT-PMP, PCP</span><br><span class="line">	* Nearest DERP: unknown (no response to latency probes)</span><br></pre></td></tr></table></figure>
<p>由于我这里通过p2p打洞就建立了连接，同时没有导入Tailscale的中继节点，因此这里无法获得darp连接。</p>
<p>其他情况应该是</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tailscale netcheck</span><br><span class="line"></span><br><span class="line">Report:</span><br><span class="line">        * UDP: <span class="literal">true</span></span><br><span class="line">        * IPv4: <span class="built_in">yes</span>, xxxxx:57068</span><br><span class="line">        * IPv6: no</span><br><span class="line">        * MappingVariesByDestIP: <span class="literal">false</span></span><br><span class="line">        * HairPinning: <span class="literal">false</span></span><br><span class="line">        * PortMapping: </span><br><span class="line">        * Nearest DERP: Tencent Hongkong</span><br><span class="line">        * DERP latency:</span><br><span class="line">                - thk: 39.7ms (Tencent Hongkong)</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>wireguard</tag>
      </tags>
  </entry>
  <entry>
    <title>使用CoreDNS搭建DNS解析服务器</title>
    <url>/p/build-DNS-server-with-CoreDNS/</url>
    <content><![CDATA[<p>内网中物理机、<a
href="https://so.csdn.net/so/search?q=虚拟机&amp;spm=1001.2101.3001.7020">虚拟机</a>等设备较多，配置
hosts 文件太麻烦，因此想到利用一台设备搭建 DNS 服务器。</p>
<p>关键词：<strong>DNS</strong></p>
<span id="more"></span>
<h4 id="拉取镜像">拉取镜像</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull coredns/coredns</span><br></pre></td></tr></table></figure>
<h4 id="创建配置文件">创建配置文件</h4>
<ul>
<li>使用内部hosts</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line"># /etc/coredns/Corefile</span><br><span class="line">.:53 &#123;</span><br><span class="line">    hosts &#123;</span><br><span class="line">        10.0.0.1 xiexianbin.cn</span><br><span class="line">        fallthrough</span><br><span class="line">    &#125;</span><br><span class="line">    forward . 8.8.8.8:53 9.9.9.9</span><br><span class="line">    log</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用外部hosts</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># /etc/coredns/Corefile</span><br><span class="line">.:53 &#123;</span><br><span class="line">    hosts /etc/coredns/hosts &#123;</span><br><span class="line">        fallthrough</span><br><span class="line">    &#125;</span><br><span class="line">    forward . 8.8.8.8:53 9.9.9.9</span><br><span class="line">    log</span><br><span class="line">&#125;</span><br><span class="line"># cat hosts</span><br><span class="line">10.0.0.1 xiexianbin.cn</span><br></pre></td></tr></table></figure>
<ul>
<li>将所有 <code>lo</code> 域名根据同一目录下的 hosts 文件解析</li>
<li>所有其他的域名转发到 DNS 服务器 202.96.128.86:53</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line"># /Corefile</span><br><span class="line">lo:53 &#123;</span><br><span class="line">    hosts /etc/coredns/hosts</span><br><span class="line">    log</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.:53 &#123;</span><br><span class="line">    forward . 202.96.128.86:53</span><br><span class="line">    log</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="部署yaml">部署yaml</h4>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">coreDNS:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">coredns/coredns</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">coredns</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./Corefile:/Corefile</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">53</span><span class="string">:53/udp</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>DNS</tag>
      </tags>
  </entry>
  <entry>
    <title>DevOps实战（一）使用Docker搭建Gitlab社区版</title>
    <url>/p/install-gitlab-with-docker/</url>
    <content><![CDATA[<p>什么是DevOps？</p>
<p>DevOps的哲学暂且不表，本文主要介绍如何使用Docker搭建Gitlab。</p>
<p>关键词：<strong>gitlab</strong></p>
<span id="more"></span>
<h2 id="前言">前言</h2>
<p>docker作为快速部署应用的方式已经迅速流行起来，极大的解放了运维人员的工作。</p>
<h2 id="安装">安装</h2>
<h3 id="下载镜像">下载镜像</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull gitlab/gitlab-ce:latest</span><br></pre></td></tr></table></figure>
<h3 id="docker-compose部署文件">docker-compose部署文件</h3>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.6&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">gitlab:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">&#x27;gitlab/gitlab-ee:latest&#x27;</span></span><br><span class="line">    <span class="comment"># image: registry.gitlab.cn/omnibus/gitlab-jh:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">gitlab</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">&#x27;gitlab.lo&#x27;</span>                          <span class="comment"># ssh hostname</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">       <span class="attr">GITLAB_OMNIBUS_CONFIG:</span> <span class="string">|</span></span><br><span class="line"><span class="string">         external_url &#x27;https://gitlab.lo&#x27;          # git httpsname</span></span><br><span class="line"><span class="string">         nginx[&#x27;redirect_http_to_https&#x27;] = false   </span></span><br><span class="line"><span class="string">         nginx[&#x27;listen_port&#x27;] = 8880</span></span><br><span class="line"><span class="string">         nginx[&#x27;listen_https&#x27;] = false</span></span><br><span class="line"><span class="string">         prometheus_monitoring[&#x27;enable&#x27;] = false</span></span><br><span class="line"><span class="string"></span>    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;127.0.0.1:8880:8880&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;22:22&#x27;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;./config:/etc/gitlab&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;./logs:/var/log/gitlab&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;./data:/var/opt/gitlab&#x27;</span></span><br><span class="line">    <span class="attr">shm_size:</span> <span class="string">&#x27;256m&#x27;</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h3 id="nginx反向代理文件">Nginx反向代理文件</h3>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"> <span class="section">server</span> &#123;</span><br><span class="line">   <span class="attribute">charset</span> utf-<span class="number">8</span>;</span><br><span class="line">   <span class="comment">#listen unix:/dev/shm/default.sock proxy_protocol;</span></span><br><span class="line">   <span class="comment">#listen unix:/dev/shm/h2c.sock http2 proxy_protocol;</span></span><br><span class="line">   <span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line">   <span class="attribute">server_tokens</span> <span class="literal">off</span>;</span><br><span class="line">   <span class="attribute">server_name</span> gitlab.lo;</span><br><span class="line">   <span class="attribute">ssl_session_cache</span> shared:SSL:<span class="number">10m</span>;</span><br><span class="line">   <span class="attribute">ssl_certificate</span>     /ssl/gitlab.lo.crt;</span><br><span class="line">   <span class="attribute">ssl_certificate_key</span>  /ssl/gitlab.lo.key;</span><br><span class="line"></span><br><span class="line">   <span class="comment">#ssl_stapling on;</span></span><br><span class="line">   <span class="comment">#ssl_stapling_verify on;</span></span><br><span class="line"></span><br><span class="line">   <span class="attribute">ssl_session_timeout</span> <span class="number">10m</span>;</span><br><span class="line">   <span class="attribute">ssl_ciphers</span> HIGH:!aNULL:!MD5;</span><br><span class="line">   <span class="attribute">ssl_prefer_server_ciphers</span> <span class="literal">on</span>;</span><br><span class="line">   <span class="attribute">ssl_protocols</span> TLSv1 TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span> TLSv1.<span class="number">3</span>;</span><br><span class="line">   <span class="section">location</span> / &#123;</span><br><span class="line">     <span class="comment">#proxy_redirect off;</span></span><br><span class="line">     <span class="comment">#proxy_pass https://wf09.github.io/;</span></span><br><span class="line">     <span class="comment">#alias /home/ubuntu/tmp/;</span></span><br><span class="line">      <span class="attribute">proxy_pass</span> http://127.0.0.1:8880;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>; <span class="comment"># required for docker client&#x27;s sake</span></span><br><span class="line">      <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>; <span class="comment"># pass on real client&#x27;s IP</span></span><br><span class="line">      <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">      <span class="attribute">proxy_set_header</span> X-Forwarded-Proto <span class="variable">$scheme</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="其他操作">其他操作</h2>
<h3 id="查看root用户密码">查看root用户密码</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it gitlab grep <span class="string">&#x27;Password:&#x27;</span> /etc/gitlab/initial_root_password</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>gitlab</tag>
        <tag>devops</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes集群实践（六）使用k3s创建一个轻量级k8s集群</title>
    <url>/p/create-a-lightweight-k8s-cluster-with-k3s/</url>
    <content><![CDATA[<p>什么是K3s？</p>
<p>K3s 是一个轻量级的 Kubernetes
发行版，它针对边缘计算、物联网等场景进行了高度优化。为了最大化的利用设备，于是我选择了k3s作为在嵌入式设备上使用的kubernetes集群。</p>
<p>本文主要介绍如何使用k3s创建一个轻量级的k8s集群。</p>
<p>关键词：<strong>k3s</strong></p>
<span id="more"></span>
<h2 id="准备工作">准备工作</h2>
<ul>
<li>Ubuntu 20.04 LTS amd64，32GB，作为Master节点</li>
<li>Ubuntu 18.04 LTS arm64，8GB，作为Worker节点</li>
</ul>
<h3 id="使用wireguard创建虚拟局域网">使用Wireguard创建虚拟局域网</h3>
<p>使用wireguard 创建无感知的虚拟局域网，降低跨网段组网的难度。</p>
<p>具体请参考我的另外一篇文章<a
href="https://fly97.cn/p/create-a-virtual-local-area-network-with-wireguard">使用WireGuard组建虚拟局域网</a>.</p>
<h3 id="安装ipvs所需要的模块">安装IPVS所需要的模块</h3>
<p>ipvs网络模式比iptables具有更优秀的性能</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &lt;&lt;<span class="string">EOF | sudo tee /etc/modules-load.d/k3s.conf</span></span><br><span class="line"><span class="string">ip_vs</span></span><br><span class="line"><span class="string">ip_vs_lc</span></span><br><span class="line"><span class="string">ip_vs_rr</span></span><br><span class="line"><span class="string">ip_vs_wrr</span></span><br><span class="line"><span class="string">ip_vs_sh</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>
<p>实时加载模块</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo modprobe ip_vs</span><br><span class="line">sudo modprobe ip_vs_lc</span><br><span class="line">sudo modprobe ip_vs_rr</span><br><span class="line">sudo modprobe ip_vs_wrr</span><br><span class="line">sudo modprobe ip_vs_sh</span><br></pre></td></tr></table></figure>
<p>安装查看ipvs表软件包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install ipvsadm -y</span><br></pre></td></tr></table></figure>
<p>服务起来以后，可以执行以下命令查看ipvs规则</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ipvsadm -<span class="built_in">ln</span></span><br></pre></td></tr></table></figure>
<h2 id="安装master节点">安装master节点</h2>
<p><del>国内用户可以使用</del></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -sfL https://rancher-mirror.rancher.cn/k3s/k3s-install.sh | INSTALL_K3S_MIRROR=cn sh -</span><br></pre></td></tr></table></figure>
<p>上述网页由于未知原因挂掉了</p>
<p>最新地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -sfL https://rancher-mirror.oss-cn-beijing.aliyuncs.com/k3s/k3s-install.sh | INSTALL_K3S_MIRROR=cn sh -</span><br></pre></td></tr></table></figure>
<p>国际用户使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -sfL https://get.k3s.io | sh -    </span><br></pre></td></tr></table></figure>
<p>可以指定环境变量，在管道之后传递：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -sfL https://get.k3s.io | INSTALL_K3S_CHANNEL=latest sh -</span><br></pre></td></tr></table></figure>
<p>下面是flag的含义</p>
<table>
<colgroup>
<col style="width: 26%" />
<col style="width: 73%" />
</colgroup>
<thead>
<tr class="header">
<th>FLAG</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>--node-ip value, -i</code> value</td>
<td>为节点发布的 IP 地址</td>
</tr>
<tr class="even">
<td><code>--node-external-ip</code> value</td>
<td>对外发布节点的 IP 地址</td>
</tr>
<tr class="odd">
<td><code>--flannel-iface</code> value</td>
<td>覆盖默认的 flannel 接口</td>
</tr>
<tr class="even">
<td><code>--no-deploy</code> value</td>
<td>不需要部署的组件 (有效选项: coredns, servicelb, traefik,
local-storage, metrics-server)</td>
</tr>
<tr class="odd">
<td><code>--kube-proxy-arg</code> value</td>
<td>自定义 kube-proxy 进程的参数</td>
</tr>
<tr class="even">
<td><code>--write-kubeconfig-mode</code></td>
<td>更改kubeconfig的权限</td>
</tr>
<tr class="odd">
<td><code>--flannel-backend</code> value</td>
<td>更改flannel后端模式</td>
</tr>
</tbody>
</table>
<p>编辑下面的service单元文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/systemd/system/k3s.service</span><br></pre></td></tr></table></figure>
<p>如下图所示</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">....</span><br><span class="line">ExecStart=/usr/local/bin/k3s agent --node-ip 192.168.8.238 --node-external-ip 192.168.8.238 --flannel-iface eth0 --write-kubeconfig-mode 644 --kube-proxy-arg <span class="string">&#x27;proxy-mode=ipvs&#x27;</span> --kube-proxy-arg <span class="string">&#x27;ipvs-scheduler=rr&#x27;</span> --kube-proxy-arg <span class="string">&#x27;masquerade-all=true&#x27;</span> --kube-proxy-arg <span class="string">&#x27;metrics-bind-address=0.0.0.0:10249</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure>
<h2 id="安装worker节点">安装worker节点</h2>
<p>在master节点上运行以下命令，获取加入集群的token</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /var/lib/rancher/k3s/server/node-token</span><br></pre></td></tr></table></figure>
<p>国内环境执行以下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -sfL https://rancher-mirror.rancher.cn/k3s/k3s-install.sh | INSTALL_K3S_MIRROR=cn K3S_TOKEN=<span class="string">&quot;xxx&quot;</span> K3S_URL=https://192.168.7.2:6443 sh -</span><br></pre></td></tr></table></figure>
<p>其中环境变量INSTALL_K3S_EXEC可以按照下面设置</p>
<p>也可以编辑下面的service单元文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/systemd/system/k3s-agent.service</span><br></pre></td></tr></table></figure>
<p>如下图所示</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">....</span><br><span class="line">ExecStart=/usr/local/bin/k3s agent --node-ip 192.168.8.238 --node-external-ip 192.168.8.238 --flannel-iface eth0 --write-kubeconfig-mode 644 --kube-proxy-arg <span class="string">&#x27;proxy-mode=ipvs&#x27;</span> --kube-proxy-arg <span class="string">&#x27;ipvs-scheduler=rr&#x27;</span> --kube-proxy-arg <span class="string">&#x27;masquerade-all=true&#x27;</span> --kube-proxy-arg <span class="string">&#x27;metrics-bind-address=0.0.0.0:10249</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure>
<h2 id="检查集群是否安装成功">检查集群是否安装成功</h2>
<h3 id="检查k3s是否安装成功">检查k3s是否安装成功</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl status k3s</span><br></pre></td></tr></table></figure>
<h3 id="检查node状态">检查node状态</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo kubectl get node -A</span><br></pre></td></tr></table></figure>
<h2 id="k3s配置私有镜像">k3s配置私有镜像</h2>
<p>创建配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/rancher/k3s/registries.yaml</span><br></pre></td></tr></table></figure>
<p>配置文件格式如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mirrors:</span></span><br><span class="line">  <span class="attr">docker.io:</span></span><br><span class="line">    <span class="attr">endpoint:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;https://hub.deepsoft-tech.com&quot;</span></span><br><span class="line">  <span class="attr">k8s.gcr.io:</span></span><br><span class="line">    <span class="attr">endpoint:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;https://hub.deepsoft-tech.com&quot;</span></span><br><span class="line">  <span class="attr">registry.k8s.io:</span></span><br><span class="line">    <span class="attr">endpoint:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;https://hub.deepsoft-tech.com&quot;</span></span><br><span class="line">  <span class="attr">quay.io:</span></span><br><span class="line">    <span class="attr">endpoint:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;https://hub.deepsoft-tech.com&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="高可用的k3s集群">高可用的K3s集群</h2>
<p>从 v1.19.5+k3s1 版本开始，K3s 已添加了对嵌入式 etcd
的完全支持。从此版本开始，支持嵌入式etcd的高可用。</p>
<h3 id="新集群">新集群</h3>
<p>首先新集群不能有之前集群的数据，最好是从新安装一个集群。</p>
<p>要在这种模式下运行 K3s，你必须有奇数的 server
节点。我们建议从三个节点开始。</p>
<p>要开始运行，首先启动一个 server
节点，使用<code>cluster-init</code>标志来启用集群，并带有其他标志位。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -sfL https://rancher-mirror.oss-cn-beijing.aliyuncs.com/k3s/k3s-install.sh | INSTALL_K3S_MIRROR=cn sh -s - server --cluster-init --kube-proxy-arg=<span class="string">&#x27;metrics-bind-address=0.0.0.0:10249&#x27;</span> --flannel-backend=host-gw  --write-kubeconfig-mode=644 --bind-address=192.168.31.29</span><br></pre></td></tr></table></figure>
<p>启动第一台集群以后，使用共享密钥将第二台和第三台server加入集群。注意<code>--server</code>参数，指向的是第一个启动master节点的控制平面</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -sfL https://rancher-mirror.oss-cn-beijing.aliyuncs.com/k3s/k3s-install.sh | INSTALL_K3S_MIRROR=cn K3S_TOKEN=xxx sh -s server --server=https://192.168.31.29:6443 --kube-proxy-arg=<span class="string">&#x27;metrics-bind-address=0.0.0.0:10249&#x27;</span> --flannel-backend=host-gw  --write-kubeconfig-mode=644 --bind-address=192.168.31.113</span><br></pre></td></tr></table></figure>
<h2 id="为k3s启用cuda支持">为K3s启用CUDA支持</h2>
<h3 id="containerd设置">containerd设置</h3>
<p>根据以下网址：<a
href="https://k3d.io/v5.4.1/usage/advanced/cuda/">Running CUDA workloads
- k3d</a></p>
<p>拷贝以下模板到：<code>/var/lib/rancher/k3s/agent/etc/containerd/config.toml.tmpl</code></p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[plugins.opt]</span></span><br><span class="line">  <span class="attr">path</span> = <span class="string">&quot;&#123;&#123; .NodeConfig.Containerd.Opt &#125;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[plugins.cri]</span></span><br><span class="line">  <span class="attr">stream_server_address</span> = <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">  <span class="attr">stream_server_port</span> = <span class="string">&quot;10010&quot;</span></span><br><span class="line"></span><br><span class="line">&#123;&#123;- if .IsRunningInUserNS &#125;&#125;</span><br><span class="line">  <span class="attr">disable_cgroup</span> = <span class="literal">true</span></span><br><span class="line">  <span class="attr">disable_apparmor</span> = <span class="literal">true</span></span><br><span class="line">  <span class="attr">restrict_oom_score_adj</span> = <span class="literal">true</span></span><br><span class="line">&#123;&#123;end&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;- if .NodeConfig.AgentConfig.PauseImage &#125;&#125;</span><br><span class="line">  <span class="attr">sandbox_image</span> = <span class="string">&quot;&#123;&#123; .NodeConfig.AgentConfig.PauseImage &#125;&#125;&quot;</span></span><br><span class="line">&#123;&#123;end&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;- if not .NodeConfig.NoFlannel &#125;&#125;</span><br><span class="line"><span class="section">[plugins.cri.cni]</span></span><br><span class="line">  <span class="attr">bin_dir</span> = <span class="string">&quot;&#123;&#123; .NodeConfig.AgentConfig.CNIBinDir &#125;&#125;&quot;</span></span><br><span class="line">  <span class="attr">conf_dir</span> = <span class="string">&quot;&#123;&#123; .NodeConfig.AgentConfig.CNIConfDir &#125;&#125;&quot;</span></span><br><span class="line">&#123;&#123;end&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">[plugins.cri.containerd.runtimes.runc]</span></span><br><span class="line">  <span class="comment"># ---- changed from &#x27;io.containerd.runc.v2&#x27; for GPU support</span></span><br><span class="line">  <span class="attr">runtime_type</span> = <span class="string">&quot;io.containerd.runtime.v1.linux&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---- added for GPU support</span></span><br><span class="line"><span class="section">[plugins.linux]</span></span><br><span class="line">  <span class="attr">runtime</span> = <span class="string">&quot;nvidia-container-runtime&quot;</span></span><br><span class="line"></span><br><span class="line">&#123;&#123; if .PrivateRegistryConfig &#125;&#125;</span><br><span class="line">&#123;&#123; if .PrivateRegistryConfig.Mirrors &#125;&#125;</span><br><span class="line"><span class="section">[plugins.cri.registry.mirrors]</span>&#123;&#123;end&#125;&#125;</span><br><span class="line">&#123;&#123;range $k, $v := .PrivateRegistryConfig.Mirrors &#125;&#125;</span><br><span class="line"><span class="section">[plugins.cri.registry.mirrors.&quot;&#123;&#123;$k&#125;&#125;&quot;]</span></span><br><span class="line">  <span class="attr">endpoint</span> = [&#123;&#123;range <span class="variable">$i</span>, <span class="variable">$j</span> := <span class="variable">$v</span>.Endpoints&#125;&#125;&#123;&#123;if <span class="variable">$i</span>&#125;&#125;, &#123;&#123;end&#125;&#125;&#123;&#123;printf <span class="string">&quot;%q&quot;</span> .&#125;&#125;&#123;&#123;end&#125;&#125;]</span><br><span class="line">&#123;&#123;end&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;range $k, $v := .PrivateRegistryConfig.Configs &#125;&#125;</span><br><span class="line">&#123;&#123; if $v.Auth &#125;&#125;</span><br><span class="line"><span class="section">[plugins.cri.registry.configs.&quot;&#123;&#123;$k&#125;&#125;&quot;.auth]</span></span><br><span class="line">  &#123;&#123; if $v.Auth.Username &#125;&#125;<span class="attr">username</span> = <span class="string">&quot;&#123;&#123; $v.Auth.Username &#125;&#125;&quot;</span>&#123;&#123;end&#125;&#125;</span><br><span class="line">  &#123;&#123; if $v.Auth.Password &#125;&#125;<span class="attr">password</span> = <span class="string">&quot;&#123;&#123; $v.Auth.Password &#125;&#125;&quot;</span>&#123;&#123;end&#125;&#125;</span><br><span class="line">  &#123;&#123; if $v.Auth.Auth &#125;&#125;<span class="attr">auth</span> = <span class="string">&quot;&#123;&#123; $v.Auth.Auth &#125;&#125;&quot;</span>&#123;&#123;end&#125;&#125;</span><br><span class="line">  &#123;&#123; if $v.Auth.IdentityToken &#125;&#125;<span class="attr">identitytoken</span> = <span class="string">&quot;&#123;&#123; $v.Auth.IdentityToken &#125;&#125;&quot;</span>&#123;&#123;end&#125;&#125;</span><br><span class="line">&#123;&#123;end&#125;&#125;</span><br><span class="line">&#123;&#123; if $v.TLS &#125;&#125;</span><br><span class="line"><span class="section">[plugins.cri.registry.configs.&quot;&#123;&#123;$k&#125;&#125;&quot;.tls]</span></span><br><span class="line">  &#123;&#123; if $v.TLS.CAFile &#125;&#125;<span class="attr">ca_file</span> = <span class="string">&quot;&#123;&#123; $v.TLS.CAFile &#125;&#125;&quot;</span>&#123;&#123;end&#125;&#125;</span><br><span class="line">  &#123;&#123; if $v.TLS.CertFile &#125;&#125;<span class="attr">cert_file</span> = <span class="string">&quot;&#123;&#123; $v.TLS.CertFile &#125;&#125;&quot;</span>&#123;&#123;end&#125;&#125;</span><br><span class="line">  &#123;&#123; if $v.TLS.KeyFile &#125;&#125;<span class="attr">key_file</span> = <span class="string">&quot;&#123;&#123; $v.TLS.KeyFile &#125;&#125;&quot;</span>&#123;&#123;end&#125;&#125;</span><br><span class="line">&#123;&#123;end&#125;&#125;</span><br><span class="line">&#123;&#123;end&#125;&#125;</span><br><span class="line">&#123;&#123;end&#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="安装nvidia-cuda-插件">安装Nvidia CUDA 插件</h3>
<p>安装以下资源清单</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Copyright (c) 2019, NVIDIA CORPORATION.  All rights reserved.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span><br><span class="line"><span class="comment"># you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment"># You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line"><span class="comment"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"># See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"># limitations under the License.</span></span><br><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nvidia-device-plugin-daemonset</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">nvidia-device-plugin-ds</span></span><br><span class="line">  <span class="attr">updateStrategy:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">RollingUpdate</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">nvidia-device-plugin-ds</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">tolerations:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">nvidia.com/gpu</span></span><br><span class="line">        <span class="attr">operator:</span> <span class="string">Exists</span></span><br><span class="line">        <span class="attr">effect:</span> <span class="string">NoSchedule</span></span><br><span class="line">      <span class="comment"># Mark this pod as a critical add-on; when enabled, the critical add-on</span></span><br><span class="line">      <span class="comment"># scheduler reserves resources for critical add-on pods so that they can</span></span><br><span class="line">      <span class="comment"># be rescheduled after a failure.</span></span><br><span class="line">      <span class="comment"># See https://kubernetes.io/docs/tasks/administer-cluster/guaranteed-scheduling-critical-addon-pods/</span></span><br><span class="line">      <span class="attr">priorityClassName:</span> <span class="string">&quot;system-node-critical&quot;</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nvcr.io/nvidia/k8s-device-plugin:v0.12.2</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">nvidia-device-plugin-ctr</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">FAIL_ON_INIT_ERROR</span></span><br><span class="line">            <span class="attr">value:</span> <span class="string">&quot;false&quot;</span></span><br><span class="line">        <span class="attr">securityContext:</span></span><br><span class="line">          <span class="attr">allowPrivilegeEscalation:</span> <span class="literal">false</span></span><br><span class="line">          <span class="attr">capabilities:</span></span><br><span class="line">            <span class="attr">drop:</span> [<span class="string">&quot;ALL&quot;</span>]</span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">device-plugin</span></span><br><span class="line">            <span class="attr">mountPath:</span> <span class="string">/var/lib/kubelet/device-plugins</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">device-plugin</span></span><br><span class="line">          <span class="attr">hostPath:</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/var/lib/kubelet/device-plugins</span></span><br></pre></td></tr></table></figure>
<p>在Pod模板下添加以下选项以指定节点安装DaemonSet插件</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nvidia-device-plugin-daemonset</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">nvidia-device-plugin-ds</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">nodeSelector:</span></span><br><span class="line">        <span class="attr">gpu:</span> <span class="string">nvidia-2080-ti</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure>
<p>将以上资源清单提交到以后api-server后，查看是否执行成功</p>
<p><img data-src="使用k3s创建一个轻量级k8s集群/2022-08-08-18-38-54-image.png" /></p>
<p>根据NAME查看log</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">kube-system</span> <span class="string">logs</span> <span class="string">nvidia-device-plugin-daemonset-c7d9m</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2022/08/08 10:01:16 Starting FS watcher.</span><br><span class="line">2022/08/08 10:01:16 Starting OS watcher.</span><br><span class="line">2022/08/08 10:01:16 Starting Plugins.</span><br><span class="line">2022/08/08 10:01:16 Loading configuration.</span><br><span class="line">2022/08/08 10:01:16 Initializing NVML.</span><br><span class="line">2022/08/08 10:01:16 Updating config with default resource matching patterns.</span><br><span class="line">2022/08/08 10:01:16</span><br><span class="line">Running with config:</span><br><span class="line">&#123;</span><br><span class="line">  &quot;version&quot;: &quot;v1&quot;,</span><br><span class="line">  &quot;flags&quot;: &#123;</span><br><span class="line">    &quot;migStrategy&quot;: &quot;none&quot;,</span><br><span class="line">    &quot;failOnInitError&quot;: false,</span><br><span class="line">    &quot;nvidiaDriverRoot&quot;: &quot;/&quot;,</span><br><span class="line">    &quot;plugin&quot;: &#123;</span><br><span class="line">      &quot;passDeviceSpecs&quot;: false,</span><br><span class="line">      &quot;deviceListStrategy&quot;: &quot;envvar&quot;,</span><br><span class="line">      &quot;deviceIDStrategy&quot;: &quot;uuid&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;resources&quot;: &#123;</span><br><span class="line">    &quot;gpus&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;pattern&quot;: &quot;*&quot;,</span><br><span class="line">        &quot;name&quot;: &quot;nvidia.com/gpu&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;sharing&quot;: &#123;</span><br><span class="line">    &quot;timeSlicing&quot;: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">2022/08/08 10:01:16 Retreiving plugins.</span><br><span class="line">2022/08/08 10:01:16 Starting GRPC server for &#x27;nvidia.com/gpu&#x27;</span><br><span class="line">2022/08/08 10:01:16 Starting to serve &#x27;nvidia.com/gpu&#x27; on /var/lib/kubelet/device-plugins/nvidia-gpu.sock</span><br><span class="line">2022/08/08 10:01:16 Registered device plugin for &#x27;nvidia.com/gpu&#x27; with Kubelet</span><br></pre></td></tr></table></figure>
<h3 id="控制平面查看节点信息">控制平面查看节点信息</h3>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">kubectl</span> <span class="string">describe</span> <span class="string">nodes</span> <span class="string">pve-2080-ti</span></span><br></pre></td></tr></table></figure>
<p><img data-src="使用k3s创建一个轻量级k8s集群/2022-08-08-18-49-21-image.png" /></p>
<h3 id="执行gpu任务">执行GPU任务</h3>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">gpu-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">Never</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cuda-container</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">nvcr.io/nvidia/k8s/cuda-sample:vectoradd-cuda10.2</span></span><br><span class="line">      <span class="attr">resources:</span></span><br><span class="line">        <span class="attr">limits:</span></span><br><span class="line">          <span class="attr">nvidia.com/gpu:</span> <span class="number">1</span> <span class="comment"># requesting 1 GPU</span></span><br><span class="line">  <span class="attr">tolerations:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">nvidia.com/gpu</span></span><br><span class="line">    <span class="attr">operator:</span> <span class="string">Exists</span></span><br><span class="line">    <span class="attr">effect:</span> <span class="string">NoSchedule</span></span><br></pre></td></tr></table></figure>
<p>查看执行的日志</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wf09@amd-server ➜  gpu kubectl logs gpu-pod</span><br><span class="line">[Vector addition of 50000 elements]</span><br><span class="line">Copy input data from the host memory to the CUDA device</span><br><span class="line">CUDA kernel launch with 196 blocks of 256 threads</span><br><span class="line">Copy output data from the CUDA device to the host memory</span><br><span class="line">Test PASSED</span><br><span class="line">Done</span><br></pre></td></tr></table></figure>
<p>如上说明CUDA安装成功了</p>
<h2 id="k3s排错">k3s排错</h2>
<h3
id="k3s-flannel-failed-delete-failed-to-parse-netconf-unexpected-end-of-json-input">k3s
flannel failed (delete): failed to parse netconf: unexpected end of JSON
input</h3>
<p>貌似是cri网络插件的问题，但是没有找到出现问题的原因。</p>
<h4 id="解决方法">解决方法</h4>
<p>删除k3s配置，重新启动即可。</p>
<p>删除ipvsadm规则</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ipvsadm -C</span><br></pre></td></tr></table></figure>
<p>删除iptables规则</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -F <span class="comment"># flush 清除所有的已定规则</span></span><br><span class="line">iptables -X <span class="comment"># delete 删除所有用户自定义的链</span></span><br><span class="line">iptables -Z <span class="comment"># zero 将所有的chain的计数与流量统计都归零</span></span><br></pre></td></tr></table></figure>
<p>删除网卡信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip <span class="built_in">link</span> delete kube-ipvs0 </span><br></pre></td></tr></table></figure>
<p>重新启动集群</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl start k3s</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>使用WireGuard组建虚拟局域网</title>
    <url>/p/create-a-virtual-local-area-network-with-wireguard/</url>
    <content><![CDATA[<p>什么是wireguard？</p>
<p>以下引用自 <a href="https://www.wireguard.com/">WireGuard</a>
项目主页:</p>
<p>WireGuard 是一种极其简单但快速且现代的
VPN，它利用了最先进的加密技术。它的目标是比 IPsec
更快、更简单、更精简和更有用，同时避免令人头疼的问题。旨在提供比 OpenVPN
更高的性能。WireGuard 被设计为在嵌入式接口和超级计算机等上运行的通用
VPN，适用于许多不同的环境。最初仅支持 Linux
平台，现在可以进行跨平台（Windows、macOS、BSD、iOS、Android）的广泛部署。目前仍然在大力开发中，但已经被认为是业内最安全、最容易使用和最简单的
VPN 解决方案。</p>
<p>本文主要介绍如何使用WireGuard组建虚拟局域网，并结合自己的实践经验，给出笔者在使用wireguard中遇到的问题。</p>
<p>关键词：<strong>WireGuard</strong></p>
<span id="more"></span>
<h2 id="前言">前言</h2>
<p>有人可能会问，为什么不使用Frp或其他端口映射工具？需求之一是希望七层应用（包括DNS）都不需要特别的设置：而端口映射在应用层，每当有一个新的应用都要重新配置一遍。VPN虚拟出来的网络处于网络层，路由规则一次性配好后，就不需要再为了新的七层应用再配置一遍。</p>
<p>部署前提：需要一台可以<strong>被公网访问</strong>的电脑，不管是通过DMZ，还是一对一NAT的方式，或者是其他方式。</p>
<h2 id="基础设置">基础设置</h2>
<h3 id="server端">Server端</h3>
<p>为了方便，这里使用docker。</p>
<p>注：安装docker环境不在本文的讨论范围内。</p>
<p>安装Wireguard内核</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install wireguard-dkms -y</span><br></pre></td></tr></table></figure>
<p>Docker开启IP地址转发</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &lt;&lt;<span class="string">EOF | sudo tee /etc/modules-load.d/containerd.conf</span></span><br><span class="line"><span class="string">overlay</span></span><br><span class="line"><span class="string">br_netfilter</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line">sudo modprobe overlay</span><br><span class="line">sudo modprobe br_netfilter</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置必需的 sysctl 参数，这些参数在重新启动后仍然存在。</span></span><br><span class="line"><span class="built_in">cat</span> &lt;&lt;<span class="string">EOF | sudo tee /etc/sysctl.d/99-kubernetes-cri.conf</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-iptables  = 1</span></span><br><span class="line"><span class="string">net.ipv4.ip_forward                 = 1</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-ip6tables = 1</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 应用 sysctl 参数而无需重新启动</span></span><br><span class="line">sudo sysctl --system</span><br></pre></td></tr></table></figure>
<p>拉取Wireguard镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull lscr.io/linuxserver/wireguard:latest</span><br></pre></td></tr></table></figure>
<p>设置Server端环境变量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># env</span></span><br><span class="line">SERVERURL=1.2.3.4							 <span class="comment"># 任意client都可以直接访问的公网IP</span></span><br><span class="line">SERVERPORT=51820            	 <span class="comment"># Server向外暴露的端口</span></span><br><span class="line">PEERS=5                     	 <span class="comment"># Peer 数目</span></span><br><span class="line">PEERDNS=119.29.29.29        	 <span class="comment"># Peer DNS</span></span><br><span class="line">INTERNAL_SUBNET=192.168.7.0/24 <span class="comment"># 虚拟局域网IP</span></span><br><span class="line">ALLOWEDIPS=192.168.7.0/24      <span class="comment"># 允许被访问的IP</span></span><br></pre></td></tr></table></figure>
<p>设置docker-compose.yml</p>
<p>主要是server端容器配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">wireguard:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">lscr.io/linuxserver/wireguard:latest</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">env_file:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./env</span>                    <span class="comment"># 将上文的环境变量存为env</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">    	<span class="attr">TZ:</span> <span class="string">&quot;Asia/Shanghai&quot;</span></span><br><span class="line">      <span class="attr">PUID:</span> <span class="string">&quot;1000&quot;</span>               <span class="comment"># 配置文件映射到宿主机的UID</span></span><br><span class="line">      <span class="attr">PGID:</span> <span class="string">&quot;1000&quot;</span>               <span class="comment"># 配置文件映射到宿主机的PID</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./config:/config</span>         <span class="comment"># 配置文件路径</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/lib/modules:/lib/modules</span></span><br><span class="line">    <span class="attr">cap_add:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">NET_ADMIN</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SYS_MODULE</span></span><br><span class="line">    <span class="attr">sysctls:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">net.ipv4.conf.all.src_valid_mark=1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">net.ipv4.ip_forward=1</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">51820</span><span class="string">:51820/udp</span>         <span class="comment"># 向外映射的端口，需要开启UDP支持</span></span><br></pre></td></tr></table></figure>
<p>启动Server端</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>
<p><img data-src="image-20220610155805291.png" /></p>
<h3 id="client端">Client端</h3>
<p>从config目录下选择一个peerX，文件夹内的peerX.conf就是客户端的配置文件。</p>
<p>客户端使用wg命令行的方式进行安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install wireguard-dkms -y  <span class="comment"># 如果当前内核版本大于5.6则不用安装</span></span><br><span class="line">sudo apt-get install wireguard-tools -y       </span><br></pre></td></tr></table></figure>
<p>将配置文件复制到/etc/wireguard文件夹，执行以下命令启动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wg-quick up peerX                      <span class="comment"># peerX要和配置文件名的basename一致</span></span><br></pre></td></tr></table></figure>
<p>如果在启动过程发现了如下问题：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/bin/wg-quick: line 32: resolvconf: <span class="built_in">command</span> not found</span><br></pre></td></tr></table></figure>
<p>执行以下命令修复</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">ln</span> -s /usr/bin/resolvectl /usr/local/bin/resolvconf</span><br></pre></td></tr></table></figure>
<p>启动完毕以后检查执行情况</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wg </span><br></pre></td></tr></table></figure>
<p><img data-src="使用WireGuard组建虚拟局域网/image-20220610164755938.png" /></p>
<h3 id="附加设置">附加设置</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PersistentKeepalive = 1</span><br></pre></td></tr></table></figure>
<p>上面的设置是每隔1秒发送一个数据包，保持数据连接</p>
<h2 id="进阶设置">进阶设置</h2>
<h3 id="wireguard全互联架构">Wireguard全互联架构</h3>
<h3 id="基于wireguard协议的vpn工具">基于WireGuard协议的VPN工具</h3>
<p>未完待续...</p>
]]></content>
      <tags>
        <tag>wireguard</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes集群实践（五）如何在公网环境下搭建K8s集群</title>
    <url>/p/create-a-k8s-cluster-with-kubeadm-on-internet/</url>
    <content><![CDATA[<p>本文通过一个例子的形式介绍如何在公网环境下搭建K8s集群。</p>
<p>关键词：<strong>k8s</strong></p>
<span id="more"></span>
<h3 id="前期准备">前期准备</h3>
<ul>
<li>至少两台具备公网环境的服务器</li>
<li>安装kubeadm、kubelet、kubectl三件套</li>
<li>服务器的防火墙放行对应的端口，具体端口号请查看K8s官网</li>
</ul>
<h3 id="操作演示">操作演示</h3>
<p>一般云服务厂商不会给你直接在网卡上给你一个公网IP，而是赋予一个内网IP，通过<strong>一对一NAT</strong>的形式将内网IP和公网IP对应，如下图所示。</p>
<p><img data-src="image-20220528103551074.png" /></p>
<p>如果你的网卡的IP是公网IP，说明服务商直接把公网IP赋予到你的网卡上。</p>
<p>这两种网卡对应的<strong>暴露Service的方式</strong>略有不同。</p>
<h4 id="初始化master节点">初始化Master节点</h4>
<p>这里给出初始化Master节点的一个模板，主要是根据自己的<strong>公网IP</strong>修改localAPIEndpoint对应的字段（注意是<strong>公网IP</strong>而不是<strong>内网IP</strong>）</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># kubeadm-init.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">kubeadm.k8s.io/v1beta3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">InitConfiguration</span></span><br><span class="line"><span class="attr">localAPIEndpoint:</span></span><br><span class="line">  <span class="attr">advertiseAddress:</span> <span class="string">&quot;1.2.3.4&quot;</span></span><br><span class="line">  <span class="attr">bindPort:</span> <span class="number">6443</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterConfiguration</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">kubeadm.k8s.io/v1beta3</span></span><br><span class="line"><span class="attr">kubernetesVersion:</span> <span class="string">v1.24.0</span></span><br><span class="line"><span class="attr">imageRepository:</span> <span class="string">registry.cn-hangzhou.aliyuncs.com/google_containers</span></span><br><span class="line"><span class="attr">networking:</span></span><br><span class="line">  <span class="attr">podSubnet:</span> <span class="string">&quot;10.244.0.0/16&quot;</span> <span class="comment"># --pod-network-cidr # 网络插件地址</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">KubeletConfiguration</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">kubelet.config.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">cgroupDriver:</span> <span class="string">systemd</span></span><br></pre></td></tr></table></figure>
<p>修改完毕以后，执行初始化集群的命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubeadm init --config kubeadm-init.yml</span><br></pre></td></tr></table></figure>
<p>如果没有问题会在稍后显示其他节点加入集群的命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubeadm <span class="built_in">join</span> 1.2.3.4:6443 --token xxx --discovery-token-ca-cert-hash sha256:xxxx</span><br></pre></td></tr></table></figure>
<h4 id="worker节点加入">Worker节点加入</h4>
<p>在worker节点上执行加入集群的命令，如果没有问题它会提示<strong>在master节点查看节点状态</strong>，此时返回master节点会看到master节点上看到工作节点和worker节点的健康情况</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get nodes -o wide</span><br></pre></td></tr></table></figure>
<h4 id="创建一个应用">创建一个应用</h4>
<p>集群安装完毕以后当然要创建一个实际的应用练练手啦</p>
<h5 id="创建一个configmap">创建一个configMap</h5>
<p>configMap是K8s推荐使用的配置文件的方式。将<strong>配置文件写在yaml资源清单</strong>中，yaml在，应用就在。</p>
<p>这里以Nginx配置文件为例</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-conf</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">nginx.conf:</span> <span class="string">|-</span></span><br><span class="line"><span class="string">    user root;</span></span><br><span class="line"><span class="string">    worker_processes auto;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">    <span class="string">events</span> &#123;</span><br><span class="line">      <span class="string">worker_connections</span> <span class="number">1024</span><span class="string">;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="string">http</span> &#123;</span><br><span class="line">      <span class="string">proxy_headers_hash_max_size</span> <span class="number">51200</span><span class="string">;</span></span><br><span class="line">      <span class="string">proxy_headers_hash_bucket_size</span> <span class="number">6400</span><span class="string">;</span></span><br><span class="line">      <span class="string">log_format</span> <span class="string">main</span> <span class="string">&#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span></span><br><span class="line">      <span class="string">&#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span></span><br><span class="line">      <span class="string">&#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot; &#x27;</span></span><br><span class="line">      <span class="string">&#x27;$proxy_protocol_addr:$proxy_protocol_port&#x27;</span><span class="string">;</span></span><br><span class="line"></span><br><span class="line">      <span class="string">access_log</span> <span class="string">/var/log/nginx/access.log</span> <span class="string">main;</span></span><br><span class="line">      <span class="string">server</span> &#123;</span><br><span class="line">        <span class="string">charset</span> <span class="string">utf-8;</span></span><br><span class="line">        <span class="string">listen</span> <span class="string">unix:/dev/nginx/h1.sock</span> <span class="string">proxy_protocol;</span></span><br><span class="line">        <span class="string">listen</span> <span class="string">unix:/dev/nginx/h2c.sock</span> <span class="string">http2</span> <span class="string">proxy_protocol;</span></span><br><span class="line">        <span class="string">location</span> <span class="string">/</span> &#123;</span><br><span class="line">          <span class="string">return</span> <span class="number">403</span><span class="string">;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="string">location</span> <span class="string">^~</span> <span class="string">/my/</span> &#123;</span><br><span class="line">          <span class="string">alias</span> <span class="string">/sdcard/;</span></span><br><span class="line">          <span class="string">autoindex</span> <span class="string">on;</span></span><br><span class="line">          <span class="string">proxy_force_ranges</span> <span class="string">on;</span></span><br><span class="line">          <span class="string">max_ranges</span> <span class="number">32</span><span class="string">;</span></span><br><span class="line">          <span class="string">autoindex_exact_size</span> <span class="string">off;</span></span><br><span class="line">          <span class="string">add_header</span> <span class="string">Strict-Transport-Security</span> <span class="string">&quot;max-age=31536000; includeSubDomains&quot;</span> <span class="string">always;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="string">location</span> <span class="string">/qb/</span> &#123;</span><br><span class="line">          <span class="string">proxy_redirect</span> <span class="string">off;</span></span><br><span class="line">          <span class="string">proxy_pass</span> <span class="string">http://127.0.0.1:8080/;</span></span><br><span class="line">          <span class="string">proxy_set_header</span> <span class="string">Host</span> <span class="string">$host;</span></span><br><span class="line">          <span class="string">add_header</span> <span class="string">Strict-Transport-Security</span> <span class="string">&quot;max-age=31536000; includeSubDomains&quot;</span> <span class="string">always;</span></span><br><span class="line">          <span class="string">proxy_set_header</span> <span class="string">X-Real-IP</span> <span class="string">$remote_addr;</span></span><br><span class="line">          <span class="string">proxy_set_header</span> <span class="string">X-Forwarded-For</span> <span class="string">$proxy_add_x_forwarded_for;</span></span><br><span class="line">          <span class="string">proxy_set_header</span> <span class="string">X-Forwarded-Proto</span> <span class="string">$scheme;</span></span><br><span class="line">          <span class="string">proxy_set_header</span> <span class="string">REMOTE-HOST</span> <span class="string">$remote_addr;</span></span><br><span class="line">          <span class="string">proxy_set_header</span> <span class="string">Range</span> <span class="string">$http_range;</span></span><br><span class="line">          <span class="string">proxy_set_header</span> <span class="string">If-Range</span> <span class="string">$http_if_range;</span></span><br><span class="line">          <span class="string">proxy_no_cache</span> <span class="string">$http_range</span> <span class="string">$http_if_range;</span></span><br><span class="line">          <span class="string">proxy_set_header</span> <span class="string">X-Forwarded-Proto</span> <span class="string">$scheme;</span></span><br><span class="line">          <span class="string">proxy_set_header</span> <span class="string">Upgrade</span> <span class="string">$http_upgrade;</span></span><br><span class="line">          <span class="string">proxy_set_header</span> <span class="string">Connection</span> <span class="string">&quot;upgrade&quot;</span><span class="string">;</span></span><br><span class="line">          <span class="string">http2_push_preload</span> <span class="string">on;</span></span><br><span class="line">          <span class="string">client_max_body_size</span> <span class="number">0</span><span class="string">;</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="创建一个deployment">创建一个Deployment</h5>
<p>创建一个Deployment，Deployment会根据Pod的模板创建出可以自动维护数量的ReplicaSet，无需考虑故障转移问题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx</span><br><span class="line">  replicas: 1</span><br><span class="line">  revisionHistoryLimit: 3</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx</span><br><span class="line">    spec:</span><br><span class="line">      nodeSelector:</span><br><span class="line">        type: aws</span><br><span class="line">      volumes:</span><br><span class="line">      - name: sdcard</span><br><span class="line">        hostPath:</span><br><span class="line">          path: /sdcard</span><br><span class="line">      - name: nginx-conf</span><br><span class="line">        configMap:</span><br><span class="line">          name: nginx-conf</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - name: nginx-conf</span><br><span class="line">          mountPath: /etc/nginx/nginx.conf</span><br><span class="line">          subPath: nginx.conf</span><br><span class="line">        - name: sdcard</span><br><span class="line">          mountPath: /sdcard/</span><br><span class="line">        - name: unix</span><br><span class="line">          mountPath: /dev/nginx</span><br><span class="line">      - name: qbittorrent</span><br><span class="line">        image: linuxserver/qbittorrent</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - name: sdcard</span><br><span class="line">          mountPath: /downloads/</span><br><span class="line">        - name: config</span><br><span class="line">          mountPath: /config</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 5678</span><br><span class="line">          name: port</span><br></pre></td></tr></table></figure>
<p>这里注意几点：</p>
<ul>
<li><p>如果在一个Pod中创建多个容器，一定是在<code>.containers</code>创建多个对象，以最后一个<code>.containers</code>下面的内容为准</p></li>
<li><p>nodeSelector是选择将应用调度到那个节点上运行，可以使用<code>kubectl label node-name key=value</code>对节点进行标签操作</p></li>
<li><p>configMap和hostPath都是<code>.volumes</code>下的对象</p></li>
<li><p>如果configMap使用了<code>subPath</code>挂载，那么Pod容器获取的configMap不会实时获得更新</p></li>
<li><p>当Pod中的多个容器都挂载了同一个Volume，使用subPath可以避免最后操作的覆盖问题</p></li>
<li><p><code>.spec.matchLabels</code>和<code>.spec.template.metadata.labels</code>下的标签要一致</p></li>
</ul>
<h5 id="创建一个service">创建一个service</h5>
<p>创建一个service，可以使应用向外部提供服务</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">tls</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">443</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">443</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">UDP</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">udp</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5678</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="string">port</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">tcp</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5678</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="string">port</span></span><br><span class="line">  <span class="attr">externalIPs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">172.26</span><span class="number">.12</span><span class="number">.34</span></span><br></pre></td></tr></table></figure>
<p>这里注意几点：</p>
<ul>
<li>UDP协议和TCP协议要分开放行</li>
<li>targetPort对应的是Pod对外保留的端口</li>
<li><code>.spec.selector</code>下的label要和Deployment的<code>.spec.matchLabels</code>标签一致</li>
<li>这里对外暴露端口的方式是通过<strong>externalIPs</strong>：
<ul>
<li>这里的IP是根据网卡获得的IP填写的，如果是一对一NAT的方式，就写内网IP；如果是直接赋予了网卡公网IP，就写公网IP。</li>
</ul></li>
</ul>
<h4 id="完">完</h4>
]]></content>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac实用小技巧</title>
    <url>/p/how-to-use-mac/</url>
    <content><![CDATA[<p>本文主要记录我在使用Mac操作系统中遇到的问题，不断更新</p>
<p>关键词：<strong>Mac</strong></p>
<span id="more"></span>
<h3 id="安装系统">安装系统</h3>
<blockquote>
<p>由于我使用的是黑苹果，所以有了这一章😂，不打算在这里写，咕咕咕。。</p>
</blockquote>
<p>略。</p>
<h3 id="键盘问题">键盘问题</h3>
<p>(⌃)Control-------------&gt; Ctrl (⌥)Option-------------&gt; Alt
(⌘)Command--------&gt; Win</p>
<p><img data-src="webp" /></p>
<p>如果不习惯这样的键位，可以在<strong>系统偏好设置——键盘——修饰键</strong>选项中更改Control和Win的位置，这样复制粘贴操作在两种系统的键盘上是一致的😄</p>
<p><img data-src="image-20220522194414226.png" /></p>
<h3 id="美化自带终端">美化自带终端</h3>
<p>自带是zsh，直接装Oh-My-Zsh</p>
<h4 id="github">Github</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="gitee">Gitee</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://gitee.com/mirrors/oh-my-zsh/raw/master/tools/install.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="设置主题">设置主题</h4>
<p>编辑<code>~/.zshrc</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 找到 ZSH_THEME</span></span><br><span class="line"><span class="comment"># robbyrussell 是默认的主题</span></span><br><span class="line">ZSH_THEME=<span class="string">&quot;robbyrussell&quot;</span></span><br><span class="line"><span class="comment"># ZSH_THEME=&quot;样式名称&quot; </span></span><br></pre></td></tr></table></figure>
<h4 id="设置history记录时间">设置history记录时间</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">HIST_STAMPS=<span class="string">&quot;mm/dd/yyyy&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="设置插件">设置插件</h4>
<p>这个也是Oh-My-Zsh最有用的特性之一</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">plugins=(docker docker-compose git zsh-autosuggestions)</span><br></pre></td></tr></table></figure>
<p>这里分别设置了docker、docker-compose、git命令和全局自动补全的命令。这些插件都是自带安装的。</p>
<p>设置kubectl的自动补全</p>
<blockquote>
<p>https://kubernetes.io/zh/docs/tasks/tools/included/optional-kubectl-configs-zsh/</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> &lt;(kubectl completion zsh)</span><br></pre></td></tr></table></figure>
<h4 id="设置快捷命令行代理">设置快捷命令行代理</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">alias</span> set_proxy=<span class="string">&#x27;export https_proxy=http://localhost:7890;export http_proxy=http://localhost:7890&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> unset_proxy=<span class="string">&#x27;unset https_proxy;unset http_proxy&#x27;</span></span><br></pre></td></tr></table></figure>
<h4 id="设置nerdctl别名为docker">设置nerdctl别名为docker</h4>
<p>这样就可以继续愉快的使用docker-cli命令了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">alias</span> docker=<span class="string">&#x27;nerdctl&#x27;</span></span><br></pre></td></tr></table></figure>
<h4 id="设置终端颜色">设置终端颜色</h4>
<p><strong>终端——偏好——描述文件——高级</strong>，选择<code>xterm-256color</code></p>
<p><img data-src="image-20220522204225442.png" /></p>
<h3 id="ssh问题">SSH问题</h3>
<h4 id="ssh别名">ssh别名</h4>
<p>编辑<code>~/.ssh/config</code>，设置对应的ssh别名</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Host github.com *.github.com coding.net *.coding.net jihulab.com *.jihulab.com</span><br><span class="line">    User git</span><br><span class="line">    Port 22</span><br><span class="line">    HostName %h</span><br><span class="line">    IdentityFile ~/.ssh/xxxx</span><br><span class="line">    ProxyCommand nc -x 127.0.0.1:7890 %h %p <span class="comment"># 走代理的ssh协议</span></span><br></pre></td></tr></table></figure>
<h4 id="ssh保持链接">ssh保持链接</h4>
<p>客户端编辑<code>/etc/ssh/ssh_config</code>，在<code>Host *</code>加入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ServerAliveInterval 30 <span class="comment"># 每隔30s向server端sshd发送keep-alive包，</span></span><br><span class="line">ServerAliveCountMax 60 <span class="comment"># 如果发送60次server无回应断开连接</span></span><br></pre></td></tr></table></figure>
<p>或者是服务端编辑<code>/etc/ssh/ssh_config</code>，添加下列设置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ClientAliveInterval 30 <span class="comment"># 服务端每隔30秒向client发送一个数据包来保持链接</span></span><br><span class="line">ClientAliveCountMax 60 <span class="comment"># 如果发送60次client无回应断开连接</span></span><br></pre></td></tr></table></figure>
<p>如果什么都不操作，服务端配置可以让连接保持 30s*60=30 min</p>
<h4 id="共享ssh链接">共享ssh链接</h4>
<p>如果需要在多个窗口中打开同一个服务器连接，可以尝试添加
<code>~/.ssh/config</code>，添加两行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ControlMaster auto</span><br><span class="line">ControlPath ~/.ssh/connection-%r@%h:%p</span><br></pre></td></tr></table></figure>
<p>配置之后，第二条连接共享第一次建立的连接，加快速度。</p>
<h4 id="添加长链接设置">添加长链接设置</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ControlPersist 4h</span><br></pre></td></tr></table></figure>
<p>每次 SSH 连接建立之后，此条连接会被保持 4
小时，<strong>退出服务器之后依然可以重用</strong>。</p>
<h4 id="配置连接中转">配置连接中转</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ForwardAgent <span class="built_in">yes</span></span><br></pre></td></tr></table></figure>
<p>当需要从一台服务器连接到另一台服务器，同时两台服务器需要传输数据，以上设置可以不用通过本地电脑中转。</p>
<h3 id="开机或定时执行任务">开机或定时执行任务</h3>
<p>launchctl是一个统一的服务管理框架，启动、停止和管理守护进程、应用程序、进程和脚本。</p>
<h4 id="编写plist文件">编写plist文件</h4>
<p>定时执行</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">plist</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//Apple//DTD PLIST 1.0//EN&quot;</span> <span class="string">&quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plist</span> <span class="attr">version</span>=<span class="string">&quot;1.0&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>Label<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>com.denglibing.checkin<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>RunAtLoad<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>ProgramArguments<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">array</span>&gt;</span> <span class="tag">&lt;<span class="name">string</span>&gt;</span>/Users/denglibing/Desktop/denglibing_checkin/denglibing_checkin_request.sh<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>StartCalendarInterval<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">key</span>&gt;</span>Weekday<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">integer</span>&gt;</span>1<span class="tag">&lt;/<span class="name">integer</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">key</span>&gt;</span>Hour<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">integer</span>&gt;</span>8<span class="tag">&lt;/<span class="name">integer</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">key</span>&gt;</span>Minute<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">string</span>&gt;</span>58<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">key</span>&gt;</span>Weekday<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">integer</span>&gt;</span>2<span class="tag">&lt;/<span class="name">integer</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">key</span>&gt;</span>Hour<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">integer</span>&gt;</span>8<span class="tag">&lt;/<span class="name">integer</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">key</span>&gt;</span>Minute<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">string</span>&gt;</span>52<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>StandardOutPath<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>/Users/denglibing/Desktop/denglibing_checkin/outlog<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>StandardErrorPath<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>/Users/denglibing/Desktop/denglibing_checkin/errorlog<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plist</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>开机启动</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">plist</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//Apple//DTD PLIST 1.0//EN&quot;</span> <span class="string">&quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plist</span> <span class="attr">version</span>=<span class="string">&quot;1.0&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">key</span>&gt;</span>Label<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">string</span>&gt;</span>com.xray.cloudflare<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">key</span>&gt;</span>KeepAlive<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">false</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">key</span>&gt;</span>RunAtLoad<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">key</span>&gt;</span>ProgramArguments<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">string</span>&gt;</span>/Users/wf09/Bin/xray/xray<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">string</span>&gt;</span>-c<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">string</span>&gt;</span>/Users/wf09/Bin/xray/cloudflare.json<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">key</span>&gt;</span>StandardOutPath<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    		    <span class="tag">&lt;<span class="name">string</span>&gt;</span>/Users/wf09/Bin/xray/cloudflare.log<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plist</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="选择存放plist文件位置">选择存放plist文件位置</h4>
<p>建议存放在<code>~/Library/LaunchAgents</code>路径下。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">* ~/Library/LaunchAgents 由用户自己定义的任务项</span><br><span class="line">* /Library/LaunchAgents 由管理员为用户定义的任务项</span><br><span class="line">* /Library/LaunchDaemons 由管理员定义的守护进程任务项</span><br><span class="line">* /System/Library/LaunchAgents 由Mac OS X为用户定义的任务项</span><br><span class="line">* /System/Library/LaunchDaemons 由Mac OS X定义的守护进程任务项</span><br><span class="line"></span><br><span class="line">/System/Library和/Library和~/Library目录的区别？</span><br><span class="line">/System/Library目录是存放Apple自己开发的软件。</span><br><span class="line">/Library目录是系统管理员存放的第三方软件。</span><br><span class="line">~/Library/是用户自己存放的第三方软件。</span><br><span class="line"></span><br><span class="line"><span class="comment"># LaunchDaemons和LaunchAgents的区别</span></span><br><span class="line">LaunchDaemons是用户未登陆前就启动的服务（守护进程）。</span><br><span class="line">LaunchAgents是用户登陆后启动的服务（守护进程）。</span><br></pre></td></tr></table></figure>
<h4 id="加载命令">加载命令</h4>
<h5 id="加载任务">加载任务</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">launchctl load -w com.denglibing.checkin.plist</span><br></pre></td></tr></table></figure>
<h5 id="删除任务">删除任务</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">launchctl unload -w com.denglibing.checkin.plist</span><br></pre></td></tr></table></figure>
<h5 id="查看任务列表">查看任务列表</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">launchctl list | grep <span class="string">&#x27;com.denglibing&#x27;</span></span><br></pre></td></tr></table></figure>
<h5 id="启动任务">启动任务</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">launchctl start -w com.denglibing.checkin.plist</span><br></pre></td></tr></table></figure>
<p><strong>关闭任务</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">launchctl stop -w com.denglibing.checkin.plist</span><br></pre></td></tr></table></figure>
<h3 id="添加快速操作到文件夹">添加快速操作到文件夹</h3>
<p>有时需要添加一个操作如<strong>在终端中打开文件夹、在VScode中打开文件夹</strong>等</p>
<ol type="1">
<li>打开自动操作</li>
</ol>
<p>command + space搜索自动操作</p>
<p><img data-src="image-20220522211922798.png" /></p>
<ol start="2" type="1">
<li>选择快速操作</li>
</ol>
<p><img data-src="image-20220522212036459.png" /></p>
<ol start="3" type="1">
<li>搜索框输入打开，选中打开访达项目</li>
</ol>
<p><img data-src="image-20220522212015739.png" /></p>
<ol start="4" type="1">
<li>工作流程收到当前一栏<strong>选择文件或文件夹</strong>，并选中位于<strong>访达</strong></li>
</ol>
<p><img data-src="image-20220522212344761.png" /></p>
<ol start="5" type="1">
<li>打开方式选择<strong>你想要打开的应用程序</strong>，这里选择最常用的<strong>终端</strong></li>
</ol>
<p><img data-src="image-20220522212507742.png" /></p>
<ol start="6" type="1">
<li>验证效果</li>
</ol>
<p><img data-src="image-20220522212603763.png" /></p>
]]></content>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言基础（二）读写json字符串</title>
    <url>/p/go-json/</url>
    <content><![CDATA[<p>本文主要介绍了Go语言中读写json的相关操作。</p>
<p>关键词：<strong>golang</strong></p>
<span id="more"></span>
<h3 id="将json字符串反序列化成对象">将json字符串反序列化成对象</h3>
<blockquote>
<p>以飞书机器人富文本的消息体为例</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;msg_type&quot;</span>: <span class="string">&quot;post&quot;</span>,</span><br><span class="line">    <span class="string">&quot;content&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;post&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;zh_cn&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;title&quot;</span>: <span class="string">&quot;项目更新通知&quot;</span>,</span><br><span class="line">                <span class="string">&quot;content&quot;</span>: [</span><br><span class="line">                    [</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="string">&quot;tag&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;text&quot;</span>: <span class="string">&quot;项目有更新: &quot;</span></span><br><span class="line">                        &#125;,</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="string">&quot;tag&quot;</span>: <span class="string">&quot;a&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;text&quot;</span>: <span class="string">&quot;请查看&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;href&quot;</span>: <span class="string">&quot;http://www.example.com/&quot;</span></span><br><span class="line">                        &#125;,</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="string">&quot;tag&quot;</span>: <span class="string">&quot;at&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;user_id&quot;</span>: <span class="string">&quot;ou_18eac8********17ad4f02e8bbbb&quot;</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    ]</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="核心代码">核心代码</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Unmarshal</span><span class="params">(data []<span class="type">byte</span>, v any)</span></span> <span class="type">error</span></span><br></pre></td></tr></table></figure>
<h4 id="map映射方法">map映射方法</h4>
<p>直接用<code>map[string]interface&#123;&#125;</code>一步到位</p>
<blockquote>
<p>这种方法比较粗暴，可以快速映射到go里面的对象</p>
</blockquote>
<p>缺点就是在读json里的字段时<strong>需要先用<code>.</code>推断出来空接口的类型</strong>，导致代码不太好看hhh...</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	msg := <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;&#125;</span><br><span class="line">	jsonDATA, err := ioutil.ReadFile(<span class="string">&quot;data.json&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// fmt.Printf(&quot;jsonDATA: %s\n&quot;, string(jsonDATA))</span></span><br><span class="line">	err = json.Unmarshal(jsonDATA, &amp;msg)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;msg: %v\n&quot;</span>, msg)</span><br><span class="line">	content := msg[<span class="string">&quot;content&quot;</span>].(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;msg[\&quot;content\&quot;][\&quot;post\&quot;][\&quot;zh_cn\&quot;]: %v\n&quot;</span>, content[<span class="string">&quot;post&quot;</span>].(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)[<span class="string">&quot;zh_cn&quot;</span>])</span><br><span class="line">	fmt.Printf(<span class="string">&quot;msg[\&quot;content\&quot;][\&quot;post\&quot;][\&quot;zh_cn\&quot;][\&quot;title\&quot;]: %v\n&quot;</span>, content[<span class="string">&quot;post&quot;</span>].(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)[<span class="string">&quot;zh_cn&quot;</span>].(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)[<span class="string">&quot;title&quot;</span>])</span><br><span class="line">	fmt.Printf(<span class="string">&quot;msg[\&quot;content\&quot;][\&quot;post\&quot;][\&quot;zh_cn\&quot;][\&quot;content\&quot;]: %v\n&quot;</span>, content[<span class="string">&quot;post&quot;</span>].(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)[<span class="string">&quot;zh_cn&quot;</span>].(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)[<span class="string">&quot;content&quot;</span>])</span><br><span class="line">	_content := content[<span class="string">&quot;post&quot;</span>].(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)[<span class="string">&quot;zh_cn&quot;</span>].(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)[<span class="string">&quot;content&quot;</span>].([]<span class="keyword">interface</span>&#123;&#125;)[<span class="number">0</span>].([]<span class="keyword">interface</span>&#123;&#125;) <span class="comment">// 二维json数组</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;content[0]: %v\n&quot;</span>, _content[<span class="number">0</span>])</span><br><span class="line">	fmt.Printf(<span class="string">&quot;content[1]: %v\n&quot;</span>, _content[<span class="number">1</span>])</span><br><span class="line">	fmt.Printf(<span class="string">&quot;content[2]: %v\n&quot;</span>, _content[<span class="number">2</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="image-20220520155720624.png" /></p>
<h4 id="结构体映射方法">结构体映射方法</h4>
<p>这种方法虽然比较复杂，但是好理解</p>
<blockquote>
<p>balabala写了一堆，最后自己没搞出来。</p>
</blockquote>
<p>如果单独用一种方法比较复杂的话，那最优解就是两种方式结合在一起。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">  JSON类型             Go类型                </span><br><span class="line">---------------------------------------------</span><br><span class="line">JSON objects    &lt;--&gt;  map[string]interface&#123;&#125; </span><br><span class="line">JSON arrays     &lt;--&gt;  []interface&#123;&#125;          </span><br><span class="line">JSON booleans   &lt;--&gt;  bool                   </span><br><span class="line">JSON numbers    &lt;--&gt;  float64                </span><br><span class="line">JSON strings    &lt;--&gt;  string                 </span><br><span class="line">JSON null       &lt;--&gt;  nil                    </span><br></pre></td></tr></table></figure>
<p>不过既然已经有好轮子了干嘛还要自己造呢～自己专注代码逻辑就OK了，其他的就不要考虑了</p>
<h4 id="使用工具映射">使用工具映射</h4>
<blockquote>
<p>Paste JSON as Code</p>
</blockquote>
<p>在线版：https://app.quicktype.io/</p>
<p>VScode 插件</p>
<p><img data-src="image-20220520164653737.png" /></p>
<p>生成代码步骤：</p>
<ol type="1">
<li><p>打开json文件</p>
<p><img data-src="image-20220520164806555.png" /></p></li>
<li><p>打开VScode command，Mac上的快捷键是 <strong>Command + Shift +
P</strong>，选择<strong>Open quicktype for
JSON</strong>，如果语言不对的话可以使用<strong><em>Set quicktype target
language</em></strong>指定生成代码的语言</p>
<p><img data-src="image-20220520164949829.png" /></p></li>
<li><p>展示生成的结果</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Generated by https://quicktype.io</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// To change quicktype&#x27;s target language, run command:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   &quot;Set quicktype target language&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Data <span class="keyword">struct</span> &#123;</span><br><span class="line">	MsgType <span class="type">string</span>      <span class="string">`json:&quot;msg_type&quot;`</span></span><br><span class="line">	Content DataContent <span class="string">`json:&quot;content&quot;`</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DataContent <span class="keyword">struct</span> &#123;</span><br><span class="line">	Post Post <span class="string">`json:&quot;post&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Post <span class="keyword">struct</span> &#123;</span><br><span class="line">	ZhCN ZhCN <span class="string">`json:&quot;zh_cn&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ZhCN <span class="keyword">struct</span> &#123;</span><br><span class="line">	Title   <span class="type">string</span>             <span class="string">`json:&quot;title&quot;`</span>  </span><br><span class="line">	Content [][]ContentElement <span class="string">`json:&quot;content&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ContentElement <span class="keyword">struct</span> &#123;</span><br><span class="line">	Tag    <span class="type">string</span>  <span class="string">`json:&quot;tag&quot;`</span>              </span><br><span class="line">	Text   *<span class="type">string</span> <span class="string">`json:&quot;text,omitempty&quot;`</span>   </span><br><span class="line">	Href   *<span class="type">string</span> <span class="string">`json:&quot;href,omitempty&quot;`</span>   </span><br><span class="line">	UserID *<span class="type">string</span> <span class="string">`json:&quot;user_id,omitempty&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	msg := &amp;Data&#123;&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;msg: %v\n&quot;</span>, msg)</span><br><span class="line">	jsonDATA, err := ioutil.ReadFile(<span class="string">&quot;data.json&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// fmt.Printf(&quot;jsonDATA: %s\n&quot;, string(jsonDATA))</span></span><br><span class="line">	err = json.Unmarshal(jsonDATA, msg)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;msg.Content: %v\n&quot;</span>, msg.Content)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;msg.MsgType: %v\n&quot;</span>, msg.MsgType)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>JSON tag中的<code>omitempty</code>
关键字，表示这条信息如果没有提供，在序列化成 json
的时候就不要包含其默认值</p>
</blockquote></li>
</ol>
<h3 id="把对象序列化成字符串">把对象序列化成字符串</h3>
<h4 id="核心代码-1">核心代码</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">jsonDATA, err = json.Marshal(msg) <span class="comment">// 不带缩进 </span></span><br><span class="line">json.MarshalIndent(c, <span class="string">&quot;&quot;</span>, <span class="string">&quot;     &quot;</span>) <span class="comment">// 带缩进</span></span><br></pre></td></tr></table></figure>
<h4 id="完整代码">完整代码</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	msg := &amp;Data&#123;&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;msg: %v\n&quot;</span>, msg)</span><br><span class="line">	jsonDATA, err := ioutil.ReadFile(<span class="string">&quot;data.json&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// fmt.Printf(&quot;jsonDATA: %s\n&quot;, string(jsonDATA))</span></span><br><span class="line">	err = json.Unmarshal(jsonDATA, msg)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;msg.Content: %v\n&quot;</span>, msg.Content)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;msg.MsgType: %v\n&quot;</span>, msg.MsgType)</span><br><span class="line">	<span class="comment">// jsonDATA, err = json.Marshal(msg) // 不带缩进</span></span><br><span class="line">	jsonDATA, err = json.MarshalIndent(msg, <span class="string">&quot;&quot;</span>, <span class="string">&quot;  &quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;string(jsonDATA): %v\n&quot;</span>, <span class="type">string</span>(jsonDATA))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>理解Kubernetes Services</title>
    <url>/p/understanding-services-in-kubernetes/</url>
    <content><![CDATA[<p>本文是CNCF × Alibaba 云原生技术公开课的<strong>第八章理解Kubernetes
Services</strong>学习笔记。</p>
<p>关键词：<strong>k8s</strong></p>
<span id="more"></span>
<h3 id="需求来源">需求来源</h3>
<h4 id="为什么需要服务发现">为什么需要服务发现</h4>
<p>传统的应用部署实在特定的机器上面部署，此时知道怎么去调用别的机器的IP地址。但是在K8s集群中应该是通过Pod去部署，而Pod的生命周期过程中，比如创建或者销毁，此时<strong>IP地址都会发生变化</strong>，<strong>不能指定IP去访问指定的应用。</strong></p>
<p>K8s的应用部署中需要创建一个Pod组，而这些Pod组合需要一个统一的访问接口，以及怎么去控制流量负载均衡在这个组里，比如<strong>测试环境、预发环境和线上环境</strong>。部署过程中需要<strong>保持同样的部署模板以及访问方式</strong>，这样就可以用同一套应用的模板在不同的环境中直接发布。</p>
<p><img data-src="image-20220516164957086.png" /></p>
<h4
id="servicek8s中服务发现和负载均衡">Service：K8s中服务发现和负载均衡</h4>
<p>应用总是需要暴露到外部去访问，而Pod的网络和机器的网卡并不是一个IP段的，那么怎么让Pod暴露到外部访问呢？此时就需要<strong>服务发现</strong>。</p>
<p><img data-src="image-20220516165007514.png" /></p>
<p>K8s中的Service实现了服务发现和负载均衡。在K8s架构里，K8s
Service向上提供了外部网络以及Pod网络的访问：外部网络可以通过Service访问，Pod网络也可以通过K8s
Service访问；</p>
<p>向下对接了一组Pod：可以通过K8s
Service的方式负载均衡到一组Pod上，外部网络可以通过Service去访问Pod，不同Pod之间也可通过Service访问彼此。<strong>Service为他们互相之间访问提供了统一的IP地址。</strong></p>
<h3 id="用例解读">用例解读</h3>
<h4 id="service语法">Service语法</h4>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">get-hostname</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">get-hostname</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span> 			<span class="comment"># TCP协议</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">8888</span>              <span class="comment"># Service向外暴露的端口</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="string">http</span>        <span class="comment"># Pod的端口名</span></span><br><span class="line">  <span class="attr">externalIPs:</span>              <span class="comment"># 这个服务暴露在集群中的哪个Node上</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.15</span><span class="number">.202</span></span><br></pre></td></tr></table></figure>
<h4 id="创建和查看service">创建和查看Service</h4>
<h5 id="创建service">创建Service</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f service.yaml</span><br></pre></td></tr></table></figure>
<h5 id="查看service">查看Service</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl describe svc get-hostname</span><br></pre></td></tr></table></figure>
<p><img data-src="image-20220516170555828.png" /></p>
<ul>
<li>IP：集群内部可以访问的虚拟IP</li>
<li>External IP：向集群外部暴露的IP</li>
<li>Endpoints：通过Selector筛选出的Pod IP</li>
</ul>
<p>当Service创建之后，会在集群内创建一个虚拟的IP地址以及端口，集群内部的所有Node和Pod都可以通过这个IP地址和端口访问到这个Service。</p>
<p>Service把用Selector筛选出来的Pod和IP地址挂载到后端。这样通过Service的IP地址访问时，就可以<strong>负载均衡到后端Pod</strong>。</p>
<p>Service有个默认设置<code>.spec.sessionAffinity=None</code>，意思是当流量通过Service时，<strong>随机选择一个Pod</strong>进行负载，这样就实现了负载均衡。</p>
<p><img data-src="image-20220516171436345.png" /></p>
<p>当某一个Pod终止，Service会自动从后端删除这个Pod。就算Pod的生命周期有变化，从外部看，Service的"端点"是不会发生变化的。</p>
<h4 id="集群内部访问service">集群内部访问Service</h4>
<ul>
<li>可以通过Service的虚拟IP访问，可以通过<code>kubecetl get svc</code>查看</li>
<li>直接访问服务名，依靠DNS解析。
<ul>
<li>相同的Namespace可以直接通过Service的名字访问到声明的Service。</li>
<li>不同的Namespace可以通过<code>service.namespace</code>的方式访问这个Service。</li>
</ul></li>
<li>通过环境变量访问。同一个Namespace里的Pod启动时，K8s会把Service中的一些IP地址，端口以及一些配置信息通过环境变量的方式发放到K8s的Pod里。Pod可以通过读取环境变量的方式访问到<strong>同一Namespace的环境变量</strong>。</li>
</ul>
<p>举个例子，一个名称为 <code>redis-master</code> 的 Service 暴露了 TCP
端口 6379， 同时给它分配了 Cluster IP 地址 10.0.0.11，这个 Service
生成了如下环境变量：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">REDIS_MASTER_SERVICE_HOST=10.0.0.11</span><br><span class="line">REDIS_MASTER_SERVICE_PORT=6379</span><br><span class="line">REDIS_MASTER_PORT=tcp://10.0.0.11:6379</span><br><span class="line">REDIS_MASTER_PORT_6379_TCP=tcp://10.0.0.11:6379</span><br><span class="line">REDIS_MASTER_PORT_6379_TCP_PROTO=tcp</span><br><span class="line">REDIS_MASTER_PORT_6379_TCP_PORT=6379</span><br><span class="line">REDIS_MASTER_PORT_6379_TCP_ADDR=10.0.0.11</span><br></pre></td></tr></table></figure>
<blockquote>
<p>必须在创建服务以后才能在Pod中通过环境变量的方式访问。</p>
</blockquote>
<h4 id="headless-service">Headless Service</h4>
<p>Service创建的时候指定<code>clusterIP:None</code>，此时K8s不会给Service分配一个虚拟IP地址。</p>
<p>Pod可以通过service_name用DNS解析的方式解析到所有后端Pod的IP地址，通过DNS的A记录的方式解析到所有后端的Pod的地址，由客户端选择一个后端的IP地址，这个A记录会随着Pod的生命周期变化，返回的A记录列表也会发生变化。</p>
<p>这种方式要求客户端应用根据DNS返回的A记录，自己选择一个合适的地址去访问Pod。</p>
<p><img data-src="image-20220517094610322.png" /></p>
<p>当集群中的pod访问my-service时，会直接解析到所有的service对应的IP地址，返回给Pod，然后Pod自己选择IP地址去直接访问。</p>
<h4 id="向集群外部暴露service">向集群外部暴露Service</h4>
<h5 id="nodeport">NodePort</h5>
<p>NodePort
服务是引导外部流量到你的服务的最原始方式。NodePort，正如这个名字所示，在所有节点（虚拟机）上开放一个特定端口，任何发送到该端口的流量都被转发到对应服务。</p>
<p><img data-src="58174ac44fdbacbbc89cec648260fcdf.png" /></p>
<h5 id="loadbalancer">LoadBalancer</h5>
<p>LoadBalancer 服务是暴露服务到 internet 的标准方式。在 GKE
上，这种方式会启动一个 <a
href="https://cloud.google.com/compute/docs/load-balancing/network/">Network
Load Balancer</a>，它将给你一个单独的 IP
地址，转发所有流量到你的服务。</p>
<p><img data-src="d8631b315a7acdd6926ec5405ed1043f.png" /></p>
<p>如果你想要直接暴露服务，这就是默认方式。所有通往你指定的端口的流量都会被转发到对应的服务。它没有过滤条件，没有路由等。这意味着你几乎可以发送任何种类的流量到该服务，像
HTTP，TCP，UDP，Websocket，gRPC 或其它任意种类。</p>
<p>这个方式的最大缺点是<strong>每个用到的 LoadBalancer
都需要付费</strong>，这种方式仅在大型云服务公司上实现，这将是非常昂贵的。</p>
<h5 id="external-ip">External IP</h5>
<p>和LoadBalancer相比，LoadBalancer被某一个Node节点替换了，通过<strong>Node节点暴露的IP</strong>对外部提供服务。</p>
<blockquote>
<p><code>externalIPs</code> 不会被 Kubernetes
管理，它属于集群管理员的职责范畴。</p>
</blockquote>
<h3 id="虚拟ip和service代理">虚拟IP和Service代理</h3>
<p>在K8s集群中，每个Node运行一个<strong>kube-proxy</strong>进程，kube-proxy负责为Service实现了一种虚拟IP的形式。</p>
<h4 id="为什么不使用dns轮询">为什么不使用DNS轮询</h4>
<p>为什么不配置具有个A值或AAAA值的DNS记录，并依靠轮询名称解析？</p>
<p>主要有以下几个原因：</p>
<ul>
<li>DNS的实现的历史由来已久，DNS不遵守TTL，并且在nameserver查找结果到期后对其进行缓存；</li>
<li>有些应用程序仅执行一次DNS查找，并无限期缓存结果；</li>
<li>即使应用和库进行了适当重新解析，DNS记录上的TTL值低或者为零可能会给DNS带来高负载，从而使管理变得困难。</li>
</ul>
<h4 id="userspace代理模式">userspace代理模式</h4>
<p>kube-proxy会监视Kubernetes API
Server对Service对象和Endpoint对象的添加和移除操作。</p>
<p>对于每个Service，会在本地Node随机打开一个端口。任何连接到代理端口的请求，都会被代理到Service的后端Pod中的某个上面。使用Pod的策略是kube-proxy基于<code>.spec.SessionAffinity</code>来确定的。</p>
<p>最后<strong>配置iptables规则</strong>，捕获到到达该Service的ClusterIP（虚拟IP）和Port的请求，<strong>并重定向到代理端口</strong>，代理端口再代理请求到后端Pod。</p>
<p>默认情况下。userspace代理模式的kube-proxy使用<strong>轮转算法选择后端Pod</strong>。</p>
<p><img data-src="services-userspace-overview-16527573586443.svg" /></p>
<h4 id="iptables代理模式">iptables代理模式</h4>
<p>kube-proxy会监视Kubernetes API
Server对Service对象和Endpoint对象的添加和移除操作。</p>
<p>对于每个Service，配置iptables规则，将到达该Service的ClusterIP和端口请求重定向到Service的一组后端的某个Pod上。</p>
<p>对于每个Endpoints，配置iptables规则，这个规则<em>会<strong>选择一个后端组合</strong></em>。</p>
<blockquote>
<p>这里的Endpoints指的是</p>
<p><img data-src="image-20220517112401720.png" /></p>
<p>后端组合的含义还不是很清楚，日后补充。</p>
</blockquote>
<p>默认的策略是，kube-proxy在iptables模式下<strong>随机选择一个后端</strong>。</p>
<p>注意：如果kube-proxy在iptables模式下运行，若<strong>选中的第一个Pod没有响应，则连接失败</strong>。<font color="red">而在userspace模式下，kube-proxy检测到无法链接到第一个Pod时，<strong>会自动使用其他后端Pod重试</strong>。</font></p>
<p>可使用Pod就绪探测器验证后端Pod可以正常工作，使得iptables模式下的kube-proxy仅看到测试正常的后端。这样意味着可以避免将流量通过kube-proxy发送到失败的Pod。</p>
<p><img data-src="services-iptables-overview.svg" /></p>
<h4 id="ipvs代理模式">IPVS代理模式</h4>
<p>在<code>ipvs</code>模式下，kube-proxy监视kubernetes服务和端点，调用<code>netlink</code>接口相应的创建IPVS规则，定期将IPVS规则与Kubernetes服务和端点同步。</p>
<p>控制循环确保IPVS状态和所需状态匹配，访问服务时，IPVS将流量定向到Pod之一。</p>
<p>IPVS代理基于类似iptables模式下的netfilter挂钩函数，但是使用<strong>哈希表</strong>作为基础数据结构，并且在内核空间工作</p>
<p>与iptables模式下的kube-proxy相比，<strong>IPVS模式下的kube-proxy重定向通信的延迟要短，并且在同步规则时具有更好的性能。</strong>与其他代理模式相比。IPVS模式还支持更高的网络流量吞吐量。</p>
<p>IPVS还提供了更多选项来平衡后端Pod的流量：</p>
<ul>
<li>rr：轮替（Round-Robin）</li>
<li>lc：最小链接（Least Connection），即打开数量最少者优先</li>
<li>dh：目标地址哈希（Destination Hashing）</li>
<li>sh：源地址哈希（Source Hashing）</li>
<li>sed：最短预期延迟（Shortest Expected Delay）</li>
<li>nq：从不排队（Never Queue）</li>
</ul>
<blockquote>
<p><strong>Note</strong>：</p>
<p>要在IPVS模式下运行kube-proxy，必须在启动kube-proxy之前使IPVS在节点上可用。</p>
<p>当kube-proxy以IPVS代理模式启动时。他将验证IPVS内核模块是否可用。如果未检测到IPVS内核模块，则Kube-proxy回退到以iptables代理模式运行。</p>
</blockquote>
<p><img data-src="services-ipvs-overview.svg" /></p>
<p>在这些代理模型中，绑定到服务IP的流量：在客户端不了解kubernetes或服务或Pod的任何信息的情况下，将Pod代理到适合的后端。</p>
<p>如果需要确保每次来自特定客户端的链接传递到同一个Pod，则可以通过将<code>.spec.sessionAffinity</code>设置<strong>ClientIP</strong>（默认值是<strong>None</strong>），来<strong>基于客户端的IP地址选择会话关联</strong>。还可以通过适当设置<code>.spec.sessionAffinityConfig.clientIP.timeoutSeconds</code>设置最大会话停留时间（默认时间为10800秒，即3小时）。</p>
<h3 id="架构设计">架构设计</h3>
<p><img data-src="image-20220517101421542.png" /></p>
<p>K8s服务发现以及K8s Service是如上的一个整体架构。</p>
<p>K8s的master节点里面有API Server，API
Server统一管理K8s所有对象，所有的组件都会注册到API
Server上去监听对象的变化。</p>
<p>这里面有三个关键组件：</p>
<ul>
<li>Cloud Controller
Manager，CCM：负责配置LoadBalancer的一个负载均衡器提供给外部访问；</li>
<li>CoreDNS：K8s集群的DNS组件，通过CoreDNS观测API
Server里面的Service后端Pod的变化，配置Service的DNS解析，实现通过Service的名字直接访问到Service的虚拟IP，或者Headless类型的Service中的IP列表解析；</li>
<li>Kube-proxy：K8s网络节点代理，代理通过监听Service以及Pod变化，然后配置集群中的Node、Pod或者ClusterIP的访问；</li>
</ul>
<p>例如Client Pod去访问Service，首先Pod拿Service
IP请求，请求到了宿主机网络后，就被kube-proxy所配置的iptables或者IPVS做拦截处理，之后负载均衡到每一个实际的后端Pod，这样就<strong>实现了负载均衡和服务发现</strong>。</p>
<p>对于来自外部的流量，通过外部负载均衡器管理器（CCM）监听Service的变化，配置LoadBalancer，然后转发到节点的NodePort上，NodePort通过Kube-proxy配置iptables规则，把NodePort的流量转换成ClusterIP，然后转换成后端Pod的IP地址，<strong>这样就实现了负载均衡和服务发现。</strong></p>
]]></content>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>大话数据结构（二）| 栈和队列</title>
    <url>/p/stack-and-ground/</url>
    <content><![CDATA[<p>本文主要介绍栈和队列。</p>
<p><strong>关键词：数据结构</strong></p>
<span id="more"></span>
<h3 id="栈的定义">栈的定义</h3>
<p>栈（stack）是限定仅仅在栈尾进行插入和删除操作的线性表。</p>
<ul>
<li>允许插入和删除的一端称为栈顶</li>
<li>另一端被称为栈底</li>
<li>不含任何元素的栈称为空栈</li>
<li>栈被称为后进先出（LIFO，Last In First Out）的线性表</li>
<li>栈的插入操作叫做进栈，栈的删除操作叫做出栈</li>
</ul>
<h4 id="进栈出栈变化形式">进栈出栈变化形式</h4>
<p><strong>最先进栈的元素不一定最后出栈。</strong></p>
<p>栈对线性表的插入和删除的位置进行了限制，并没有对元素进出的时间进行限制。在不是所有元素都进栈的情况下事先进入的元素也可以出栈，只要<strong>保证栈顶元素出栈</strong>即可。</p>
<p>举例：假设有三个元素1、2、3依次进栈，出栈次序如何？</p>
<ol type="1">
<li>1、2、3进，3、2、1出。出栈次序为321。</li>
<li>1进，1出，2进，2出，3进，3出。此时出栈次序为123。</li>
<li>1进，2进，2出，1出，3进，3出。此时出栈次序为213。</li>
<li>1进，1出，2进，3进，3出，2出。此时出栈次序为132。</li>
<li>1进，2进，2出，3进，3出，1出。此时出栈次序为231。</li>
</ol>
<p>不可能出现312这样的答案，因为进栈的顺序是123，因此<strong>2一定先于1出栈</strong>。</p>
<h3 id="抽象数据类型">抽象数据类型</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DATA</span><br><span class="line">	元素具有相同的类型，相邻具有前驱和后继的关系</span><br><span class="line">Operation</span><br><span class="line">	InitStack(*S): 初始化操作，建立一个空栈S</span><br><span class="line">	DestroyStack(*S): 若栈存在，则销毁它</span><br><span class="line">  ClearStack(*S): 将栈清空</span><br><span class="line">  StackEmpty(*S): 若栈为空，返回True；否则返回False</span><br><span class="line">  GetTop(S, *e): 若栈存在且非空，用e返回S的栈顶元素</span><br><span class="line">  Push(*S, e): 若栈存在，插入新元素e到栈并成为栈顶元素</span><br><span class="line">  Pop(*S, *e): 删除栈S中栈顶元素, 并用e返回其值</span><br><span class="line">  StackLength(S): 返回栈S的元素个数</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>初探docker（四）| docker容器退出码</title>
    <url>/p/docker-tutorial-04/</url>
    <content><![CDATA[<p>本文主要介绍Docker容器退出状态码。</p>
<p><strong>关键词：Docker</strong></p>
<span id="more"></span>
<h3 id="常见容器退出码解释">常见容器退出码解释</h3>
<h4 id="exit-0">Exit 0</h4>
<ul>
<li>退出状态码表示特定容器没有附加前台进程</li>
<li>该状态码表示<strong>容器正常退出</strong></li>
<li>某些情况下，容器中的进程成功捕获到了外部收到的信号，并成功进程了处理，此时容器退出的状态码也是0。</li>
</ul>
<h4 id="exit-1">Exit 1</h4>
<ul>
<li>程序错误，例如Dockerfile引用了不存在的文件，如entrypoint引用了错误的包；</li>
<li>程序错误可以很简单比如除以0，也可很复杂比如空引用和其他程序crash；</li>
</ul>
<h4 id="exit-137">Exit 137</h4>
<ul>
<li>表明容器收到了<code>SIGKILL</code>信号，表示进程被杀掉，对应<code>kill -9</code>；</li>
<li>引发<code>SIGKILL</code>的通常是用户手动执行的<code>docker kill</code>或者由docker守护进程发起的；</li>
<li>在k8s中，如果Pod的limit资源设置比较小，引发运行内存不足导致
<code>OOMKillered</code>，此时<code>state</code>的
<code>OOMKilled</code>设置为<code>true</code>。通过<code>dmesg -T</code>也可看到oom日志</li>
</ul>
<h4 id="exit-139">Exit 139</h4>
<ul>
<li>表明容器收到了<code>SIGENV</code>信号，表示无效的内存引用，对应<code>kill -11</code>；</li>
<li>一般是代码或者基础镜像有问题</li>
</ul>
<h4 id="exit-143">Exit 143</h4>
<ul>
<li>表明容器收到了
<code>SIGTERM</code>信号，表示终端被关闭，对应<code>kill -15</code>；</li>
<li>引发<code>SIGTERM</code>一般对应用户手动执行<code>docker stop</code>或者由docker守护进程发起的；</li>
<li>有时<code>docker stop</code>命令也可能会导致<strong>Exit
137</strong>。在发生代码无法处理<code>SIGTERM</code>的情况下，docker守护进程等待10秒钟后发出<code>SIGKILL</code>强制退出。</li>
</ul>
<h4 id="不常用的一些-exit-code">不常用的一些 Exit Code</h4>
<ul>
<li><code>Exit 126</code>: 权限问题或命令不可执行</li>
<li><code>Exit 127</code>:
Shell脚本中可能出现错字且字符无法识别的情况</li>
<li><code>Exit 1 或 255</code>：因为很多程序员写异常退出时习惯用 exit(1)
或 exit(-1)，-1 会根据转换规则转成 255。这个一般是自定义
code，要看具体逻辑。</li>
</ul>
<h3 id="附录具有特殊含义的退出代码">附录：具有特殊含义的退出代码</h3>
<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 25%" />
<col style="width: 20%" />
<col style="width: 45%" />
</colgroup>
<thead>
<tr class="header">
<th>退出状态代码</th>
<th>含义</th>
<th>例子</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>捕获一般错误</td>
<td>let "var1 = 1 / 0"</td>
<td>各种各样的错误，例如“除以零”和其他不允许的操作</td>
</tr>
<tr class="even">
<td>2</td>
<td>滥用shell内置函数（根据bash文档）</td>
<td>empty_function() {}</td>
<td>缺少关键字或命令，或权限问题（以及二进制文件比较失败的差异返回代码）</td>
</tr>
<tr class="odd">
<td>126</td>
<td>调用的命令无法执行</td>
<td>/dev/null</td>
<td>权限问题或命令不是可执行文件</td>
</tr>
<tr class="even">
<td>127</td>
<td>调用的命令找不到</td>
<td>illegal_command</td>
<td><span class="math inline">\(PATH 拼写错误或者可能有问题 | | 128 |
退出参数无效 | exit 3.14159 | exit 只接受 0 - 255 范围内的整数参数 | |
128+n | 致命错误信号 | *kill -9* `\)</span>PPID` of script</td>
</tr>
<tr class="odd">
<td>130</td>
<td>由 Ctrl-C 终止的脚本</td>
<td>Ctrl-C</td>
<td>Ctrl-C 是致命错误，错误信号是2</td>
</tr>
<tr class="even">
<td>255*</td>
<td>退出状态超出范围</td>
<td>exit -1</td>
<td>exit 只接受 0 - 255 范围内的整数</td>
</tr>
</tbody>
</table>
<ul>
<li>根据上表，退出代码 1 - 2、126 - 165 和 255 [1]
具有特殊含义，因此对于用户指定的退出参数应避免使用。 以退出 127
结束脚本肯定会在故障排除时引起混淆（错误代码是“找不到命令”还是用户定义的？）。
但是，许多脚本使用退出 1 作为一般的错误救助。 <strong>由于退出代码 1
表示许多可能的错误，因此它在调试中并不是特别有用。</strong></li>
</ul>
]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes集群实践（四）如何在集群中使用网络存储系统NFS</title>
    <url>/p/how-to-use-nfs-in-k8s/</url>
    <content><![CDATA[<p>由于需要在Pods中共享文件，直接挂载到宿主机肯定不行的。因此需要有一套网络存储系统。</p>
<p>本文主要介绍如何在K8s中使用网络存储系统NFS。</p>
<p>关键词：<strong>k8s</strong></p>
<span id="more"></span>
<h3 id="准备工作">准备工作</h3>
<ul>
<li>安装好Kubernetes的集群</li>
<li>Ubuntu 20.04 LTS</li>
</ul>
<h3 id="安装服务端">安装服务端</h3>
<p>一般在集群外部安装服务端，这样可以降低集群的负载。这里只是测试用，因此<strong>在master节点</strong>上安装服务端。</p>
<h4 id="安装">安装</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install nfs-kernel-server</span><br></pre></td></tr></table></figure>
<h4 id="创建要共享的目录">创建要共享的目录</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /data/nfsshare -p</span><br></pre></td></tr></table></figure>
<h4 id="编辑nfs配置">编辑nfs配置</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/exports</span><br></pre></td></tr></table></figure>
<p><img data-src="image-20220512133120131.png" /></p>
<p>其中IP是允许访问的网段，</p>
<ul>
<li>rw：访问到此目录的服务器都具备读写权限</li>
<li>sync：数据同步写入内存和硬盘，与其相对的是<code>async</code>（只在必要的时候写入内存和硬盘）</li>
<li>all_squash：共享文件的UID和GID映射匿名用户anonymous，适合公用目录</li>
<li>no_subtree_check：不检查父目录的权限</li>
<li>anonuid=1000：指定nfs服务器<code>/etc/passwd</code>文件中匿名用户的UID</li>
<li>anongid=1000：指定nfs服务器/<code>etc/passwd</code>文件中匿名用户的GID</li>
</ul>
<p>使用映射匿名用户UID和GID，同时设置匿名用户的UID和GID，可以避免<strong>NFS服务器的权限问题。</strong></p>
<h4 id="载入配置">载入配置</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo exportfs -rv</span><br></pre></td></tr></table></figure>
<h4 id="启动服务">启动服务</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> nfs-kernel-server --now </span><br></pre></td></tr></table></figure>
<h4 id="服务检查">服务检查</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /var/lib/nfs/etab</span><br></pre></td></tr></table></figure>
<p><img data-src="image-20220512112029175.png" /></p>
<p>查看NFS共享情况</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$showmount</span> -e 192.168.15.201</span><br><span class="line">/home/wf09/nfsfiles 192.168.15.0/24</span><br></pre></td></tr></table></figure>
<p>其中IP是nfs-server的IP。</p>
<h3 id="安装客户端">安装客户端</h3>
<p>集群中需要使用NFS存储的机器<strong>都需要安装客户端！</strong>不然使用NFS作为存储的Pod就会一直提示<code>Init:0/1</code></p>
<p><img data-src="image-20220512112529311.png" /></p>
<p>这里使用之前配置好的xcall脚本去进行调用。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install nfs-common -y<span class="string">&quot;</span></span><br></pre></td></tr></table></figure>
<p><img data-src="image-20220512112427702.png" /></p>
<h3 id="使用nfs作为存储卷">使用nfs作为存储卷</h3>
<p>使用NFS作为存储方式有以下几种</p>
<h4
id="在deploymentstatefulset中直接使用">在deployment/statefulset中直接使用</h4>
<h5 id="创建一个deployment资源清单">创建一个deployment资源清单</h5>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">backend-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">backend</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">backend</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">jar</span></span><br><span class="line">        <span class="attr">emptyDir:</span> &#123;&#125;</span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nfsfiles</span>              <span class="comment"># 卷名称</span></span><br><span class="line">        <span class="attr">nfs:</span>                        <span class="comment"># 使用NFS作为存储卷</span></span><br><span class="line">          <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.15</span><span class="number">.201</span>    <span class="comment"># NFS服务地址</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">/home/wf09/nfsfiles</span> <span class="comment"># NFS服务器共享的目录</span></span><br><span class="line">          <span class="attr">readOnly:</span> <span class="literal">false</span>           <span class="comment"># 是否为只读</span></span><br><span class="line">      <span class="attr">initContainers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">tool</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">harbor.local/zheshiyou/backend</span></span><br><span class="line">        <span class="attr">command:</span> [<span class="string">&quot;cp&quot;</span>, <span class="string">&quot;/app.jar&quot;</span>, <span class="string">&quot;/jar&quot;</span>]</span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">jar</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/jar</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">backend</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">harbor.local/zheshiyou/jre:latest</span></span><br><span class="line">        <span class="attr">command:</span> [<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar&quot;</span>, <span class="string">&quot;/jar/app.jar&quot;</span>]</span><br><span class="line">        <span class="comment">#command: [&quot;bash&quot;,&quot;-c&quot;, &quot;while true ; do continue ; done&quot;]</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">server</span></span><br><span class="line">          <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">jar</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/jar</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nfsfiles</span>                <span class="comment"># 卷挂载到容器中的目录</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/share</span>             <span class="comment"># 卷名称</span></span><br></pre></td></tr></table></figure>
<p>上面的示例定义在资源配置文件deployment.yaml中，其中的Pod资源拥有一个关联至NFS服务器192.168.15.201的存储卷，backend容器将其挂载到容器中的/share目录上，它是backend容器中的需要持久化的目录。</p>
<h5 id="创建deployment并查看配置信息">创建deployment并查看配置信息</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f deployment.yml</span><br></pre></td></tr></table></figure>
<p>查看配置信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get pods -o wide -l app=backend</span><br></pre></td></tr></table></figure>
<p><img data-src="image-20220512113720297.png" /></p>
<p>查看deployment中某一个pod的调度信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl describe pods/backend-deployment-7b44ccc689-bvdm6</span><br></pre></td></tr></table></figure>
<p>可知调度成功</p>
<p><img data-src="image-20220512114009179.png" /></p>
<h4 id="查看容器挂载情况">查看容器挂载情况</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl <span class="built_in">exec</span> -it backend-deployment-7b44ccc689-bvdm6 -- <span class="built_in">df</span> -hT</span><br></pre></td></tr></table></figure>
<p><img data-src="image-20220512114335873.png" /></p>
<h4 id="测试数据持久化访问">测试数据持久化访问</h4>
<p>模拟正常资源调度情况：在某一Pod存放文件，然后登录到其他的Pod查看文件是否共享成功。</p>
<ol type="1">
<li><p>登录到某一Pod</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl <span class="built_in">exec</span> -ti backend-deployment-7b44ccc689-bvdm6 bash</span><br></pre></td></tr></table></figure></li>
<li><p>生成10M文件，模拟正常PDF大小</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=<span class="built_in">test</span> bs=1M count=10</span><br></pre></td></tr></table></figure></li>
<li><p>登录到其他Pod，查看文件是否存在</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl <span class="built_in">exec</span> backend-deployment-7b44ccc689-l949v -- <span class="built_in">ls</span> -lh /share</span><br></pre></td></tr></table></figure></p></li>
</ol>
<p><img data-src="image-20220512133823379.png" /></p>
<h3 id="附录">附录</h3>
<p>NFS共享参数说明</p>
<table>
<colgroup>
<col style="width: 21%" />
<col style="width: 78%" />
</colgroup>
<thead>
<tr class="header">
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ro</td>
<td>只读访问</td>
</tr>
<tr class="even">
<td>rw</td>
<td>读写访问</td>
</tr>
<tr class="odd">
<td>sync</td>
<td>同步写入，同时将数据写入内存和硬盘中，保证不丢失数据</td>
</tr>
<tr class="even">
<td>async</td>
<td>异步写入，优先将数据写入内存，然后再写入到硬盘，可能会丢失数据</td>
</tr>
<tr class="odd">
<td>secure</td>
<td>nfs通过1024以下的安全TCP端口发送</td>
</tr>
<tr class="even">
<td>insecure</td>
<td>nfs通过1024以上的端口发送</td>
</tr>
<tr class="odd">
<td>wdelay</td>
<td>如果多个用户要写入NFS目录，则归组写入<strong>（默认）</strong></td>
</tr>
<tr class="even">
<td>no_wdelay</td>
<td>如果多个用户要写入NFS目录，则立即写入。当使用async时，无需此设置</td>
</tr>
<tr class="odd">
<td>hide</td>
<td>不共享nfs目录的子目录</td>
</tr>
<tr class="even">
<td>no_hide</td>
<td>共享nfs目录的子目录</td>
</tr>
<tr class="odd">
<td>subtree_check</td>
<td>如果共享/usr/bin之类的子目录时，强制nfs检查父目录的权限<strong>（默认）</strong></td>
</tr>
<tr class="even">
<td>no_subtree_check</td>
<td>不检查父目录的权限</td>
</tr>
<tr class="odd">
<td>all_squash</td>
<td>共享文件的UID和GID映射匿名用户anonymous，适合公用目录</td>
</tr>
<tr class="even">
<td>no_all_squash</td>
<td>保留共享文件的UID和GID<strong>（默认）</strong></td>
</tr>
<tr class="odd">
<td>root_squash</td>
<td>root用户的所有请求映射成如anonymous用户一样的权限<strong>（默认）</strong></td>
</tr>
<tr class="even">
<td>no_root_squash</td>
<td>root用户具有根目录的完全管理访问权限</td>
</tr>
<tr class="odd">
<td>anonuid=xxx</td>
<td>指定nfs服务器/etc/passwd文件中匿名用户的UID</td>
</tr>
<tr class="even">
<td>anongid=xxx</td>
<td>指定nfs服务器/etc/passwd文件中匿名用户的GID</td>
</tr>
</tbody>
</table>
]]></content>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes集群实践（三）集群外如何访问K8s内的Service</title>
    <url>/p/service-access-application-cluster/</url>
    <content><![CDATA[<p>本文主要介绍<strong>集群外如何访问K8s内的Service</strong>。</p>
<p>关键词：<strong>k8s</strong></p>
<span id="more"></span>
<h3 id="准备工作">准备工作</h3>
<p>这里是使用的开启了k8s集群的<strong>Docker Desktop For
Mac</strong>。在Windows/Mac上使用K8s in Docker请查看上一篇文章。</p>
<p><img data-src="image-20220501231242091.png" /></p>
<h3 id="创建developments">创建Developments</h3>
<p>Deployment 是在 Pod 上层的一个抽象，它可以定义一组 Pod
的副本数目、以及这个 Pod 的版本。一般用 Deployment
这个抽象来做应用的真正的管理，而 Pod 是组成 Deployment 最小的单元。</p>
<p>Kubernetes 是通过 Controller，也就是我们刚才提到的控制器去维护
Deployment 中 Pod 的数目，它也会去帮助 Deployment 自动恢复失败的
Pod。</p>
<p>这里的给出一个Development的定义：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">jixiao-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">jixiao</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">jixiao</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">jixiao</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">jixiao-jar</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">Never</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure>
<p>TIPS：</p>
<ul>
<li>这里使用的是本地镜像，因此<code>imagePullPolicy</code>设置为<code>Never</code></li>
<li>containerPort指的是Pod向外部暴露的端口</li>
</ul>
<h3 id="创建service">创建Service</h3>
<p>Service 提供了一个或者多个 Pod 实例的稳定访问地址。</p>
<p>可以理解为Service 是 Pod和外部访问的桥梁。</p>
<p>通过Servide访问Pod应用有多种方式，这里给出<strong>通过Service
连接到Pod，并通过端口转发访问的方式</strong>。</p>
<p>这里创建一个Service：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">jixiao</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">jixiao</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">8080</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">jixiao</span></span><br></pre></td></tr></table></figure>
<p>TIPS：</p>
<ul>
<li><p>这里通过<code>.spec.selector.app</code>的Value访问刚刚部署的<code>Developments</code>，<strong>即对应的Value要完全相同才行</strong>，简单理解为<code>app: jixiao</code>要出现在两个配置文件中即可。</p></li>
<li><p><code>targetPort</code>指的是Pod暴露的端口，<code>port</code>指的是在Service中使用的端口。</p></li>
</ul>
<h3
id="集群外访问集群内service的方式">集群外访问集群内Service的方式</h3>
<h4 id="端口转发">端口转发</h4>
<p>转发一个本地端口到Pod端口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl port-forward service/jixiao 7777:80</span><br></pre></td></tr></table></figure>
<p>TIPS：</p>
<ul>
<li>这里的80端口是Service中使用的端口，而不是Pod向外暴露的端口。</li>
</ul>
<p><img data-src="image-20220501234222534.png" /></p>
<h3 id="测试">测试</h3>
<p>新打开一个终端</p>
<p><img data-src="image-20220501234321909.png" /></p>
<h4 id="externalips">externalIPs</h4>
<p>如果外部的 IP 路由到集群中一个或多个 Node 上，Kubernetes Service
会被暴露给这些 <strong>externalIPs</strong>。 通过外部 IP（作为目的 IP
地址）进入到集群，打到 Service 的端口上的流量， 将会被路由到 Service 的
Endpoint 上。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">server</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">server</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">8888</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="string">http</span></span><br><span class="line">  <span class="attr">externalIPs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.15</span><span class="number">.202</span></span><br></pre></td></tr></table></figure>
<p>TIPS：</p>
<p>如上配置可以通过<code>192.168.15.202:8888</code>访问到Service后面的Pods应用。</p>
<h4 id="nodeport">NodePort</h4>
<p>NodePort
服务是引导外部流量到你的服务的最原始方式。NodePort，正如这个名字所示，在所有节点（虚拟机）上开放一个特定端口，任何发送到该端口的流量都被转发到对应服务。</p>
<p>然而，<a
href="https://kuboard.cn/learning/k8s-intermediate/service/service-types.html#nodeport">NodePort</a>
默认范围是30000-32767。这个端口号太大，不适合对外提供服务。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">www2</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">www</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">nodePort:</span> <span class="number">30000</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="string">http</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins实战（二）安装配置Jenkins</title>
    <url>/p/install-and-config-jenkins/</url>
    <content><![CDATA[<p>本文主要介绍安装和配置Jenkins。</p>
<p>关键词：<strong>Jenkins</strong></p>
<span id="more"></span>
<h3 id="准备工作">准备工作</h3>
<ul>
<li>Ubuntu 20.04 LTS</li>
</ul>
<h4 id="安装openjdk">安装OpenJDK</h4>
<h5 id="下载jdk">下载jdk</h5>
<blockquote>
<p>https://www.injdk.cn/</p>
</blockquote>
<p>这里使用Zulu打包的openjdk 11。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://d6.injdk.cn/openjdk/zulu/11/zulu11.43.55-ca-jdk11.0.9.1-linux_amd64.deb</span><br></pre></td></tr></table></figure>
<h5 id="安装">安装</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install ./zulu11.43.55-ca-jdk11.0.9.1-linux_amd64.deb -y</span><br></pre></td></tr></table></figure>
<h4 id="安装jenkins">安装jenkins</h4>
<h5 id="下载jenkins">下载jenkins</h5>
<p>由于众所周知的原因，在国内无法快速访问jenkins.io，这里使用USTC提供的镜像。</p>
<blockquote>
<p>https://mirrors.ustc.edu.cn/jenkins/debian-stable/</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://mirrors.ustc.edu.cn/jenkins/debian-stable/jenkins_2.332.3_all.deb</span><br></pre></td></tr></table></figure>
<h5 id="安装-1">安装</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install fontconfig -y</span><br><span class="line">sudo apt install ./jenkins_2.332.3_all.deb -y</span><br></pre></td></tr></table></figure>
<h3 id="配置jenkins">配置jenkins</h3>
<p>使用systemd，配置文件地址在</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/lib/systemd/system/jenkins.service</span><br></pre></td></tr></table></figure>
<h4 id="修改监听端口">修改监听端口</h4>
<p><img data-src="image-20220509131641758.png" /></p>
<h4 id="启用反向代理">启用反向代理</h4>
<p>这里使用前缀<code>/jenkins</code>进行反向代理</p>
<p><img data-src="image-20220509131731389.png" /></p>
<h5 id="反向代理设置">反向代理设置</h5>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="section">upstream</span> jenkins&#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:8080</span>;                   <span class="comment"># 后端jenkins地址</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">443</span>    ssl;</span><br><span class="line">    <span class="attribute">server_name</span>  jenkins.local;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">access_log</span>  /var/log/nginx/jenkins.access.log  main;</span><br><span class="line">    <span class="attribute">ssl_session_cache</span> shared:SSL:<span class="number">10m</span>;</span><br><span class="line">    <span class="attribute">ssl_certificate</span>     /usr/local/ssl/jenkins.crt;  <span class="comment"># pem文件的路径</span></span><br><span class="line">    <span class="attribute">ssl_certificate_key</span>  /usr/local/ssl/jenkins.key; <span class="comment"># key文件的路径</span></span><br><span class="line">    <span class="attribute">ssl_trusted_certificate</span> /usr/local/ssl/ca.crt;</span><br><span class="line">    <span class="comment">#ssl_reject_handshake on;</span></span><br><span class="line">    <span class="comment"># ssl验证相关配置</span></span><br><span class="line">    <span class="attribute">ssl_session_timeout</span>  <span class="number">10m</span>;    <span class="comment">#缓存有效期</span></span><br><span class="line">    <span class="attribute">ssl_ciphers</span> ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;    <span class="comment">#加密算法</span></span><br><span class="line">    <span class="attribute">ssl_protocols</span> TLSv1 TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span>;    <span class="comment">#安全链接可选的加密协议</span></span><br><span class="line">    <span class="attribute">ssl_prefer_server_ciphers</span> <span class="literal">on</span>;   <span class="comment">#使用服务器端的首选算法</span></span><br><span class="line">    <span class="attribute">ssl_stapling</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">ssl_stapling_verify</span> <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://jenkins;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-Proto <span class="variable">$scheme</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="修改插件地址">修改插件地址</h4>
<blockquote>
<p>https://www.jenkins-zh.cn/tutorial/management/plugin/update-center/</p>
</blockquote>
<p>修改地址，<strong>Dashboard&gt;&gt;&gt;插件管理&gt;&gt;&gt;Plugin
Manager&gt;&gt;&gt;高级</strong></p>
<p><img data-src="image-20220509135702702.png" /></p>
<h4 id="添加ssh密钥">添加SSH密钥</h4>
]]></content>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Docker Compose搭建Harbor镜像仓库</title>
    <url>/p/build-harbor-mirror-warehouse-with-docker-compose/</url>
    <content><![CDATA[<p>Docker容器应用的开发和运行离不开可靠的镜像管理，虽然docker官方提供了公共的镜像仓库（Docker
Hub），但是从安全和效率等方面考虑，部署我们私有环境内的Registry也是非常必要的。Harbor是由VMware公司开源的企业级的Docker
Registry管理项目，它包括权限管理（RBAC）、LDAP、日志审核、界面管理、自我注册、镜像复制和中文支持等功能。</p>
<p>本文主要介绍如何使用Docker Compose搭建Harbor镜像仓库。</p>
<p>关键词：<strong>docker，harbor</strong></p>
<span id="more"></span>
<h3 id="准备工作">准备工作</h3>
<ul>
<li>Mac mini</li>
<li>Docker Desktop For Mac</li>
<li>docker-compose</li>
</ul>
<h3 id="下载安装文件">下载安装文件</h3>
<h4 id="选择离线安装文件">选择离线安装文件</h4>
<blockquote>
<p>https://github.com/goharbor/harbor/releases/download/v2.5.0/harbor-offline-installer-v2.5.0.tgz</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://github.com/goharbor/harbor/releases/download/v2.5.0/harbor-offline-installer-v2.5.0.tgz</span><br></pre></td></tr></table></figure>
<p>解压文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar zxvf harbor-offline-installer-v2.5.0.tgz</span><br></pre></td></tr></table></figure>
<h3 id="修改配置">修改配置</h3>
<h4 id="配置hosts">配置hosts</h4>
<p>harbor要求使用https，因此需要生成本地可信的https证书。这里已经生成好了。</p>
<p>因为是本地使用，所以无需修改DNS，只需要修改hosts。</p>
<p><img data-src="image-20220508201150693.png" /></p>
<h4 id="修改配置文件">修改配置文件</h4>
<p>将模版配置文件修改为配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> harbor.yml.tmpl harbor.yml</span><br></pre></td></tr></table></figure>
<p>修改配置文件，主要是修改https和持久化目录，其他的还没研究。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Configuration file of Harbor</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The IP address or hostname to access admin UI and registry service.</span></span><br><span class="line"><span class="comment"># DO NOT use localhost or 127.0.0.1, because Harbor needs to be accessed by external clients.</span></span><br><span class="line"><span class="attr">hostname:</span> <span class="string">harbor.local</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># http related config</span></span><br><span class="line"><span class="comment"># http:</span></span><br><span class="line"><span class="comment">#   # port for http, default is 80. If https enabled, this port will redirect to https port</span></span><br><span class="line"><span class="comment">#   port: 80</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># https related config</span></span><br><span class="line"><span class="attr">https:</span></span><br><span class="line">  <span class="comment"># https port for harbor, default is 443</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">443</span></span><br><span class="line">  <span class="comment"># The path of cert and key files for nginx</span></span><br><span class="line">  <span class="attr">certificate:</span> <span class="string">harbor.crt</span></span><br><span class="line">  <span class="attr">private_key:</span> <span class="string">harbor.key</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # Uncomment following will enable tls communication between all harbor components</span></span><br><span class="line"><span class="comment"># internal_tls:</span></span><br><span class="line"><span class="comment">#   # set enabled to true means internal tls is enabled</span></span><br><span class="line"><span class="comment">#   enabled: true</span></span><br><span class="line"><span class="comment">#   # put your cert and key files on dir</span></span><br><span class="line"><span class="comment">#   dir: /etc/harbor/tls/internal</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment external_url if you want to enable external proxy</span></span><br><span class="line"><span class="comment"># And when it enabled the hostname will no longer used</span></span><br><span class="line"><span class="comment"># external_url: https://reg.mydomain.com:8433</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The initial password of Harbor admin</span></span><br><span class="line"><span class="comment"># It only works in first time to install harbor</span></span><br><span class="line"><span class="comment"># Remember Change the admin password from UI after launching Harbor.</span></span><br><span class="line"><span class="attr">harbor_admin_password:</span> <span class="string">Harbor12345</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Harbor DB configuration</span></span><br><span class="line"><span class="attr">database:</span></span><br><span class="line">  <span class="comment"># The password for the root user of Harbor DB. Change this before any production use.</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">root123</span></span><br><span class="line">  <span class="comment"># The maximum number of connections in the idle connection pool. If it &lt;=0, no idle connections are retained.</span></span><br><span class="line">  <span class="attr">max_idle_conns:</span> <span class="number">100</span></span><br><span class="line">  <span class="comment"># The maximum number of open connections to the database. If it &lt;= 0, then there is no limit on the number of open connections.</span></span><br><span class="line">  <span class="comment"># <span class="doctag">Note:</span> the default number of connections is 1024 for postgres of harbor.</span></span><br><span class="line">  <span class="attr">max_open_conns:</span> <span class="number">900</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The default data volume</span></span><br><span class="line"><span class="attr">data_volume:</span> <span class="string">/Users/wf09/Desktop/docker/harbor/data</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Harbor Storage settings by default is using /data dir on local filesystem</span></span><br><span class="line"><span class="comment"># Uncomment storage_service setting If you want to using external storage</span></span><br><span class="line"><span class="comment"># storage_service:</span></span><br><span class="line"><span class="comment">#   # ca_bundle is the path to the custom root ca certificate, which will be injected into the truststore</span></span><br><span class="line"><span class="comment">#   # of registry&#x27;s and chart repository&#x27;s containers.  This is usually needed when the user hosts a internal storage with self signed certificate.</span></span><br><span class="line"><span class="comment">#   ca_bundle:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#   # storage backend, default is filesystem, options include filesystem, azure, gcs, s3, swift and oss</span></span><br><span class="line"><span class="comment">#   # for more info about this configuration please refer https://docs.docker.com/registry/configuration/</span></span><br><span class="line"><span class="comment">#   filesystem:</span></span><br><span class="line"><span class="comment">#     maxthreads: 100</span></span><br><span class="line"><span class="comment">#   # set disable to true when you want to disable registry redirect</span></span><br><span class="line"><span class="comment">#   redirect:</span></span><br><span class="line"><span class="comment">#     disabled: false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Trivy configuration</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Trivy DB contains vulnerability information from NVD, Red Hat, and many other upstream vulnerability databases.</span></span><br><span class="line"><span class="comment"># It is downloaded by Trivy from the GitHub release page https://github.com/aquasecurity/trivy-db/releases and cached</span></span><br><span class="line"><span class="comment"># in the local file system. In addition, the database contains the update timestamp so Trivy can detect whether it</span></span><br><span class="line"><span class="comment"># should download a newer version from the Internet or use the cached one. Currently, the database is updated every</span></span><br><span class="line"><span class="comment"># 12 hours and published as a new release to GitHub.</span></span><br><span class="line"><span class="attr">trivy:</span></span><br><span class="line">  <span class="comment"># ignoreUnfixed The flag to display only fixed vulnerabilities</span></span><br><span class="line">  <span class="attr">ignore_unfixed:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># skipUpdate The flag to enable or disable Trivy DB downloads from GitHub</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment"># You might want to enable this flag in test or CI/CD environments to avoid GitHub rate limiting issues.</span></span><br><span class="line">  <span class="comment"># If the flag is enabled you have to download the `trivy-offline.tar.gz` archive manually, extract `trivy.db` and</span></span><br><span class="line">  <span class="comment"># `metadata.json` files and mount them in the `/home/scanner/.cache/trivy/db` path.</span></span><br><span class="line">  <span class="attr">skip_update:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment"># The offline_scan option prevents Trivy from sending API requests to identify dependencies.</span></span><br><span class="line">  <span class="comment"># Scanning JAR files and pom.xml may require Internet access for better detection, but this option tries to avoid it.</span></span><br><span class="line">  <span class="comment"># For example, the offline mode will not try to resolve transitive dependencies in pom.xml when the dependency doesn&#x27;t</span></span><br><span class="line">  <span class="comment"># exist in the local repositories. It means a number of detected vulnerabilities might be fewer in offline mode.</span></span><br><span class="line">  <span class="comment"># It would work if all the dependencies are in local.</span></span><br><span class="line">  <span class="comment"># This option doesn’t affect DB download. You need to specify &quot;skip-update&quot; as well as &quot;offline-scan&quot; in an air-gapped environment.</span></span><br><span class="line">  <span class="attr">offline_scan:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment"># insecure The flag to skip verifying registry certificate</span></span><br><span class="line">  <span class="attr">insecure:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># github_token The GitHub access token to download Trivy DB</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment"># Anonymous downloads from GitHub are subject to the limit of 60 requests per hour. Normally such rate limit is enough</span></span><br><span class="line">  <span class="comment"># for production operations. If, for any reason, it&#x27;s not enough, you could increase the rate limit to 5000</span></span><br><span class="line">  <span class="comment"># requests per hour by specifying the GitHub access token. For more details on GitHub rate limiting please consult</span></span><br><span class="line">  <span class="comment"># https://developer.github.com/v3/#rate-limiting</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment"># You can create a GitHub token by following the instructions in</span></span><br><span class="line">  <span class="comment"># https://help.github.com/en/github/authenticating-to-github/creating-a-personal-access-token-for-the-command-line</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment"># github_token: xxx</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobservice:</span></span><br><span class="line">  <span class="comment"># Maximum number of job workers in job service</span></span><br><span class="line">  <span class="attr">max_job_workers:</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="attr">notification:</span></span><br><span class="line">  <span class="comment"># Maximum retry count for webhook job</span></span><br><span class="line">  <span class="attr">webhook_job_max_retry:</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="attr">chart:</span></span><br><span class="line">  <span class="comment"># Change the value of absolute_url to enabled can enable absolute url in chart</span></span><br><span class="line">  <span class="attr">absolute_url:</span> <span class="string">disabled</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Log configurations</span></span><br><span class="line"><span class="attr">log:</span></span><br><span class="line">  <span class="comment"># options are debug, info, warning, error, fatal</span></span><br><span class="line">  <span class="attr">level:</span> <span class="string">info</span></span><br><span class="line">  <span class="comment"># configs for logs in local storage</span></span><br><span class="line">  <span class="attr">local:</span></span><br><span class="line">    <span class="comment"># Log files are rotated log_rotate_count times before being removed. If count is 0, old versions are removed rather than rotated.</span></span><br><span class="line">    <span class="attr">rotate_count:</span> <span class="number">50</span></span><br><span class="line">    <span class="comment"># Log files are rotated only if they grow bigger than log_rotate_size bytes. If size is followed by k, the size is assumed to be in kilobytes.</span></span><br><span class="line">    <span class="comment"># If the M is used, the size is in megabytes, and if G is used, the size is in gigabytes. So size 100, size 100k, size 100M and size 100G</span></span><br><span class="line">    <span class="comment"># are all valid.</span></span><br><span class="line">    <span class="attr">rotate_size:</span> <span class="string">200M</span></span><br><span class="line">    <span class="comment"># The directory on your host that store log</span></span><br><span class="line">    <span class="attr">location:</span> <span class="string">/var/log/harbor</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Uncomment following lines to enable external syslog endpoint.</span></span><br><span class="line">  <span class="comment"># external_endpoint:</span></span><br><span class="line">  <span class="comment">#   # protocol used to transmit log to external endpoint, options is tcp or udp</span></span><br><span class="line">  <span class="comment">#   protocol: tcp</span></span><br><span class="line">  <span class="comment">#   # The host of external endpoint</span></span><br><span class="line">  <span class="comment">#   host: localhost</span></span><br><span class="line">  <span class="comment">#   # Port of external endpoint</span></span><br><span class="line">  <span class="comment">#   port: 5140</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#This attribute is for migrator to detect the version of the .cfg file, DO NOT MODIFY!</span></span><br><span class="line"><span class="attr">_version:</span> <span class="number">2.5</span><span class="number">.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment external_database if using external database.</span></span><br><span class="line"><span class="comment"># external_database:</span></span><br><span class="line"><span class="comment">#   harbor:</span></span><br><span class="line"><span class="comment">#     host: harbor_db_host</span></span><br><span class="line"><span class="comment">#     port: harbor_db_port</span></span><br><span class="line"><span class="comment">#     db_name: harbor_db_name</span></span><br><span class="line"><span class="comment">#     username: harbor_db_username</span></span><br><span class="line"><span class="comment">#     password: harbor_db_password</span></span><br><span class="line"><span class="comment">#     ssl_mode: disable</span></span><br><span class="line"><span class="comment">#     max_idle_conns: 2</span></span><br><span class="line"><span class="comment">#     max_open_conns: 0</span></span><br><span class="line"><span class="comment">#   notary_signer:</span></span><br><span class="line"><span class="comment">#     host: notary_signer_db_host</span></span><br><span class="line"><span class="comment">#     port: notary_signer_db_port</span></span><br><span class="line"><span class="comment">#     db_name: notary_signer_db_name</span></span><br><span class="line"><span class="comment">#     username: notary_signer_db_username</span></span><br><span class="line"><span class="comment">#     password: notary_signer_db_password</span></span><br><span class="line"><span class="comment">#     ssl_mode: disable</span></span><br><span class="line"><span class="comment">#   notary_server:</span></span><br><span class="line"><span class="comment">#     host: notary_server_db_host</span></span><br><span class="line"><span class="comment">#     port: notary_server_db_port</span></span><br><span class="line"><span class="comment">#     db_name: notary_server_db_name</span></span><br><span class="line"><span class="comment">#     username: notary_server_db_username</span></span><br><span class="line"><span class="comment">#     password: notary_server_db_password</span></span><br><span class="line"><span class="comment">#     ssl_mode: disable</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment external_redis if using external Redis server</span></span><br><span class="line"><span class="comment"># external_redis:</span></span><br><span class="line"><span class="comment">#   # support redis, redis+sentinel</span></span><br><span class="line"><span class="comment">#   # host for redis: &lt;host_redis&gt;:&lt;port_redis&gt;</span></span><br><span class="line"><span class="comment">#   # host for redis+sentinel:</span></span><br><span class="line"><span class="comment">#   #  &lt;host_sentinel1&gt;:&lt;port_sentinel1&gt;,&lt;host_sentinel2&gt;:&lt;port_sentinel2&gt;,&lt;host_sentinel3&gt;:&lt;port_sentinel3&gt;</span></span><br><span class="line"><span class="comment">#   host: redis:6379</span></span><br><span class="line"><span class="comment">#   password: </span></span><br><span class="line"><span class="comment">#   # sentinel_master_set must be set to support redis+sentinel</span></span><br><span class="line"><span class="comment">#   #sentinel_master_set:</span></span><br><span class="line"><span class="comment">#   # db_index 0 is for core, it&#x27;s unchangeable</span></span><br><span class="line"><span class="comment">#   registry_db_index: 1</span></span><br><span class="line"><span class="comment">#   jobservice_db_index: 2</span></span><br><span class="line"><span class="comment">#   chartmuseum_db_index: 3</span></span><br><span class="line"><span class="comment">#   trivy_db_index: 5</span></span><br><span class="line"><span class="comment">#   idle_timeout_seconds: 30</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment uaa for trusting the certificate of uaa instance that is hosted via self-signed cert.</span></span><br><span class="line"><span class="comment"># uaa:</span></span><br><span class="line"><span class="comment">#   ca_file: /path/to/ca</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Global proxy</span></span><br><span class="line"><span class="comment"># Config http proxy for components, e.g. http://my.proxy.com:3128</span></span><br><span class="line"><span class="comment"># Components doesn&#x27;t need to connect to each others via http proxy.</span></span><br><span class="line"><span class="comment"># Remove component from `components` array if want disable proxy</span></span><br><span class="line"><span class="comment"># for it. If you want use proxy for replication, MUST enable proxy</span></span><br><span class="line"><span class="comment"># for core and jobservice, and set `http_proxy` and `https_proxy`.</span></span><br><span class="line"><span class="comment"># Add domain to the `no_proxy` field, when you want disable proxy</span></span><br><span class="line"><span class="comment"># for some special registry.</span></span><br><span class="line"><span class="attr">proxy:</span></span><br><span class="line">  <span class="attr">http_proxy:</span></span><br><span class="line">  <span class="attr">https_proxy:</span></span><br><span class="line">  <span class="attr">no_proxy:</span></span><br><span class="line">  <span class="attr">components:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">core</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">jobservice</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">trivy</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># metric:</span></span><br><span class="line"><span class="comment">#   enabled: false</span></span><br><span class="line"><span class="comment">#   port: 9090</span></span><br><span class="line"><span class="comment">#   path: /metrics</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Trace related config</span></span><br><span class="line"><span class="comment"># only can enable one trace provider(jaeger or otel) at the same time,</span></span><br><span class="line"><span class="comment"># and when using jaeger as provider, can only enable it with agent mode or collector mode.</span></span><br><span class="line"><span class="comment"># if using jaeger collector mode, uncomment endpoint and uncomment username, password if needed</span></span><br><span class="line"><span class="comment"># if using jaeger agetn mode uncomment agent_host and agent_port</span></span><br><span class="line"><span class="comment"># trace:</span></span><br><span class="line"><span class="comment">#   enabled: true</span></span><br><span class="line"><span class="comment">#   # set sample_rate to 1 if you wanna sampling 100% of trace data; set 0.5 if you wanna sampling 50% of trace data, and so forth</span></span><br><span class="line"><span class="comment">#   sample_rate: 1</span></span><br><span class="line"><span class="comment">#   # # namespace used to differenciate different harbor services</span></span><br><span class="line"><span class="comment">#   # namespace:</span></span><br><span class="line"><span class="comment">#   # # attributes is a key value dict contains user defined attributes used to initialize trace provider</span></span><br><span class="line"><span class="comment">#   # attributes:</span></span><br><span class="line"><span class="comment">#   #   application: harbor</span></span><br><span class="line"><span class="comment">#   # # jaeger should be 1.26 or newer.</span></span><br><span class="line"><span class="comment">#   # jaeger:</span></span><br><span class="line"><span class="comment">#   #   endpoint: http://hostname:14268/api/traces</span></span><br><span class="line"><span class="comment">#   #   username:</span></span><br><span class="line"><span class="comment">#   #   password:</span></span><br><span class="line"><span class="comment">#   #   agent_host: hostname</span></span><br><span class="line"><span class="comment">#   #   # export trace data by jaeger.thrift in compact mode</span></span><br><span class="line"><span class="comment">#   #   agent_port: 6831</span></span><br><span class="line"><span class="comment">#   # otel:</span></span><br><span class="line"><span class="comment">#   #   endpoint: hostname:4318</span></span><br><span class="line"><span class="comment">#   #   url_path: /v1/traces</span></span><br><span class="line"><span class="comment">#   #   compression: false</span></span><br><span class="line"><span class="comment">#   #   insecure: true</span></span><br><span class="line"><span class="comment">#   #   timeout: 10s</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># enable purge _upload directories</span></span><br><span class="line"><span class="attr">upload_purging:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># remove files in _upload directories which exist for a period of time, default is one week.</span></span><br><span class="line">  <span class="attr">age:</span> <span class="string">168h</span></span><br><span class="line">  <span class="comment"># the interval of the purge operations</span></span><br><span class="line">  <span class="attr">interval:</span> <span class="string">24h</span></span><br><span class="line">  <span class="attr">dryrun:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h3 id="安装运行">安装运行</h3>
<p>harbor目录下执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./install.sh</span><br></pre></td></tr></table></figure>
<p>有下图所示说明启动成功</p>
<p><img data-src="image-20220508212557479.png" /></p>
<h3 id="排错">排错</h3>
<h4
id="filenotfounderror-errno-2-no-such-file-or-directory-hostfsharbor.key">FileNotFoundError:
[Errno 2] No such file or directory: '/hostfs/harbor.key'</h4>
<p><img data-src="image-20220508205215581.png" /></p>
<p>好像是<code>./prepare</code>脚本编写错误，按照下面issus提到的修改</p>
<blockquote>
<p>https://github.com/goharbor/harbor/issues/13465</p>
</blockquote>
<p><img data-src="image-20220508205501816.png" /></p>
<p>再次运行<code>./prepare</code>，成功</p>
<p><img data-src="image-20220508205609714.png" /></p>
<h4 id="浏览器访问过慢">浏览器访问过慢</h4>
<p>考虑和SSL证书的OCSP装订有关。</p>
]]></content>
      <tags>
        <tag>docker</tag>
        <tag>harbor</tag>
      </tags>
  </entry>
  <entry>
    <title>使用OpenSSL创建自签名ecc证书</title>
    <url>/p/create-a-self-signed-certificate-with-openSSL/</url>
    <content><![CDATA[<p>在搭建服务时，时不时需要使用https证书。而内网环境最好是使用自签名证书，便于管理。</p>
<p>至于为什么要生成ECC证书而不是用RSA证书：ECC证书相对于RSA证书来说，体积小且速度快，而且内网使用不需要考虑兼容性。</p>
<p>本文主要介绍如何使用OpenSSL创建自签名ecc证书。</p>
<p>关键词：<strong>openssl，https</strong></p>
<span id="more"></span>
<h3 id="准备工作">准备工作</h3>
<ul>
<li>Mac mini</li>
<li>LibreSSL 2.8.3</li>
</ul>
<p>这里还需要修改一下openssl的默认配置，使其可以生成版本v3的证书：</p>
<p><img data-src="image-20220508170638980.png" /></p>
<h3 id="生成ca根证书">生成CA根证书</h3>
<p>为什么要使用CA根证书呢？</p>
<p>使用自定义CA签发本地使用的https证书，便于管理：<strong>只需要把导入CA根证书，主机就可以正常使用自签名的证书。</strong></p>
<h4 id="生成ca根证书的私钥">生成CA根证书的私钥</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl ecparam -genkey -name prime256v1 -out ca.key</span><br></pre></td></tr></table></figure>
<h4 id="生成ca根证书-1">生成CA根证书</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl req -new -x509 -subj <span class="string">&quot;/C=CN/CN=Root\ CA&quot;</span>  -days 7305 -key ca.key -out ca.crt -extensions v3_ca </span><br></pre></td></tr></table></figure>
<p>这里的C=CN指的是国别代码，CN=Root CA的含义是CA根证书的名称是Root
CA。</p>
<h4 id="查看根证书详细信息">查看根证书详细信息</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl x509 -<span class="keyword">in</span> ca.crt -text -noout</span><br></pre></td></tr></table></figure>
<p><img data-src="image-20220508171315027.png" /></p>
<h3 id="生成域名证书">生成域名证书</h3>
<h4 id="生成域名证书的私钥">生成域名证书的私钥</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl ecparam -genkey -name prime256v1 -out harbor.key</span><br></pre></td></tr></table></figure>
<h4 id="生成域名证书签名请求csr">生成域名证书签名请求CSR</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl req -new -sha256 -subj <span class="string">&quot;/C=CN/CN=harbor.local&quot;</span> -key harbor.key -out harbor.local.csr</span><br></pre></td></tr></table></figure>
<h4 id="生成域名证书-1">生成域名证书</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl x509 -req -days 7305 -sha256 -CA ca.crt -CAkey ca.key -CAcreateserial -<span class="keyword">in</span> harbor.local.csr -out harbor.crt -extensions v3_ca</span><br></pre></td></tr></table></figure>
<h4 id="查看域名证书详细信息">查看域名证书详细信息</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl x509 -<span class="keyword">in</span> harbor.crt -text -noout</span><br></pre></td></tr></table></figure>
<p><img data-src="image-20220508172238988.png" /></p>
<p>此时发现生成的证书版本并不是V3，需要一些信息修正。</p>
<p>创建<code>v3.ext</code>文件，输入以下内容</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">authorityKeyIdentifier</span>=keyid,issuer</span><br><span class="line"><span class="attr">basicConstraints</span>=CA:<span class="literal">FALSE</span></span><br><span class="line"><span class="attr">keyUsage</span> = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment</span><br><span class="line"><span class="attr">subjectAltName</span> = @alt_names</span><br><span class="line"></span><br><span class="line"><span class="section">[alt_names]</span></span><br><span class="line"><span class="attr">DNS.1</span> = localhost</span><br></pre></td></tr></table></figure>
<h4 id="再次生成域名证书">再次生成域名证书</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl x509 -req -days 7305 -sha256 -CA ca.crt -CAkey ca.key -CAcreateserial -<span class="keyword">in</span> harbor.local.csr -out harbor.crt -extfile v3.ext</span><br></pre></td></tr></table></figure>
<h4
id="再次查看生成域名证书的详细信息">再次查看生成域名证书的详细信息</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl x509 -<span class="keyword">in</span> harbor.crt -text -noout</span><br></pre></td></tr></table></figure>
<p><img data-src="image-20220508172652252.png" /></p>
<p>此时成功创建版本v3的ecc域名证书。</p>
<h3 id="导入ca证书">导入CA证书</h3>
<h4 id="mac-os">Mac OS</h4>
<ol type="1">
<li>打开钥匙串，找到证书</li>
</ol>
<p><img data-src="image-20220508173309850.png" /></p>
<ol start="2" type="1">
<li>将需要导入的CA证书移动到空白处，此时会发现证书未被信任</li>
</ol>
<p><img data-src="image-20220508173356932.png" /></p>
<ol start="3" type="1">
<li>右键此证书，查看简介，选择信任，修改选项使用此证书为<strong>始终信任</strong></li>
</ol>
<p><img data-src="image-20220508173609105.png" /></p>
<ol start="4" type="1">
<li>在钥匙串打开该CA签发域名证书的证书，会发现<strong>域名证书已经被信任</strong>。</li>
</ol>
<p><img data-src="image-20220508173744194.png" /></p>
<h4 id="windows">Windows</h4>
<ol type="1">
<li>右键需要导入的根证书，选择安装，选择<strong>导入本地计算机</strong></li>
</ol>
<p><img data-src="image-20220508174220492.png" /></p>
<ol start="2" type="1">
<li>选择<strong>将证书放入下列存储</strong>，选择<strong>受信任的证书颁发机构</strong></li>
</ol>
<p><img data-src="image-20220508174340109.png" /></p>
<ol start="3" type="1">
<li>完成向导</li>
</ol>
<p><img data-src="image-20220508174403758.png" /></p>
<ol start="4" type="1">
<li>右键该CA签发的证书，此时发现证书没有问题。</li>
</ol>
<p><img data-src="image-20220508174651903.png" /></p>
<h4 id="linux">Linux</h4>
<p>大部分情况下我们都是在Linux系统上操作导入根证书的。</p>
<p>这里以Ubuntu为例</p>
<ol type="1">
<li><p>在目录<code>/usr/share/ca-certificates</code>下创建一个存放额外证书的文件夹</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> -p /usr/share/ca-certificates/local</span><br></pre></td></tr></table></figure></li>
<li><p>拷贝证书到证书文件夹</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">cp</span> ca.crt /usr/share/ca-certificates/local/</span><br></pre></td></tr></table></figure></li>
<li><p>执行以下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo dpkg-reconfigure ca-certificates</span><br></pre></td></tr></table></figure>
<p><img data-src="image-20220508175418532.png" /></p></li>
</ol>
<p>​ 选择yes，然后会提示选择证书，敲一下回车，ca证书就被选中</p>
<p>​ <img data-src="image-20220508175641724.png" /></p>
<ol start="4" type="1">
<li><p>导入成功</p>
<p><img data-src="image-20220508175724957.png" /></p></li>
</ol>
]]></content>
      <tags>
        <tag>openssl</tag>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Helm中部署Harbor</title>
    <url>/p/deploy-harbor-on-K8s-with-helm/</url>
    <content><![CDATA[<p>Harbor 是一个开源的企业级私有 Docker 镜像仓库，我们可以利用 Harbor
在本地安全地存储和管理 Docker 镜像，而不需要将镜像上传到 Docker Hub
或其他第三方镜像仓库。</p>
<p>关键词：<strong>Harbor</strong></p>
<span id="more"></span>
<h3 id="安装helm">安装Helm</h3>
<p>我们将 Helm 客户端安装在 k8s-master 节点上</p>
<h4 id="用二进制版本安装">用二进制版本安装</h4>
<ol type="1">
<li>下载 <a
href="https://github.com/helm/helm/releases">需要的版本</a></li>
<li>解压(<code>tar -zxvf helm-v3.0.0-linux-amd64.tar.gz</code>)</li>
<li>在解压目中找到<code>helm</code>程序，移动到需要的目录中(<code>mv linux-amd64/helm /usr/local/bin/helm</code>)</li>
</ol>
<p>然后就可以执行客户端程序并 <a
href="https://helm.sh/zh/docs/intro/quickstart/#初始化">添加稳定仓库</a>:
<code>helm help</code>.</p>
<p><img data-src="image-20220507135650409.png" /></p>
<h4 id="查看版本号">查看版本号</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm version</span><br></pre></td></tr></table></figure>
<h4 id="安装命令补全">安装命令补全</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;source &lt;(helm completion bash)&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>
<h4 id="修改helm仓库镜像">修改Helm仓库镜像</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm repo add aliyun  https://kubernetes.oss-cn-hangzhou.aliyuncs.com/charts</span><br><span class="line">helm repo update</span><br></pre></td></tr></table></figure>
<p><img data-src="image-20220507135947826.png" /></p>
<p>查看仓库列表</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm repo list</span><br></pre></td></tr></table></figure>
<h3 id="安装harbor">安装Harbor</h3>
<h4 id="添加harbor仓库">添加Harbor仓库</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm repo add harbor https://helm.goharbor.io</span><br><span class="line">helm repo update</span><br></pre></td></tr></table></figure>
<h4 id="搜索harbor">搜索Harbor</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm search repo harbor/harbor</span><br></pre></td></tr></table></figure>
<p><img data-src="image-20220507140154997.png" /></p>
<h4 id="将harbor下载到本地">将Harbor下载到本地</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm fetch harbor/harbor</span><br></pre></td></tr></table></figure>
<h4 id="解压缩">解压缩</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar xvf harbor-1.9.0.tgz</span><br><span class="line"><span class="built_in">cd</span> harbor</span><br></pre></td></tr></table></figure>
<h4 id="修改配置">修改配置</h4>
<p>修改配置文件<code>values.yaml</code>，具体查看<a
href="https://github.com/goharbor/harbor-helm/blob/master/README.md#configuration">GIthub配置列表</a>。</p>
<p>这里修改了以下几个配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">expose:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">nodePort</span></span><br><span class="line">  <span class="attr">tls:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">nodePort:</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="attr">http:</span></span><br><span class="line">        <span class="attr">nodePort:</span> <span class="number">30004</span></span><br><span class="line">      <span class="attr">https:</span></span><br><span class="line">        <span class="attr">nodePort:</span> <span class="number">30005</span></span><br><span class="line">      <span class="attr">notary:</span></span><br><span class="line">        <span class="attr">nodePort:</span> <span class="number">30006</span></span><br><span class="line"><span class="attr">externalURL:</span> <span class="string">http://192.168.232.167:30004</span></span><br><span class="line"><span class="attr">persistence:</span></span><br><span class="line">  <span class="attr">persistentVolumeClaim:</span></span><br><span class="line">    <span class="attr">registry:</span></span><br><span class="line">      <span class="attr">existingClaim:</span> <span class="string">&quot;pvc-harbor&quot;</span></span><br><span class="line">      <span class="attr">storageClass:</span> <span class="string">&quot;-&quot;</span></span><br><span class="line">      <span class="attr">subPath:</span> <span class="string">&quot;registry&quot;</span></span><br><span class="line">    <span class="attr">chartmuseum:</span></span><br><span class="line">      <span class="attr">existingClaim:</span> <span class="string">&quot;pvc-harbor&quot;</span></span><br><span class="line">      <span class="attr">storageClass:</span> <span class="string">&quot;-&quot;</span></span><br><span class="line">      <span class="attr">subPath:</span> <span class="string">&quot;chartmuseum&quot;</span></span><br><span class="line">    <span class="attr">jobservice:</span></span><br><span class="line">      <span class="attr">existingClaim:</span> <span class="string">&quot;pvc-harbor&quot;</span></span><br><span class="line">      <span class="attr">storageClass:</span> <span class="string">&quot;-&quot;</span></span><br><span class="line">      <span class="attr">subPath:</span> <span class="string">&quot;jobservice&quot;</span></span><br><span class="line">    <span class="attr">database:</span></span><br><span class="line">      <span class="attr">existingClaim:</span> <span class="string">&quot;pvc-harbor&quot;</span></span><br><span class="line">      <span class="attr">storageClass:</span> <span class="string">&quot;-&quot;</span></span><br><span class="line">      <span class="attr">subPath:</span> <span class="string">&quot;database&quot;</span></span><br><span class="line">    <span class="attr">redis:</span></span><br><span class="line">      <span class="attr">existingClaim:</span> <span class="string">&quot;pvc-harbor&quot;</span></span><br><span class="line">      <span class="attr">storageClass:</span> <span class="string">&quot;-&quot;</span></span><br><span class="line">      <span class="attr">subPath:</span> <span class="string">&quot;redis&quot;</span></span><br></pre></td></tr></table></figure>
<p>其中 <code>pvc-harbor</code> 是预先创建好的 PVC，创建过程略。</p>
<p>部署 Harbor：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ helm install -g harbor/harbor -f values.yaml .</span><br><span class="line"></span><br><span class="line">NAME: harbor-1589352564</span><br><span class="line">LAST DEPLOYED: Wed May 13 14:49:25 2020</span><br><span class="line">NAMESPACE: default</span><br><span class="line">STATUS: deployed</span><br><span class="line">REVISION: 1</span><br><span class="line">TEST SUITE: None</span><br><span class="line">NOTES:</span><br><span class="line">Please <span class="built_in">wait</span> <span class="keyword">for</span> several minutes <span class="keyword">for</span> Harbor deployment to complete.</span><br><span class="line">Then you should be able to visit the Harbor portal at http://192.168.232.167:30004.</span><br><span class="line">For more details, please visit https://github.com/goharbor/harbor.</span><br></pre></td></tr></table></figure>
<p>部署成功，等待 Harbor
启动完成，然后就可以通过<code>http://192.168.232.167:30004</code>
访问Harbor，默认用户名是admin，密码是Harbor12345。</p>
<p>由于 Docker 自从 1.3.x 之后，docker registry
交互默认使用的是HTTPS，而我们搭建的 Harbor 使用的是HTTP，所以为了避免
pull/push
镜像时得到错误：<code>http: server gave HTTP response to HTTPS client</code>，需要修改
docker 的配置文件
<code>/etc/docker/daemon.json</code>，加入以下配置：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;insecure-registries&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;192.168.232.167:30004&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>保存后重启 docker 服务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>
<h3 id="上传第一个镜像">上传第一个镜像</h3>
<p>下载一个 busybox 镜像：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull busybox:latest</span><br></pre></td></tr></table></figure>
<p>修改 tag：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker tag busybox:latest 192.168.232.167:30004/library/busybox:latest</span><br></pre></td></tr></table></figure>
<p>library 是 Harbor 的默认项目地址，也可以登录 Harbor
自行新建一个项目。</p>
<p>使用 docker login 登录到 Harbor，并输入用户名和密码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker login 192.168.232.167:30004</span><br></pre></td></tr></table></figure>
<p>登录成功后，上传镜像到 Harbor：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker push 192.168.232.167:30004/library/busybox:latest</span><br></pre></td></tr></table></figure>
<h3 id="后记">后记</h3>
<p>上面的软件没有部署完，<strong>例如PVC和helm的架构还不懂，</strong>因此先告一段落。</p>
<p>决定先使用<code>docker-compose</code>先部署<strong>Harbor</strong>
。</p>
<h3 id="参考文档">参考文档</h3>
<p>https://helm.sh/docs/using_helm/#installing-helm</p>
<p>https://github.com/goharbor/harbor-helm</p>
<p>https://www.cnblogs.com/dukuan/p/9963744.html</p>
<p>https://blog.51cto.com/wangpengtai/2418636?source=dra</p>
<p>http://kpali.me/2020/05/13/deploy-harbor-in-kubernetes.html</p>
]]></content>
      <tags>
        <tag>k8s</tag>
        <tag>harbor</tag>
      </tags>
  </entry>
  <entry>
    <title>应用编排与管理：核心原理</title>
    <url>/p/core-concept-about-resource-orchestration-and-management/</url>
    <content><![CDATA[<p>本文是CNCF × Alibaba
云原生技术公开课的<strong>第五章应用编排与管理：核心原理</strong>学习笔记。</p>
<p>关键词：<strong>k8s</strong></p>
<span id="more"></span>
<h3 id="资源元信息">资源元信息</h3>
<p>kubernetes的资源组成主要包括<strong>Spec、Status两部分</strong>。其中Spec部分用来描述期望状态，Status部分用来表述观测状态。</p>
<p>Kubernetes的元数据部分主要包括</p>
<ul>
<li>用来识别资源的<strong>标签：Labels</strong></li>
<li>用来描述资源的<strong>注解：Annotation</strong></li>
<li>用来描述多个资源关系之间相互部分的<strong>OwnerReference</strong></li>
</ul>
<h4 id="labels">Labels</h4>
<p>资源标签是一<strong>种标识型的Key：Value</strong>元数据。</p>
<p>以下是几个例子</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">enviroment:</span> <span class="string">production</span></span><br><span class="line"><span class="attr">release:</span> <span class="string">stable</span></span><br><span class="line"><span class="attr">app.kubernetes.io/version:</span> <span class="number">5.7</span><span class="number">.21</span></span><br><span class="line"><span class="attr">failure-domain.beta.kubernetes.io/region:</span> <span class="string">cn-hangzhou</span></span><br></pre></td></tr></table></figure>
<p>前三个label都打在了Pod对象上，分别标识了<strong>对应的应用环境</strong>、<strong>发布的成熟度</strong>、<strong>和应用的版本</strong>。</p>
<p>最后一个标签打在Node对象上，并在域名前面加了版本的标识和beta字符串。</p>
<p>标签主要用来筛选资源和组合资源，可以使用<strong>类似SQL查询Select，来根据Label查询和相关的资源</strong>。</p>
<p><img data-src="image-20220507170230377.png" /></p>
<h4 id="selector">Selector</h4>
<p>Selector可以用来匹配Labels的资源。</p>
<p>假设系统有以下Pod：</p>
<h5 id="相等型selector">相等型Selector</h5>
<p><img data-src="image-20220507170750082.png" /></p>
<p>通过<code>Tie=front</code>可以匹配左边栏的Pod。</p>
<p>相等型的Selector可以包括<strong>多个相等条件即逻辑与</strong>的关系。</p>
<p>通过<code>Tie=front, Env=dev</code>的Selector，可以筛选出左上角的Pod。</p>
<h5 id="集合型selector">集合型Selector</h5>
<p><img data-src="image-20220507171530472.png" /></p>
<ul>
<li><strong>in操作</strong>
<ul>
<li>通过<code>Env in (test, gray)</code>可以<code>tie</code>
是<code>front</code>或者<code>back</code>的Pod</li>
<li>通过<code>release</code>可以筛选出存在
<code>release</code>标签的Pod</li>
</ul></li>
<li><strong>notin操作</strong>：
<ul>
<li>通过<code>tie notin(front,back)</code>可以筛选出所有<code>tie</code>
不是<code>front</code>且不是<code>back</code>的Pod；</li>
<li>通过<code>!release</code>可以筛选不存在
<code>release</code>标签的Pod</li>
</ul></li>
</ul>
<p>Tips：集合型和相等型的Selector<strong>可以用<code>,</code>来连接，表示逻辑与</strong>的关系</p>
<h4 id="annotations">Annotations</h4>
<p>Annotations（注解）一般是系统或者工具用来存储资源的非标识信息，可以用来拓展资源的<strong>spec/status</strong>的描述。</p>
<p>以下是几个例子</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deployment.kubernetes.io/revision:</span> <span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="attr">kubectl.kubernetes.io/last-applied-configuration:</span> <span class="string">|</span></span><br><span class="line">	&#123;<span class="string">&quot;apiVersion&quot;</span><span class="string">:&quot;apps/v1&quot;</span>,<span class="string">&quot;kind&quot;</span><span class="string">:&quot;Deployment&quot;</span>,<span class="string">&quot;metadata&quot;</span><span class="string">:</span>&#123;<span class="string">&quot;annotations&quot;</span><span class="string">:</span>&#123;&#125;,<span class="string">&quot;name&quot;</span><span class="string">:&quot;busybox-deployment&quot;</span>,<span class="string">&quot;namespace&quot;</span><span class="string">:&quot;default&quot;</span>&#125;,<span class="string">&quot;spec&quot;</span><span class="string">:</span>&#123;<span class="string">&quot;replicas&quot;</span><span class="string">:2</span>,<span class="string">&quot;selector&quot;</span><span class="string">:</span>&#123;<span class="string">&quot;matchLabels&quot;</span><span class="string">:</span>&#123;<span class="string">&quot;app&quot;</span><span class="string">:&quot;busybox&quot;</span>&#125;&#125;,<span class="string">&quot;template&quot;</span><span class="string">:</span>&#123;<span class="string">&quot;metadata&quot;</span><span class="string">:</span>&#123;<span class="string">&quot;labels&quot;</span><span class="string">:</span>&#123;<span class="string">&quot;app&quot;</span><span class="string">:&quot;busybox&quot;</span>&#125;&#125;,<span class="string">&quot;spec&quot;</span><span class="string">:</span>&#123;<span class="string">&quot;containers&quot;</span><span class="string">:</span>[&#123;<span class="string">&quot;args&quot;</span><span class="string">:</span>[<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;while true ; do continue ; done&quot;</span>],<span class="string">&quot;command&quot;</span><span class="string">:</span>[<span class="string">&quot;sh&quot;</span>],<span class="string">&quot;image&quot;</span><span class="string">:&quot;busybox&quot;</span>,<span class="string">&quot;name&quot;</span><span class="string">:&quot;busybox&quot;</span>,<span class="string">&quot;ports&quot;</span><span class="string">:</span>[&#123;<span class="string">&quot;containerPort&quot;</span><span class="string">:80</span>&#125;]&#125;]&#125;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="image-20220507173513904.png" /></p>
<h4 id="ownereference">Ownereference</h4>
<p>Ownereference（所有者）一般是指集合类的资源，比如说Pod集合，比如<strong>replicaset、statefulset</strong>等。</p>
<p>集合类资源的控制器会创建对应的归属资源。</p>
<p>比如：<strong>replicaset</strong>控制器在操作中会创建Pod，则被创建Pod的Ownerefence就指向了创建了Pod的replicaset。</p>
<p>Ownereference可以使得用户可以<strong>方便的查找一个创建资源的对象</strong>，还可以<strong>实现级联删除</strong>的效果。</p>
<p><img data-src="image-20220507174246402.png" /></p>
<h3 id="操作演示">操作演示</h3>
<h4 id="查看pod">查看Pod</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get pods</span><br></pre></td></tr></table></figure>
<h4 id="创建pod">创建Pod</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f pod1.yaml</span><br></pre></td></tr></table></figure>
<h4 id="查看标签">查看标签</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get pods --show-labels</span><br></pre></td></tr></table></figure>
<h4 id="查看具体的资源信息">查看具体的资源信息</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get pods nginx1 -o yaml | less</span><br></pre></td></tr></table></figure>
<h4 id="修改已有的资源标签">修改已有的资源标签</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl label pods nginx1 <span class="built_in">env</span>=<span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<p>如果想覆盖已有的标签信息需要加上<code>--overwide</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl label pods nginx1 <span class="built_in">env</span>=<span class="built_in">test</span> --overwide</span><br></pre></td></tr></table></figure>
<h4 id="去掉已有的标签">去掉已有的标签</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl label pods nginx tie-</span><br></pre></td></tr></table></figure>
<h4 id="使用selector对pod进行筛选">使用Selector对Pod进行筛选</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get pods --show-labels -l <span class="built_in">env</span>=<span class="built_in">test</span></span><br><span class="line">kubectl get pods --show-labels -l <span class="built_in">env</span>=test1,<span class="built_in">env</span>=test2 <span class="comment"># 一个也筛选不出来</span></span><br><span class="line">kubectl get pods --show-labels -l <span class="built_in">env</span>=dev,tie=front</span><br><span class="line">kubectl get pods --show-labels -l <span class="string">&#x27;env in (dev,test)&#x27;</span></span><br></pre></td></tr></table></figure>
<h4 id="增加注解">增加注解</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl annotate pods nginx1 my-annotate=<span class="string">&#x27;my annotate,ok&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="控制器模式">控制器模式</h3>
<h4 id="控制循环">控制循环</h4>
<p>控制型模式最核心的就是控制循环的概念。在控制循环中包括了控制器，被控制的系统，以及能够观测系统的传感器，三个逻辑组件。</p>
<p>这些<strong>组件都是逻辑</strong>的，外界通过修改资源 spec
来控制资源，控制器比较资源 spec 和 status，从而计算一个 diff，diff
最后会用来决定执行对系统进行什么样的控制操作，控制操作会使得系统产生新的输出，并被传感器以资源
status 形式上报，控制器的各个组件将都会是独立自主地运行，不断使系统向
spec 表示终态趋近。</p>
<p><img data-src="image-20220508160446196.png" /></p>
<h4 id="传感器">传感器</h4>
<p>控制循环中逻辑的传感器主要由 Reflector、Informer、Indexer
三个组件构成。</p>
<ul>
<li>Reflector 通过 List 和 Watch K8s server 来获取资源的数据；
<ul>
<li>List 用来在 Controller 重启以及 Watch
中断的情况下，进行系统资源的全量更新；</li>
<li>Watch 则在多次 List 之间进行增量的资源更新；</li>
</ul></li>
<li>Reflector 在获取新的资源数据后，会在 Delta
队列中塞入一个包括资源对象信息本身以及资源对象事件类型的 Delta
记录；</li>
<li>Delta 队列中可以保证同一个对象在队列中仅有一条记录，从而避免
Reflector 重新 List 和 Watch 的时候产生重复的记录。</li>
<li>Informer 组件不断地从 Delta 队列中弹出 delta
记录，然后把资源对象交给 indexer，让 indexer
把资源记录在一个缓存中，缓存在默认设置下是用资源的命名空间来做索引的，并且可以被
Controller Manager 或多个 Controller
所共享。之后，再把这个事件交给事件的回调函数</li>
</ul>
<p><img data-src="image-20220508161637650.png" /></p>
<p>控制循环中的控制器组件主要由事件处理函数以及 worker
组成，事件处理函数之间会相互关注资源的新增、更新、删除的事件，并根据控制器的逻辑去决定是否需要处理。对需要处理的事件，会把事件关联资源的命名空间以及名字塞入一个工作队列中，并且由后续的
worker 池中的一个 Worker
来处理，工作队列会对存储的对象进行去重，从而避免多个 Woker
处理同一个资源的情况。</p>
<p>Worker
在处理资源对象时，一般需要用资源的名字来重新获得最新的资源数据，用来创建或者更新资源对象，或者调用其他的外部服务，Worker
如果处理失败的时候，一般情况下会把资源的名字重新加入到工作队列中，从而方便之后进行重试。</p>
<p><img data-src="image-20220508161830611.png" /></p>
<h3 id="控制器模式总结">控制器模式总结</h3>
<h4 id="两种api设计方法">两种API设计方法</h4>
<p>Kubernetes 控制器模式<strong>依赖声明式的
API</strong>。另外一种常见的 API 类型是命令式 API。</p>
<p><img data-src="image-20220508161904833.png" /></p>
<p><img data-src="image-20220508161848698.png" /></p>
]]></content>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes集群实践（二）如何编写k8s资源清单yaml文件</title>
    <url>/p/how-to-write-k8s-resource-manifest-yaml/</url>
    <content><![CDATA[<p>本文主要介绍如何编写k8s资源清单yaml文件。</p>
<p>在K8s集群上进行资源配置通常都是通过yaml文件进行的，因此如何快速编写yaml文件就变得十分重要。</p>
<p>关键词：<strong>k8s</strong></p>
<span id="more"></span>
<h3 id="yaml文件格式">yaml文件格式</h3>
<p>这个可以参考我的上一篇文章。</p>
<h3 id="yaml资源清单基本格式">yaml资源清单基本格式</h3>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span> <span class="comment"># API版本</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span>    <span class="comment"># 资源类型</span></span><br><span class="line"><span class="attr">metadata:</span>           <span class="comment"># 资源元数据</span></span><br><span class="line"> <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line"> <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span>               <span class="comment"># 资源的期望值</span></span><br><span class="line"> <span class="attr">replicas:</span> <span class="number">3</span>        <span class="comment"># 副本实例数目</span></span><br><span class="line"> <span class="attr">selector:</span>          <span class="comment"># 资源选择器，与下面的metadata.labels保持一致</span></span><br><span class="line">  <span class="attr">matchLabels:</span></span><br><span class="line">   <span class="attr">app:</span> <span class="string">web</span></span><br><span class="line"> <span class="attr">template:</span>          <span class="comment"># Pod模板</span></span><br><span class="line">  <span class="attr">metadata:</span>         <span class="comment"># Pod元数据</span></span><br><span class="line">  	<span class="attr">labels:</span>         </span><br><span class="line">  	 <span class="attr">app:</span> <span class="string">web</span></span><br><span class="line">  <span class="attr">spec:</span>             <span class="comment"># Pod资源的期望值</span></span><br><span class="line">   <span class="attr">containers:</span>      <span class="comment"># 容器配置</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">busybox</span> </span><br></pre></td></tr></table></figure>
<h3 id="kubernetes-的-api"><strong>Kubernetes</strong> 的
<strong>API</strong></h3>
<p><img data-src="image-20220506105442472.png" /></p>
<p>当我们去提交一个Pod，或者get一个Pod的时候，它的content内容都是用JSON或者是YAML表达的。上图中有个yaml的例子，在这个yamlfile中，对Pod资源的描述也分为几个部分。</p>
<p>第一个部分，一般来讲会是API的<strong>version</strong>。比如在这个例子中是V1，它也会描述我在操作哪个资源；比如说我的<strong>kind</strong>如果是pod，在Metadata中，就写上这个Pod的名字；比如说nginx，我们也会给它打一些<strong>label</strong>，我们等下会讲到label的概念。在Metadata中，有时候也会去写<strong>annotation</strong>，也就是对资源的额外的一些用户层次的描述。比较重要的一个部分叫做<strong>Spec</strong>，<strong>Spec也就是我们希望Pod达到的一个预期的状态</strong>。比如说它内部需要有哪些container被运行；比如说这里面有一个nginx的container，它的image是什么？它暴露的port是什么？当我们从KubernetesAPI中去获取这个资源的时候，一般来讲在Spec下面会有一个项目叫<strong>status</strong>，它表达了这个资源当前的状态；比如说一个Pod的状态可能是正在被调度、或者是已经running、或者是已经被terminates，就是被执行完毕了。刚刚在API之中，我们讲了一个比较有意思的metadata叫做“<strong>label</strong>”，这个label可以是一组<strong>键值对</strong>。比如下图的第一个pod中，label就可能是一个color等于red，即它的颜色是红颜色。当然你也可以加其他label，比如说size:big就是大小，定义为大的，它可以是一组label。这些label是可以被selector，也就是选择器所查询的。这个能力实际上跟我们的sql类型的select语句是非常相似的，比如下图中的三个Pod资源中，我们就可以进行select。namecolor等于red，就是它的颜色是红色的，我们也可以看到，只有两个被选中了，因为只有他们的label是红色的，另外一个label中写的color等于yellow，也就是它的颜色是黄色，是不会被选中的。</p>
<p><img data-src="image-20220506110134831.png" /></p>
<p>通过label，kubernetes的API层就可以对这些资源进行一个筛选，那这些筛选也是kubernetes对资源的集合所表达默认的一种方式。</p>
<h3
id="使用yaml创建资源对象deployment">使用yaml创建资源对象Deployment</h3>
<p>资源清单可以通过以下命令导出，会有很多冗余信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get 资源类型 -n 命名空间 -o yaml</span><br></pre></td></tr></table></figure>
<p>省略<code>-n</code>参数将<strong>导出默认命名空间<code>default</code></strong>的资源信息</p>
<blockquote>
<p>以上名字在查看<strong>配置文件其他字段含义</strong>时十分有用！</p>
</blockquote>
<p>使用以下命令可查看所有pod的命名空间</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get pods -o wide --all-namespaces</span><br></pre></td></tr></table></figure>
<p>apiVersion字段可以通过以下命令查询</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl api-resources |grep 资源类型</span><br></pre></td></tr></table></figure>
<h4 id="资源对象文件">资源对象文件</h4>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span>		<span class="comment"># API版本【必需字段】</span></span><br><span class="line"><span class="attr">Kind:</span> <span class="string">Deployment</span>        <span class="comment"># 资源对象【必需字段】</span></span><br><span class="line"><span class="attr">metedata:</span>               <span class="comment"># 资源元数据【必须字段】</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">web</span>             <span class="comment"># 资源名称</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span>    <span class="comment"># 资源所在的命名空间</span></span><br><span class="line"><span class="attr">spec:</span>                   <span class="comment"># deployment的期望状态</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span>           <span class="comment"># 副本实例数量</span></span><br><span class="line">  <span class="attr">selector:</span>  		    <span class="comment"># 标签选择器，与下文中的metadata.labels保持一致</span></span><br><span class="line">    <span class="attr">matchLabels:</span>                </span><br><span class="line">      <span class="attr">app:</span> <span class="string">web</span></span><br><span class="line">  <span class="attr">template:</span>   			<span class="comment"># Pod模板</span></span><br><span class="line">    <span class="attr">metedata:</span> 			<span class="comment"># Pod元数据</span></span><br><span class="line">      <span class="attr">labels:</span> 			<span class="comment"># 定义标签</span></span><br><span class="line">      <span class="comment"># 标签一般根据项目属性去写</span></span><br><span class="line">      <span class="comment"># 例如 project: ms</span></span><br><span class="line">      	<span class="attr">app:</span> <span class="string">web</span> <span class="comment"># 标签</span></span><br><span class="line">    <span class="attr">spec:</span>    <span class="comment"># Pod规格</span></span><br><span class="line">      <span class="attr">containers:</span>  		<span class="comment"># 容器配置</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">web</span>  		<span class="comment"># 容器名</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">busybox</span>  <span class="comment"># 镜像名</span></span><br><span class="line">        <span class="comment">#command: [&quot;sh&quot;]     # 容器执行命令</span></span><br><span class="line">        <span class="comment">#args: [&quot;-c&quot;, &quot;while true ; do continue ; done&quot;] # 命令执行的参数</span></span><br></pre></td></tr></table></figure>
<p>以上资源清单等同于</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create deployment web --image=busybox --replicas=3 -n default</span><br></pre></td></tr></table></figure>
<h3 id="使用yaml创建资源对象service">使用yaml创建资源对象Service</h3>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>              <span class="comment"># api版本【必需字段】</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span>               <span class="comment"># 资源类型【必需字段】</span></span><br><span class="line"><span class="attr">metedata:</span>                   <span class="comment"># 资源元数据【必需字段】</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span>        <span class="comment"># 资源所在namespace</span></span><br><span class="line"><span class="attr">spec:</span>                       <span class="comment"># 期望的资源配置</span></span><br><span class="line">  <span class="attr">ports:</span> <span class="number">80</span>                 <span class="comment"># Service端口，通过Cluster IP访问时使用的端口</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span>             <span class="comment"># 通信协议</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">8080</span>          <span class="comment"># 容器内部的通信端口</span></span><br><span class="line">  <span class="attr">selector:</span> </span><br><span class="line">    <span class="attr">app:</span> <span class="string">web</span>                  <span class="comment"># 标签</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span>            <span class="comment"># Service暴露类型，NodePort允许集群外部访问</span></span><br></pre></td></tr></table></figure>
<p>以上资源清单等同于：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl expose sevice web --port=80 --target-port=8080 --<span class="built_in">type</span>=NodePort -n default</span><br></pre></td></tr></table></figure>
<p>可以将以上两个资源清单合并成一个yaml文件，两个文件中间需要有<code>---</code>分割线，否则<strong>kubectl只识别最后一个yaml的内容</strong>。</p>
<h3 id="快速编写k8s资源清单">快速编写K8s资源清单</h3>
<h4
id="用create命令生成deployment的yaml">用create命令生成deployment的yaml</h4>
<blockquote>
<p>导出的yaml文件有很多冗余字段，不需要可以删除</p>
<p>如：creationTimestamp和status可以删除</p>
</blockquote>
<p>使用<code>--dry-run</code>可以检查是否有错误</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create deployment nginx --image=nginx -o yaml --dry-run=client &gt; deployment.yaml</span><br></pre></td></tr></table></figure>
<h4
id="用expose命令生成service的yaml">用expose命令生成service的yaml</h4>
<blockquote>
<p>导出的yaml文件有很多冗余字段，不需要可以删除</p>
<p>如：creationTimestamp和status可以删除</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl expose servcie nginx --port=80 --target-port=8080 --<span class="built_in">type</span>=NodePort -o yaml --dry-run=client &gt; service.yaml</span><br></pre></td></tr></table></figure>
<h4 id="用get命令导出yaml">用get命令导出yaml</h4>
<blockquote>
<p>这种方式导出的yaml存在很多冗余</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get deployment nginx -o yaml &gt; deployment.yml</span><br></pre></td></tr></table></figure>
<h3
id="怎么查询资源清单文件的指定字段">怎么查询资源清单文件的指定字段</h3>
<p>以下命令能查到pod.spec.containers下的所有字段</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl explain pods.spec.containers</span><br></pre></td></tr></table></figure>
<h3 id="如何查询资源所有字段">如何查询资源所有字段</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl explain deployment</span><br></pre></td></tr></table></figure>
<h3 id="模糊查询资源类型">模糊查询资源类型</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl api-resources | grep 资源类型的模糊字母</span><br></pre></td></tr></table></figure>
<h3 id="检查yaml语法是否有误">检查yaml语法是否有误</h3>
<p>可以使用<strong>kube-linter</strong>来检查yaml语法是否有误</p>
<blockquote>
<p>https://github.com/stackrox/kube-linter</p>
</blockquote>
<h4 id="执行检测">执行检测</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kube-linter lint pod.yaml</span><br></pre></td></tr></table></figure>
<h3 id="参考">参考</h3>
<ul>
<li>https://blog.csdn.net/omaidb/article/details/121855353</li>
</ul>
]]></content>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>YAML简明教程</title>
    <url>/p/yaml-concise-tutorial/</url>
    <content><![CDATA[<p>本文主要介绍YAML 。</p>
<p>YAML 是 "YAML Ain't a Markup Language"（YAML
不是一种标记语言）的递归缩写。在开发的这种语言时，YAML
的意思其实是："Yet Another Markup Language"（仍是一种标记语言）。</p>
<p>YAML
的语法和其他高级语言类似，并且可以简单表达清单、散列表，标量等数据形态。它使用空白符号缩进和大量依赖外观的特色，特别适合用来表达或编辑数据结构、各种配置文件、倾印调试内容、文件大纲（例如：许多电子邮件标题格式和YAML非常接近）。</p>
<p>YAML 的配置文件后缀为
<strong>yml</strong>或<strong>yaml</strong>。</p>
<p>关键词：<strong>YAML</strong></p>
<span id="more"></span>
<h3 id="yaml文件格式">yaml文件格式</h3>
<h4 id="基本语法">基本语法</h4>
<ul>
<li>大小写敏感</li>
<li>使用缩进表示层级关系</li>
<li>缩进<strong>不允许使用Tab，只允许空格</strong></li>
<li>缩进的空格数不重要，只要相同层级的元素左对齐即可</li>
<li><code>#</code>表示注释</li>
<li><code>---</code>表示yaml格式文件的开始</li>
</ul>
<h4 id="数据类型">数据类型</h4>
<p>YAML支持以下数据类型</p>
<ul>
<li>对象：键值对的几个，又称为映射（mapping）/ 哈希（hashes）/
字典（dictionary）</li>
<li>数组：一组按次序排列的值，又称为序列（sequence）/ 列表（list）</li>
<li>标量（scalars）：单个的、不可再分的值</li>
</ul>
<h4 id="yaml对象">YAML对象</h4>
<p>对象键值对使用冒号结构表示key-value，<strong>冒号后面要加一个空格。</strong></p>
<p>也可以使用<code>key:&#123;key1: value, key2: value, ...&#125;</code></p>
<p>也可以使用缩进表示层级关系：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">key:</span></span><br><span class="line">    <span class="attr">key1:</span> <span class="string">value</span></span><br><span class="line">    <span class="attr">key2:</span> <span class="string">value</span></span><br></pre></td></tr></table></figure>
<p>对于较为复杂的对象格式，可以使用<strong>问号加一个空格表示一个复杂的key</strong>，配合<strong>一个冒号加一个空格表示一个value</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">?</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">complexkey1</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">complexkey2</span></span><br><span class="line"><span class="string">:</span></span><br><span class="line">	<span class="bullet">-</span> <span class="string">complexvalue1</span></span><br><span class="line">	<span class="bullet">-</span> <span class="string">complexvalue2</span></span><br></pre></td></tr></table></figure>
<p>即对象的属性是一个数组<code>[complexkey1,complexkey2]</code>，对应的值也是一个数组<code>[complexvalue1, complexvalue2]</code></p>
<h4 id="yaml数组">YAML数组</h4>
<p>以<code>-</code>开头的行表示构成一个数组</p>
<p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">A</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">B</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">C</span></span><br></pre></td></tr></table></figure></p>
<p>支持多维数组，可以使用<strong>行内表示</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">key:</span> [<span class="string">value1</span>, <span class="string">value2</span>, <span class="string">...</span>]</span><br></pre></td></tr></table></figure>
<p>如果子成员是一个数组，则可以在下面缩进一个空格</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> </span><br><span class="line"> <span class="bullet">-</span> <span class="string">A</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">B</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">C</span></span><br></pre></td></tr></table></figure>
<p>一个复杂的例子：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">companies:</span></span><br><span class="line">    <span class="bullet">-</span></span><br><span class="line">        <span class="attr">id:</span> <span class="number">1</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">company1</span></span><br><span class="line">        <span class="attr">price:</span> <span class="string">200W</span></span><br><span class="line">    <span class="bullet">-</span></span><br><span class="line">        <span class="attr">id:</span> <span class="number">2</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">company2</span></span><br><span class="line">        <span class="attr">price:</span> <span class="string">500W</span></span><br></pre></td></tr></table></figure>
<p>即<code>companies</code>属性是一个数组，每一个数组元素又是由<code>id/name/price</code>三个属性组成。</p>
<p>数组也可以使用<strong>行内表示</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">companies:</span> [&#123;<span class="attr">id:</span> <span class="number">1</span>,<span class="attr">name:</span> <span class="string">company1</span>,<span class="attr">price:</span> <span class="string">200W</span>&#125;,&#123;<span class="attr">id:</span> <span class="number">2</span>,<span class="attr">name:</span> <span class="string">company2</span>,<span class="attr">price:</span> <span class="string">500W</span>&#125;]</span><br></pre></td></tr></table></figure>
<h4 id="复合结构">复合结构</h4>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">languages:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Ruby</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Perl</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Python</span> </span><br><span class="line"><span class="attr">websites:</span></span><br><span class="line">  <span class="attr">YAML:</span> <span class="string">yaml.org</span> </span><br><span class="line">  <span class="attr">Ruby:</span> <span class="string">ruby-lang.org</span> </span><br><span class="line">  <span class="attr">Python:</span> <span class="string">python.org</span> </span><br><span class="line">  <span class="attr">Perl:</span> <span class="string">use.perl.org</span></span><br></pre></td></tr></table></figure>
<p>转换为json</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> </span><br><span class="line">  languages<span class="punctuation">:</span> <span class="punctuation">[</span> &#x27;Ruby&#x27;<span class="punctuation">,</span> &#x27;Perl&#x27;<span class="punctuation">,</span> &#x27;Python&#x27;<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  websites<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    YAML<span class="punctuation">:</span> &#x27;yaml.org&#x27;<span class="punctuation">,</span></span><br><span class="line">    Ruby<span class="punctuation">:</span> &#x27;ruby-lang.org&#x27;<span class="punctuation">,</span></span><br><span class="line">    Python<span class="punctuation">:</span> &#x27;python.org&#x27;<span class="punctuation">,</span></span><br><span class="line">    Perl<span class="punctuation">:</span> &#x27;use.perl.org&#x27; </span><br><span class="line">  <span class="punctuation">&#125;</span> </span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="标量">标量</h4>
<p>标量是不可再分的值，包括</p>
<ul>
<li>字符串</li>
<li>布尔值</li>
<li>整数</li>
<li>浮点数</li>
<li>NULL</li>
<li>时间</li>
<li>日期</li>
</ul>
<p>通过一个例子来了解纯量的基本使用</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">boolean:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="literal">TRUE</span>  <span class="comment">#true,True都可以</span></span><br><span class="line">    <span class="bullet">-</span> <span class="literal">FALSE</span>  <span class="comment">#false，False都可以</span></span><br><span class="line"><span class="attr">float:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">3.14</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">6.8523015e+5</span>  <span class="comment">#可以使用科学计数法</span></span><br><span class="line"><span class="attr">int:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">123</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">0b1010_0111_0100_1010_1110</span>    <span class="comment">#二进制表示</span></span><br><span class="line"><span class="attr">null:</span></span><br><span class="line">    <span class="attr">nodeName:</span> <span class="string">&#x27;node&#x27;</span></span><br><span class="line">    <span class="attr">parent:</span> <span class="string">~</span>  <span class="comment">#使用~表示null</span></span><br><span class="line"><span class="attr">string:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">哈哈</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;Hello world&#x27;</span>  <span class="comment">#可以使用双引号或者单引号包裹特殊字符</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">newline</span></span><br><span class="line">      <span class="string">newline2</span>    <span class="comment">#字符串可以拆成多行，每一行会被转化成一个空格</span></span><br><span class="line"><span class="attr">date:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">2018-02-17</span>    <span class="comment">#日期必须使用ISO 8601格式，即yyyy-MM-dd</span></span><br><span class="line"><span class="attr">datetime:</span> </span><br><span class="line">    <span class="bullet">-</span>  <span class="number">2018-02-17T15:02:31+08:00</span>    <span class="comment">#时间使用ISO 8601格式，时间和日期之间使用T连接，最后使用+代表时区</span></span><br></pre></td></tr></table></figure>
<h4 id="引用">引用</h4>
<p><code>&amp;</code>锚点和<code>*</code>别名，可以用来引用</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">defaults:</span> <span class="meta">&amp;defaults</span></span><br><span class="line">  <span class="attr">adapter:</span>  <span class="string">postgres</span></span><br><span class="line">  <span class="attr">host:</span>     <span class="string">localhost</span></span><br><span class="line"></span><br><span class="line"><span class="attr">development:</span></span><br><span class="line">  <span class="attr">database:</span> <span class="string">myapp_development</span></span><br><span class="line">  <span class="string">&lt;&lt;:</span> <span class="meta">*defaults</span></span><br><span class="line"></span><br><span class="line"><span class="attr">test:</span></span><br><span class="line">  <span class="attr">database:</span> <span class="string">myapp_test</span></span><br><span class="line">  <span class="string">&lt;&lt;:</span> <span class="meta">*defaults</span></span><br></pre></td></tr></table></figure>
<p>相当于</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">defaults:</span></span><br><span class="line">  <span class="attr">adapter:</span>  <span class="string">postgres</span></span><br><span class="line">  <span class="attr">host:</span>     <span class="string">localhost</span></span><br><span class="line"></span><br><span class="line"><span class="attr">development:</span></span><br><span class="line">  <span class="attr">database:</span> <span class="string">myapp_development</span></span><br><span class="line">  <span class="attr">adapter:</span>  <span class="string">postgres</span></span><br><span class="line">  <span class="attr">host:</span>     <span class="string">localhost</span></span><br><span class="line"></span><br><span class="line"><span class="attr">test:</span></span><br><span class="line">  <span class="attr">database:</span> <span class="string">myapp_test</span></span><br><span class="line">  <span class="attr">adapter:</span>  <span class="string">postgres</span></span><br><span class="line">  <span class="attr">host:</span>     <span class="string">localhost</span></span><br></pre></td></tr></table></figure>
<p><code>&amp;</code>用来建立锚点，<code>&lt;&lt;</code>表示合并到当前数据，<code>*</code>用来引用锚点。</p>
<blockquote>
<p>此处的锚点有点类似于编程语言【指针】的含义。</p>
</blockquote>
<p>下面是另一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- &amp;showell Steve </span><br><span class="line">- Clark </span><br><span class="line">- Brian </span><br><span class="line">- Oren </span><br><span class="line">- *showell </span><br></pre></td></tr></table></figure>
<p>转换为JavaScript代码如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[ <span class="string">&#x27;Steve&#x27;</span>, <span class="string">&#x27;Clark&#x27;</span>, <span class="string">&#x27;Brian&#x27;</span>, <span class="string">&#x27;Oren&#x27;</span>, <span class="string">&#x27;Steve&#x27;</span> ]</span><br></pre></td></tr></table></figure>
<h3 id="参考地址">参考地址</h3>
<ul>
<li>https://www.runoob.com/w3cnote/yaml-intro.html</li>
<li>https://www.ruanyifeng.com/blog/2016/07/yaml.html</li>
<li>https://www.jianshu.com/p/97222440cd08</li>
<li>https://daihainidewo.github.io/blog/yaml%E6%95%99%E7%A8%8B/</li>
</ul>
]]></content>
      <tags>
        <tag>yaml</tag>
      </tags>
  </entry>
  <entry>
    <title>应用编排与管理：Deployment</title>
    <url>/p/core-concept-about-resource-orchestration-and-management/</url>
    <content><![CDATA[<p>本文是CNCF × Alibaba
云原生技术公开课的<strong>第七章应用编排与管理：Deployment</strong>学习笔记。</p>
<p>关键词：<strong>k8s</strong></p>
<span id="more"></span>
<h3 id="需求来源">需求来源</h3>
<p>假如我们直接管理集群中所有的Pod，应用A、B、C的Pod，其实是散乱的分布在集群中。</p>
<p><img data-src="image-20220513133334099.png" /></p>
<p>而且在使用过程中存在以上问题。然后就引入了今天课程的主题。</p>
<h4
id="deployment管理部署发布的控制器">Deployment：管理部署发布的控制器</h4>
<p>首先明确<strong>Doployment是管理部署发布的控制器</strong></p>
<p>Doployment将应用A、B、C分别规划到不同的Deployment中，<strong>每个Deployment是管理一组相同的应用Pod，这组Pod是相同的副本</strong>。</p>
<ol type="1">
<li>Deployment定义了一种Pod期望数量。例如对于应用A，我们期望Pod的数量是四个，<code>controller</code>会持续<strong>维持Pod数量为期望的数量</strong>。当Pod出现了网络问题或者宿主机出现了问题时，<code>controller</code>可以帮我们恢复也就是新起来对应的Pod，来；</li>
<li>配置Pod发布方式。<code>controller</code>会<strong>按照用户给定的策略来更新Pod</strong>，<strong>更新过程中可以设定不可用Pod的数量在多少范围</strong>内。</li>
<li>如果更新过程中发生问题，支持一键回滚。<strong>Deployment在更新应用时不是一次性更新全部Pod，而是一个Pod一个Pod的进行更新</strong>。如果新的Pod无法起来，这样也不影响旧版本的Pod正常运行。</li>
</ol>
<p><img data-src="image-20220513134455213.png" /></p>
<h3 id="用法用例">用法用例</h3>
<h4 id="deployment语法">Deployment语法</h4>
<p><img data-src="image-20220513134618739.png" /></p>
<ul>
<li>apiVersion：当前Deployment所属的组是apps，版本是v1</li>
<li>metadata：当前Deployment的元信息。<code>.metedata.name</code>是nginx-deployment，<code>.metadata.labels</code>是app=nginx</li>
<li>spec：期望状态。核心字段是<code>replicas</code>，即<strong>期望的Pod数量，<code>controller</code>会一直控制Pod在这个数量</strong>；selector是Pod选择器，这里<strong>label的要与下文中Pod模板的label一致</strong>；template是Pod的模板，包含了<strong>Pod的元信息，这里是app=nginx</strong>，还<strong>包含了Pod的期望状态，这里有容器的一些如镜像版本、容器名称、端口映射</strong>等信息。</li>
</ul>
<h4 id="查看deployment状态">查看Deployment状态</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$kubectl</span> get deployment </span><br></pre></td></tr></table></figure>
<p><img data-src="image-20220513135710806.png" /></p>
<ul>
<li>READY：期望的Pod数量/实际Pod的数量</li>
<li>UP-TO-DATE：达到最新期望版本的Pod数量</li>
<li>AVAILABLE：运行过程中的可用Pod数量。这里Pod并不简单是可用的（Ready状态），其实包含了一些<strong>可用超过一定时间长度的Pod</strong></li>
<li>AGE：deployment创建的时长，如上图Deployment就已经创建了80分钟</li>
</ul>
<h4 id="查看pod状态">查看Pod状态</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$kubectl</span> get pods</span><br></pre></td></tr></table></figure>
<p><img data-src="image-20220513140522034.png" /></p>
<ul>
<li>Pod的名字格式是<code>&#123;deployment-name&#125;-&#123;pod模板的hash&#125;-&#123;随机字符串&#125;</code>，Pod的<strong>ownerReferences</strong>即<strong>Pod所属的controller资源不是Deployment而是ReplicaSet</strong>。这个
<ul>
<li>ReplicaSet的name其实是<strong>nginx-deployment加上pod.template-hash</strong></li>
<li>所有的Pod都是ReplicaSet创建出来的，ReplicaSet对应的某个Deployment.template版本</li>
</ul></li>
</ul>
<h4 id="更新镜像">更新镜像</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$kubectl</span> <span class="built_in">set</span> image deployment.v1.apps/nginx-deployment nginx=nginx:1.9.1</span><br></pre></td></tr></table></figure>
<p><img data-src="image-20220513145414786.png" /></p>
<h4 id="快速回滚">快速回滚</h4>
<p>如果在发布过程中遇到了问题，支持快速回滚。</p>
<p>快速回滚到Deployment上一个版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$kubectl</span> rollout undo deployment/nginx-deployment</span><br></pre></td></tr></table></figure>
<p>回滚Deployment到上一个版本，需要先查询版本列表</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$kubectl</span> rollout <span class="built_in">history</span> deployment/nginx=deployment</span><br></pre></td></tr></table></figure>
<p><img data-src="image-20220513150000845.png" /></p>
<p>这里的CHANGE-CAUSE列全都是<code>&lt;none&gt;</code>，在应用资源清单时可以<strong>使用如下命令</strong>使得api-server记录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$kubectl</span> apply -f nginx-deployment.yml --record</span><br></pre></td></tr></table></figure>
<h5 id="设置历史版本保留">设置历史版本保留</h5>
<p>通过<code>.spec.revisionHistoryLimit</code>字段可以设置保留历史版本的<code>replicaset</code>的数量，默认值是10</p>
<h3 id="deploymentstatus">DeploymentStatus</h3>
<p>每一个资源都有它的spec.Status，这里deploymentStatus中描述的是它的转换状态：也就是<strong>Processing、Complete、和Failed。</strong></p>
<p><img data-src="image-20220513151104847.png" /></p>
<ul>
<li>以Processing为例：Processing指的是Deployment正在处于<strong>扩容和发布状态</strong>。当Processing状态的deployment所有的ReplicasSet以及Pod副本全部达到最新版本，而且是avilable，这样就会进入Complete状态。而Complete状态如果发生了一些扩缩容的话，也会进入Processing的状态。</li>
<li>如果在处理过程中遇到一些问题：比如说<strong>拉取镜像失败了</strong>，或者<strong>就绪探针检查失败了</strong>，就会进入failed状态；如果在运行过程中即complete状态，中间运行时发生了一些<strong>探针检查失败</strong>，此时deployment也会进入failed状态。进入failed状态后，除非所有副本均变成available，而且是update到最新版本，deployment才会进入Complete状态。</li>
</ul>
<h3 id="架构设计">架构设计</h3>
<h4 id="管理模式">管理模式</h4>
<p><img data-src="image-20220513165107394.png" /></p>
<ul>
<li>Deployment负责管理不同版本的ReplicaSet，由ReplicaSet来管理具体的Pod副本数</li>
<li>每个ReplicaSet对应Deployment
template的一个版本。每修改一次template，都会生成一个新的ReplocaSet，这个ReplicaSet下的Pod其实是相同版本。</li>
</ul>
<h4 id="deployment控制器">Deployment控制器</h4>
<p>控制器实现原理</p>
<p>所有的控制器都是通过Informer中的<strong>一些事件做处理和监听</strong>。Deployment控制器关注Deployment和ReplicaSet的事件，收到事件后加入队列。控制器从队列中取出来后，进行check
paused的处理，paused其实是检查deployment是否需要新的发布，如果paused设置为true，就表示Deployment只会做副本数量上的维持而不是发布。</p>
<p><img data-src="image-20220513165749153.png" /></p>
<ul>
<li>当check
paused为yes，那么控制器只会做<strong>同步副本</strong>，也就是说把副本同步到对应的ReplicaSet中，最后在更新Deployment的状态。</li>
<li>当check
paused为false，那么控制器会跟<strong>更新副本</strong>，也就是通过Create或者Rolling的方式来更新，更新方式也是通过Create/Update/Delete
ReplicaSet来实现的</li>
</ul>
<h4 id="replicaset控制器">ReplicaSet控制器</h4>
<p>当Deployment分配了ReplicaSet之后，ReplicaSet控制器也是通过Informer中监听一些事件，这些事件包含了ReplicaSet和Pod的事件。ReplicaSet控制器管理副本数，使得状态向spec规定的副本数无限靠近。</p>
<p><img data-src="image-20220513171158658.png" /></p>
<p>Deployment控制器做了更复杂的时区，包含了版本管理。Deployment控制器把每一个版本的数量维持工作交给ReplicaSet控制器来做。</p>
<h4 id="扩缩容模拟">扩/缩容模拟</h4>
<p><img data-src="image-20220513171437987.png" /></p>
<h4 id="发布模拟">发布模拟</h4>
<p><img data-src="image-20220513172101061.png" /></p>
<ul>
<li>若修改template中的一个容器的image，Deployment控制器会新建一个对应template2中的ReplicaSet，创建出来之后会<strong>逐渐增加ReplicaSet2
中 Pod 的数量，同时逐渐减少 ReplicaSet1 中的 Pod 数量。</strong></li>
<li>最终新版本的Pod为Pod4、Pod5和Pod6，旧版本的Pod被删除，这里就完成了一次发布。</li>
</ul>
<h4 id="回滚模拟">回滚模拟</h4>
<p><img data-src="image-20220513175011929.png" /></p>
<ul>
<li>如果此时发现当前业务版本使用有问题时，此时需要回滚，不管是通过<code>rollout</code>命令还是通过回滚修改template，都是把当前的templete回滚为旧版本的templete</li>
<li>此时Deployment会修改ReplicationSet1中Pod的期望数量，把期望数量修改为3个，而且会逐渐减少新版本
ReplicaSet2 中的 replica 数量，最终的效果就是把 Pod
从旧版本重新创建出来。<strong>回滚并不是把之前的 Pod
重新找出来，而是说重新创建出符合旧版本 template 的 Pod。</strong></li>
</ul>
<h4 id="spec字段解析">spec字段解析</h4>
<ul>
<li><p>MinReadySeconds：Deployment会根据Pod
ready查看Pod是否可用，默认值是0。如果设置MinReadySeconds=30（秒），Deployment会等到超过30秒以后才认为Pod是avaliable的。Pod
available的前提条件是Pod ready，但ready
的Pod不一定是available的。<strong>一定要超过MinReadySeconds之后才会判断为available</strong>；</p></li>
<li><p>revisionHistoryLimit：保留历史revision，即保留历史ReplicaSet的数量，默认值为10个，这里可以设置为一个或者两个，如果回滚可能性比较大的话可以设置数量超过10；</p></li>
<li><p>progressDeadlineSecond：当Deployment处于扩容或者发布状态时，pod会处于一个processing的状态，可以设置这个状态的超时时间，如果超过了这个超过时间还处于processing，那么可以认为这个Pod进入了failed的状态。</p></li>
</ul>
<h4 id="升级策略字段解析">升级策略字段解析</h4>
<p>可以在<code>.spec.strategy</code>字段下设置升级策略。</p>
<p><img data-src="image-20220513220124878.png" /></p>
<ul>
<li>maxUnavailable：滚动升级过程中最多有多少个Pod不可用；</li>
<li>maxSurge：滚动升级过程中最多存在多少个Pod超过预期replica数量。</li>
</ul>
<p>当<code>.spec.replicas</code>=3的Deployment在发布时可能存在一种情况：新版本的ReplicaSet和旧版本的ReplicaSet加起来是4个，超过了期望数3个。这是因为<strong>默认的Max
Unavailable和MaxSurge都是25%，</strong>默认Deployment在发布过程中，可能有25%的replicas是不可用的，也可能会有25%的replica是可用的，因此最高可以达到125%的replica数量。</p>
<p>这里可以根据用户实际场景来设置：当用户的资源足够时，且更注重发布过程中的可用性，<strong>此时可以设置maxUnavailable较小，maxSurge较大</strong>。但是如果用户的资源比较紧张，此时可以设置MaxSurge较小，甚至设置为0。</p>
<p><strong>maxUnavailable和maxSurge不能同时为0：</strong>当MaxSurge为0时，必须要删除Pod，才能扩容Pod；当maxUnavailable为0时，限制了升级过程中无法删除Pod，因为一旦删除就会有Pod不可用。两者产生了冲突。</p>
<h3 id="小结">小结</h3>
<ul>
<li>Deployment时K8s中一种常见的工作负载，支持部署多版本的Pod</li>
<li>Deployment时管理多版本的方式，是针对每个版本的模版创建一个ReplicaSet，由ReplicaSet维护一盒一定数量的Pod副本，而Deployment只需要关心不同版本的ReplicaSet要制定多少数量的Pod；</li>
<li>因此Deployment发布部署的根本原理，就是Deployment调整不同版本的ReplicaSet的中期望副本数，以此来达到多版本Pod的升级和回滚</li>
</ul>
]]></content>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>理解Pod和容器设计模式</title>
    <url>/p/container-design-patterns/</url>
    <content><![CDATA[<p>本文是CNCF × Alibaba 云原生技术公开课的<strong>第四章理解 Pod
和容器设计模式</strong>学习笔记。</p>
<p>关键词：<strong>k8s</strong></p>
<span id="more"></span>
<h3 id="为什么需要pod">为什么需要Pod</h3>
<h4 id="容器的基本概念">容器的基本概念</h4>
<ul>
<li>容器的本质是一个进程，是一个<strong>视图被隔离，资源受限</strong>的进程。</li>
</ul>
<p>容器里面PID=1的进程就是容器本身，这意味着<strong>管理容器等于直接管理应用本身</strong>。</p>
<p>如果将Kubernetes类比于云时代的操作系统，那么容器的镜像就是这个操作系统的软件安装包。</p>
<p><img data-src="image-20220505153649015.png" /></p>
<h4 id="真实操作系统的例子">真实操作系统的例子</h4>
<p>假如有一个程序叫做helloworld，这个程序是由一组进程组成，这里说的进程等同于Linux线程。</p>
<p>因为Linux线程是轻量级进程，所以如果从Linux中看helloword的pstree，会看到这个helloword程序由四个线程组成。四个线程<strong>相互协作</strong>，共享helloword程序的资源，组成了helloworld程序的<strong>真实工作情况</strong>。</p>
<p>以上实际上是一个<strong>进程组</strong>的概念。</p>
<p><img data-src="image-20220505154210244.png" /></p>
<p>真实的操作系统中，一个程序往往是根据进程组来进行管理的。类比到Kubernetes，由于Pod是Kubernetes进行资源调度的最小单位，那么<strong>Pod就可类比成操作系统的进程组</strong>。</p>
<p><img data-src="image-20220505161515178.png" /></p>
<h4 id="进程组的概念">进程组的概念</h4>
<p>还是原来的例子：hellowolrd程序由四个进程组成，这些进程会共享一些资源和文件。如果现在<strong>把helloworld程序用容器跑起来</strong>，应该怎么做？</p>
<p>一个自然的想法是，启动一个docker容器，里面运行四个进程。</p>
<p>但是容器的设计本身是一种<strong>单进程</strong>的模型。不是说容器内只能起一个进程，由于容器的应用等于进程，所以只能去管理PID=1的这个进程，其他再起来的进程实际上一个<strong>托管状态</strong>，此时的PID=1的进程具有<strong>进程管理</strong>的能力。</p>
<p>因为容器中PID=1的进程需要具有进程管理的能力，因此需要PID=1的进程改为<strong>systemd</strong>，否则这个应用或者容器没有办法去管理多个进程。因为PID=1的进程是应用本身，如果此时该进程被杀死，<strong>那么剩下三个进程的资源就没有人回收了</strong>。</p>
<p>但是如果真的将这个应用本身改为<strong>systemd</strong>，或者直接把容器里PID=1的进程直接修改为<strong>systemd</strong>。这会导致<strong>无法获得这个应用的状态</strong>，因为容器里运行的是<strong>systemd</strong>，而不是<strong>应用本身</strong>。</p>
<p>简单梳理下：</p>
<ul>
<li><p>由于容器实际上是一个单进程模型，所以如果在容器里启动多个进程，只有一个可以作为PID=1的进程。如果这个PID=1的进程挂了，其他的进程会成为<strong>孤儿</strong>，<strong>操作系统无法回收这一部分资源。</strong></p>
<blockquote>
<p>此时的孤儿进程由宿主机的操作系统的systemd或者init进程管理。</p>
</blockquote></li>
<li><p>如果在容器里运行一个systemd管理其他进程，这样会导<strong>致管理容器无法直接管理应用</strong>。应用被systemd接管了，此时<strong>应用状态的生命周期不等于容器的生命周期</strong>。</p></li>
</ul>
<p><img data-src="image-20220505161527738.png" /></p>
<h4 id="pod进程组">Pod=进程组</h4>
<p>Pod是Kubernetes抽象出来的一个可以类比为进程组的概念。</p>
<p>前文提到的这四个进程共同组成的一个应用helloworld，在kubenetes里面实际上会被定义<strong>为拥有四个容器的Pod</strong>。</p>
<p>因为在一个容器里启动多个进程会遇到上面的问题，<strong>所以Kubernetes把四个相互协作的进程用四个独立的容器启动起来，然后定义在一个Pod里。</strong></p>
<p>当Kubernetes把helloword给拉起来的时候，实际上会看到四个容器，他们共享了某些资源，这些<strong>资源都属于Pod</strong>，所以Pod在Kubernetes里只是一个<strong>逻辑单位</strong>。多个容器的组合就叫做Pod。<strong>Pod是Kubernetes资源分配的原子调度单位。</strong></p>
<p><img data-src="image-20220505162400647.png" /></p>
<h4 id="为什么pod必须是原子调度单位">为什么Pod必须是原子调度单位</h4>
<p>为什么要把Pod作为一个概念抽象出来呢？为什么不通过调度等方式把Pod这个抽象的概念去掉？为什么Pod必须是Kubernetes里的原子调度单位？</p>
<p>通过一个例子来解释。</p>
<p>比如现在有两个容器，他们是紧密协作的，所以他们应该被部署在同一个pod里。具体来说，第一个容器是App也就是业务容器，他会<strong>写日志</strong>文件；第二个容器是LogCollector，他会<strong>转发业务容器写的日志文件</strong>到其他组件。</p>
<p>两个容器的资源需求如下：</p>
<ul>
<li>App需要1G内存</li>
<li>LogCollector需要0.5G内存</li>
</ul>
<p>而当前集群环境的可用内存：</p>
<ul>
<li>Node_A可用内存为1.25G</li>
<li>Node_B可用内存为2G</li>
</ul>
<p>比如现在没有Pod的概念，就只有两个容器，需要这两个容器<strong>运行在同一台机器上</strong>。如果调度器先把App调度到了Node_A上面，由于内存不足以再运行LogCollector，<strong>调度失败</strong>，必须重新调度。</p>
<p>以上是一个非常典型的<strong>成组调度失败</strong>的例子，Task
co-scheduling问题不是说不能解，在很多项目里，都有类似的解法。</p>
<ul>
<li><p>比如在Mesos中，他会进行<strong>资源囤积</strong>：即当资源满足了所有约束的任务时，才会开始调度，这是一个<strong>典型的成组调度</strong>的解法。在Mesos中，上文提到的两个"容器"不会立刻调度。<strong>但是这样的话调度效率会损失，因为需要等待；其次会因为互相等待而产生死锁。</strong></p></li>
<li><p>另一种是Google的解法，他在Omega
系统中做了一个非常复杂且非常厉害的解法，被称为<strong>乐观调度</strong>：即不管冲突的异常情况，先调度，同时设置一个回滚机制，如果在调度过程中出现了冲突，即通过回滚来解决问题。这个方式来说更加优雅，也更加高效。<strong>但是实现机制非常复杂</strong>，因为<strong>悲观锁的设置一定要比乐观锁要简单</strong>。</p></li>
</ul>
<p>而像这样一个调度问题，在Kubernetes里，直接通过<strong>Pod</strong>一个概念解决了，因为在Kubernetes里，App容器和LogCollector容器是属于一个Pod的，在调度时必然是以一个Pod为单位进行调度，<strong>因此不存在这个问题</strong>。</p>
<p><img data-src="image-20220505171036279.png" /></p>
<h4 id="再次理解pod">再次理解Pod</h4>
<p>首先Pod里面的容器是<strong>超亲密关系</strong>。和超亲密关系相比，还有一种关系叫<strong>亲密关系</strong>，这个亲密关系一定是可用通过调度来解决的。</p>
<p>比如现在有两个Pod，<strong>需要运行在同一台宿主机上</strong>，那么就属于亲密关系，调度器是可以去做的。</p>
<p>对于超亲密关系来说。必须通过Pod来解决，如果超亲密关系赋予不了，那么<strong>整个Pod或者整个应用</strong>都无法启动。</p>
<p>什么是超亲密关系呢？</p>
<ul>
<li>比如两个进程会<strong>发生文件交换</strong>，例如一个写日志，一个读取日志；</li>
<li>两个进程之间<strong>通过localhost或者本地的socket</strong>去通信；</li>
<li>两个容器或者微服务之间，会发生非常频繁的RPC调用，出于性能的考虑，也应该是超亲密关系；</li>
<li>两个容器或者应用，他们需要<strong>共享某些Linux
NameSpace</strong>。最常见的例子就是一个容器需要加入另外一个容器的Network
Namespace，这样就可以看到另外一个容器的网络设备信息；</li>
</ul>
<p><img data-src="image-20220505193202869.png" /></p>
<p>Pod解决了两个问题</p>
<ol type="1">
<li>怎么去描述<strong>超亲密关系</strong>；</li>
<li>怎么去对<strong>超亲密关系的容器或者说是业务去做统一调度</strong>。</li>
</ol>
<h3 id="pod的实现机制">Pod的实现机制</h3>
<h4 id="pod要解决的问题">Pod要解决的问题</h4>
<p>容器之间原本说被Linux
Namespace和cgroups隔开的，所以现在实际要解决的事怎么打破隔离。</p>
<p>具体解法分两个部分：<strong>网络和存储</strong>。</p>
<h5 id="共享网络">共享网络</h5>
<p>现在有一个Pod，其中包含了容器A和容器B，他们两个需要共享Network
Namespace。</p>
<p>Kuberetes会在某个Pod里，额外起一个<strong>Infra
Container容器</strong>来共享整个Pod的Network Namespace。</p>
<p>Infra
Container是一个非常小的镜像，是一个汇编语言写的、永远处于暂停状态的容器。由于有了这样一个Infra
Container之后，<strong>其他所有容器都会通过加入Namespace的方式加入到Infra
Container中的Network Namespace中。</strong></p>
<p>因此一个Pod里面的所有容器网络视图是完全一样的，<strong>即他们看到的网络设备、IP地址、MAC地址等其他网络信息其实完全是一样的</strong>，这些都来自于Pod第一次创建这个Infra
Container。</p>
<p>在Pod里面一定有一个IP地址，是这个Pod的Network Namespace
对应的地址，也是Infra
Container的IP地址。这个IP地址被Pod中的容器共享。这就是Pod的网络实现方式。</p>
<p>在整个Pod里，必然是Infra
Container第一个启动，而且整个Pod的生命周期等同于Infra
Container的生命周期，与容器A和容器B是无关的。<strong>因此Kubernetes允许单独更新Pod里的某一个镜像，且更新时整个Pod也不会重建，也不会重启。</strong></p>
<p><img data-src="image-20220505193219913.png" /></p>
<h5 id="共享存储">共享存储</h5>
<p>现在有两个容器，一个是容器A，另一个是容器B。两个容器需要进行文件共享。</p>
<p><strong>在一个Pod里，声明一个Volume，它是属于Pod的，同一个Pod访问的Volume是同一份Volume。</strong></p>
<p>之前的例子，应用容器App写了日志，只要这个日志是在一个Volume中，只要声明挂载了同一个Volume，这个Volume就可以被另外一个LogCollector容器看到。</p>
<p><img data-src="image-20220505194156672.png" /></p>
<h3 id="详解容器设计模式">详解容器设计模式</h3>
<p>举个例子，现在需要发布一个应用，这个应用是用JAVA写的，打包完了以后需要把他放在Tomcat的web
APP目录下面，这样就可以启动起来了。</p>
<p>如果需要打包成镜像，通常有几种做法：</p>
<ul>
<li>把WAR包和Tomcat打包进一个镜像里。<strong>此时无论要更新WAR包还是更新Tomcat都要重新做一个镜像。</strong></li>
<li>镜像里只打包Tomcat。他就是一个Tomcat，但是需要使用数据卷的方式，从宿主机把WAR包挂载进Tomcat中，挂载到web
APP目录下。<strong>此时需要维护一套分布式存储系统</strong>，因为master分配负载到工作节点是不一定的，有可能这次分配到节点A下一次就分配到节点B，所以必须有一套分布式存储系统，使得容器无论在A还是在B都可以找到这个WAR包。</li>
</ul>
<blockquote>
<p>即使有了分布式存储系统作Volume，还需要负责维护Volume里的WAR包，需要单独写一套Kubernetes
Volume
插件，用于每次Pod启动之前，把应用所需要的WAR包下载到Volume里，最后才能被应用挂载到。</p>
</blockquote>
<h5 id="init-container">Init Container</h5>
<p>Kubernetes提供了一种在没有分布式存储的情况下也能发布应用的方式。</p>
<p>首先定义一个Init
Container，就是把WAR包从镜像里拷贝到一个Volume里。完成以后就退出。<strong>Init
Container会比用户容器先启动，而且严格按照定义顺序来执行。</strong></p>
<p>由于一个Pod里面的容器是共享Volume的，tomcat容器启动的时候把Init
Container操作的Volume挂载为自己的APP目录，<strong>此时APP目录下一定会找到Init
Contaier操作的WAR包。</strong></p>
<p>有了Init
Container，这个Pod就是一个自包含的“容器组”。不用担心没有分布式存储，Volume不是持久化的，它一定是可以公布的。</p>
<p>通过组合两种不同角色的容器，并且按照像Init Container
这样的一种编排方式，统一的去打包应用。像这样的一个概念，在Kubernetes里就是一个非常经典的容器设计模式，叫做：Sidecar</p>
<p><img data-src="image-20220505203809412.png" /></p>
<h5 id="容器设计模式sidecar">容器设计模式：Sidecar</h5>
<p><strong>在Pod里，定义一些专门的容器，用来执行主业务容器的一些辅助工作，这种容器设计模式被称为Sidecar。</strong></p>
<p>还有一些其他操作：</p>
<ul>
<li><p>原本需要在<strong>容器里执行SSH需要干的事情</strong>，比如执行脚本，判断一些前置条件，其实都可以像Init
Container或者Sidecar的方式去解决；</p></li>
<li><p><strong>日志收集</strong>，日志收集本身是一个进程，就可以打包作为pod的一部分；</p></li>
<li><p><strong>Debug应用</strong>，现在Debug整个应用都可以在应用Pod里面再次定义一个小的额外的Container，因为在同一个Pod里，共享相同的Namespace</p></li>
<li><p>查看其他容器的工作状态，不需要登陆到容器里去看，只要把监控组件装到额外的小容器里就行了。<strong>业务监控</strong>也可以通过Sidecar方式来做。</p></li>
</ul>
<p><strong>通过Sidecar可以把辅助功能从业务容器解耦，这个能力还可以重用</strong>，即同样的一个Sidecar容器可以被全公司的人共用。这就是设计模式的威力。</p>
<p><img data-src="image-20220505203837861.png" /></p>
<h4 id="sidecar应用与日志收集">Sidecar：应用与日志收集</h4>
<p>前面提到的应用日志收集，业务容器将日志写在一个 Volume 里面，而由于
Volume 在 Pod 里面是被共享的，所以日志容器 —— 即 Sidecar
容器一定可以通过共享该
Volume，直接把日志文件读出来，然后存到远程存储里面，或者转发到另外一个例子。<strong>现在业界常用的
Fluentd 日志进程或日志组件，基本上都是这样的工作方式。</strong></p>
<p><img data-src="image-20220505203853464.png" /></p>
<h4 id="sidecar代理容器">Sidecar：代理容器</h4>
<p>假如现在有个 Pod
需要访问一个外部系统，或者一些外部服务，但是这些外部系统是一个集群，那么这个时候如何通过一个统一的、简单的方式，用一个
IP
地址，就把这些集群都访问到？有一种方法就是：修改代码。因为代码里记录了这些集群的地址；<strong>另外还有一种解耦的方法，即通过
Sidecar 代理容器。</strong></p>
<p>简单说，<strong>单独写一个这么小的
Proxy，用来处理对接外部的服务集群，它对外暴露出来只有一个 IP
地址就可以了</strong>。所以接下来，业务容器主要访问 Proxy，然后由 Proxy
去连接这些服务集群，这里的关键在于 Pod 里面多个容器是通过 localhost
直接通信的，因为它们同属于一个 network
Namespace，网络视图都一样，所以它们俩通信
localhost，并没有性能损耗。</p>
<p><img data-src="image-20220505203959014.png" /></p>
<h4 id="sidecar适配器容器">Sidecar：适配器容器</h4>
<p>现在业务暴露出来的 API，比如说有个 API 的一个格式是
A，但是现在有一个外部系统要去访问我的业务容器，它只知道的一种格式是 API
B
,所以要做一个工作，就是把业务容器怎么想办法改掉，要去改业务代码。但实际上，你可以<strong>通过一个
Adapter 帮你来做这层转换。</strong></p>
<p>现在有个例子：现在业务容器暴露出来的监控接口是
/metrics，访问这个这个容器的 metrics 的这个 URL
就可以拿到了。可是现在，这个监控系统升级了，它访问的 URL 是
/health，metrics
不认识。那这个怎么办？<strong>可以不去改代码，而是额外写一个
Adapter，用来把所有对 health 的这个请求转发给 metrics</strong>，所以这个
Adapter 对外暴露的是 health 这样一个监控的
URL，这就可以了，你的业务就又可以工作了。</p>
<p>这样的关键还在于 Pod 之中的容器是通过 localhost
直接通信的，所以没有性能损耗，并且这样一个 <strong>Adapter
容器可以被全公司重用起来</strong>，这些都是设计模式给我们带来的好处。</p>
<h3 id="总结">总结</h3>
<p><img data-src="image-20220505204158684.png" /></p>
]]></content>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>K8s核心概念</title>
    <url>/p/core-concept-about-k8s/</url>
    <content><![CDATA[<p>本文是CNCF × Alibaba 云原生技术公开课的<strong>第三章Kubernetes
核心概念</strong>学习笔记。</p>
<p>关键词：<strong>k8s</strong></p>
<span id="more"></span>
<h3 id="k8s的架构">k8s的架构</h3>
<p>k8s的架构是比较典型的二层架构和server-client架构。Master作为中央的管控节点，会与Node进行一个链接。</p>
<p>所有用户侧的组件，只会和Master进行连接，把希望的状态或者想执行的命令发给Master，Master会把这些命令发给相应的节点。</p>
<p><img data-src="kubernetes-high-level-component-archtecture.jpg" /></p>
<h4 id="master">Master</h4>
<p>Master节点主要包含四个主要的组件：API
Server、Controller、Scheduler以及etcd：</p>
<p><img data-src="image-20220429212540202.png" /></p>
<ul>
<li>API Server：用来处理API操作，k8s的所有组件都会和API
Server进行连接，组件和组件之间一般不进行独立链接，都要依赖API
Server进行消息的传送。</li>
<li>Controller：控制器。用来完成对集群状态的一些管理。例如<strong>自动对容器进行修复，或者自动进行水平扩张</strong>。</li>
<li>Scheduler：调度器。顾名思义就是完成调度的操作。例如把一个用户提交的Container，依赖于它对CPU、对memory请求大小，找一台合适的节点，进行放置。</li>
<li>etcd：分布式存储系统。API
Server中所需要的原信息存在etcd中，etcd本身是一个高可用系统，通过etcd保证整个k8s
Master节点的高可用性。</li>
</ul>
<h4 id="node">Node</h4>
<p>Node是真正运行业务负载的，每个业务负载以<strong>Pod</strong>的形式运行。一个Pod中运行一个或者多个容器，真正运行这些Pod组件的是<strong>kubelet</strong>，也就是Node上面最关键的组件，它通过API
Server接收到需要Pod运行的状态，然后提交到Container
Runtime组件中，在OS上创建容器所需要的环境，最终把容器或者Pod运行起来。Node需要对存储和网络进行管理。K8s不直接管理存储和网络，K8s通过Storage
Plugin或者Network Plugin进行管理，完成存储和网络操作。</p>
<p><img data-src="image-20220429213903847.png" /></p>
<p>在K8s自己的环境里，也会有k8s的Network，他是为了提供Service
Network来进行组网。真正完成组网的组件是Kube-proxy。Kube-proxy利用iptable的能力来组建k8s集群的网络。以上就是Node上面的四个组件（Container
Runtime、Storage Plugin、Network Plugin、Kube-proxy）。</p>
<p>注意：K8s上的Node不会直接和用户进行交互，Node和用户之间的交互只会通过Master节点。用户通过Master节点下发这些信息。K8s上的每个Node，都会运行上面的这几个组件。</p>
<h5 id="例子">例子</h5>
<p>通过一个例子看K8s架构中的这些组件是如何进行交互的。</p>
<p><img data-src="image-20220429220138689.png" /></p>
<p>用户通过UI或者CLI提交一个Pod到K8s进行部署，这个Pod请求会首先通过UI或者CLI提交给K8s
API Server，下一步API
Server会把这个信息写入到存储系统etcd，之后Scheduler会通过API
Server的watch机制得到这个信息：有一个Pod需要被调度。</p>
<p>此时Scheduler会根据这个内存状态进行一次调度决策，在完成这次调度以后，Scheduler向API
Server报告。此时API Server接收到消息以后，把这次结果写入etcd，然后API
Server会通知相应的节点。相应节点的Kubelet会得到这个通知，Kubelet调用Container
Runtime来启动配置这个容器和这个容器的运行环境，去调度Storage
Plugin来配置存储，Network Plugin去配置网络。</p>
<h3 id="核心概念">核心概念</h3>
<h4 id="pod">Pod</h4>
<p>Pod是K8s的一个最小调度和属性单元，用户可以通过K8s的Pod
API来生产一个Pod，让K8s对这个Pod进行调度，也就是把他放到另一个K8s管理的节点上运行起来。</p>
<p>一个Pod简单来说是一组容器的抽象，它包含一个或者多个容器。</p>
<p>Pod包含一些其他所需要的资源，比如卷。</p>
<p><img data-src="image-20220430130241945.png" /></p>
<p>Pod的共享上下文包括一组Linux命名空间，控制组和可能一些其他的隔离方面，这些都是用来隔离Docker容器的技术。在Pod的上下文中，每个独立的应用可能会进一步实施隔离。</p>
<p>就Docker使用的概念术语来说，<strong>Pod类似于共享名字空间和文件系统卷的一组Docker容器</strong>。</p>
<p>Pod给这些容器提供了一个共享的运行环境，他们会共享同一个网络环境，这些容器可以用localhost来进行直接的连接。</p>
<h5 id="使用pod">使用Pod</h5>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.14.2</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>
<p>要创建上面的Pod，请运行以下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f simple-pod.yaml</span><br></pre></td></tr></table></figure>
<p>注意：Pod一般不是直接创建的，而是使用<strong>工作负载资源</strong>创建的，</p>
<h4 id="volume">Volume</h4>
<p>Volume用来管理K8s存储，Volume声明容器中的容器可以访问文件的目录。</p>
<p>一个卷可以被挂载Pod中一个或者多个容器指定的路径下面。</p>
<p>Volume本身是一个<strong>抽象</strong>的概念，一个Volume可以支持多种后端存储。K8s的Volume就支持了很多存储插件，可以支持<strong>本地的存储</strong>，也可以支持<strong>分布式存储</strong>。它也可以支持云存储，例如阿里云上的云盘、AWS上的云盘、Google上的云盘等。</p>
<p><img data-src="image-20220430132644760.png" /></p>
<p>Docker 也有 <a
href="https://docs.docker.com/storage/">卷（Volume）</a>
的概念，但对它只有少量且松散的管理。 Docker
卷是磁盘上或者另外一个容器内的一个目录。 Docker
提供卷驱动程序，但是其功能非常有限。</p>
<p>Kubernetes 支持很多类型的卷。 <a
href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/">Pod</a>
可以同时使用任意数目的卷类型。 临时卷类型的生命周期与 Pod
相同，但持久卷可以比 Pod 的存活期长。 当 Pod 不再存在时，Kubernetes
也会销毁临时卷；不过 Kubernetes 不会销毁<strong>持久卷</strong>。
对于给定 Pod 中任何类型的卷，在容器重启期间数据都不会丢失。</p>
<h5 id="挂载本地卷">挂载本地卷</h5>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.14.2</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/mnt/logs</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">logs</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">go-logs</span></span><br><span class="line">        <span class="attr">hostPath:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/logs</span></span><br></pre></td></tr></table></figure>
<h5 id="挂载网络卷nfs">挂载网络卷NFS</h5>
<p>待补充</p>
<h4 id="deployment">Deployment</h4>
<p>Deployment为<strong>Pod和ReplicaSet（副本）</strong>提供声明式的更新能力。</p>
<p>Deployment是在Pod上层的抽象，用Deployment这个抽象来做应用的真正管理，而Pod是组成Deployment的最小单元。</p>
<p>K8s通过Controller也就是控制器去维护Deployment中Pod的数目，帮助Deployment自动恢复失败的Pod。</p>
<p><img data-src="image-20220430135024552.png" /></p>
<p>例如可以定义一个Deployment，这个Deployment需要两个Pod，当一个Pod失败后，控制器会检测到，他会重新把Deployment中的Pod数据从一个恢复到两个，然后再去重新生成一个Pod。</p>
<p>通过控制器，还可以完成发布的策略，例如进行滚动升级，或者版本回滚等。</p>
<h5 id="创建deployment">创建Deployment</h5>
<p>下面是一个 Deployment 示例。其中创建了一个 ReplicaSet，负责启动三个
<code>nginx</code> Pods：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.14.2</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>
<p>在该例中：</p>
<ul>
<li>创建名为<code>nginx-deployment</code>的Deployment</li>
<li>该Deployment创建<code>3</code>个（由replicas字段标明）Pod副本</li>
<li><code>selector</code>字段定义了Deployment如何查找要管理的Pods。在这里选择Pod模板中定义的标签（app：nginx）。</li>
</ul>
<blockquote>
<p><code>spec.selector.matchLabels</code>
字段是key-Value键值对映射，在matchLabels映射的每个Key-Value映射等效于<code>matchExpressions</code>中的一个元素，即key字段是<code>key</code>，操作符是<code>In</code>，<code>values</code>数组仅包含<code>value</code>。在<code>matchLabels</code>和<code>matchExpressions</code>中给出的所有条件都满足才能匹配。</p>
</blockquote>
<ul>
<li>template包含以下子字段：
<ul>
<li>Pod被使用<code>.metadata.labels</code>字段打上<code>app:nginx</code>标签</li>
<li>Pod模板规约即<code>.template.spec</code>字段指示Pods运行一个nginx容器，该容器运行<code>nginx:1.14.2</code>的Docker
Hub 镜像</li>
<li>创建一个容器并使用<code>.spec.template.spec.containers[0].name</code>字段并将其命名为<code>nginx</code></li>
</ul></li>
</ul>
<h4 id="service">Service</h4>
<p>Service提供了一个或者多个Pod实例的稳定访问地址。</p>
<p>从上文中可以看到，一个Deployment可以有两个甚至更多个完全相同的Pod，对于一个外部的用户来说，访问哪一个Pod其实都属于一样的，所以他希望做一次负载均衡，在做负载均衡的同时，只想访问某一个固定的<strong>VIP，VirtualIP</strong>地址，而不希望得到一个具体的Pod的IP地址。</p>
<p>由于Pod本身可能会终止，如果一个Pod失败了，可能会换成另外一个新的。</p>
<p>对于外部用户来说，提供了多个具体的Pod地址，这个用户需要不停的去更新Pod地址。<strong>K8s的Service把所有Pod的访问能力抽象成一个第三方的IP地址。</strong></p>
<p>实现Service有多种方式，K8s支持Cluster
IP，上面讲过的kuber-proxy组网，也支持nodePort，LoadBalancer等其他的一些访问能力。</p>
<p><img data-src="image-20220430153116204.png" /></p>
<h5 id="使用service">使用Service</h5>
<p>例如，假定有一组Pod，他们对外暴露了9376端口，同时还被打上了app=Myapp标签</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">MyApp</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">9376</span></span><br></pre></td></tr></table></figure>
<p>上述配置创建了一个名为<code>my-service</code>的对象，它会将请求代理到TCP端口9376，并且具有标签<code>app=MyApp</code>的Pod上。</p>
]]></content>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes集群实践（七）Kubernetes安装云原生存储系统LongHorn</title>
    <url>/p/Install-longhorn-on-k8s/</url>
    <content><![CDATA[<p>本文主要介绍如何安装和使用云原生存储系统LongHorn。</p>
<p>关键词：<strong>k8s</strong></p>
<span id="more"></span>
<h2 id="前言">前言</h2>
<p>K8s存储最开始是通过Volume
Plugin实现集成外部存储系统，即不同的存储系统对应不同的volume
plugin。</p>
<p>Volume
Plugin实现代码全部放在了K8s主干代码中，也就是说这些查看与核心K8s二进制文件一起链接、编译、构建和发布。</p>
<p>这种方案存在以下几个问题：</p>
<ol type="1">
<li>在K8s中添加新的存储系统支持需要在<strong>核心K8s（in-tree）</strong>增加插件代码，随着存储插件越来越多，K8s代码也会变得越来庞大。</li>
<li>K8s与具体的存储plugin耦合在一起，一旦存储接口发任何变化都需要重新修改plugin代码，也就是说不得不修改K8s代码，导致K8s代维护越来越困难。</li>
<li>如果这些plugin由bug或者存储系统故障导致crash，可能会导致整个K8s集群crash。这些查看运行时无法做权限管控，具有K8s所以组件的所有权限，存在一定的安全风险。</li>
<li>插件的实现必须通过Golang语言编写并与K8s一起开源，可能对某些厂商不利。</li>
</ol>
<p>因此从1.8开始，K8s停止往K8s代码中增加新的存储支持，并推出了一种新的插件形式支持外部存储系统，即<strong>FlexVolume</strong>。</p>
<p>FlexVolume类似于CNI插件，通过外部脚本集成外部存储接口。这些脚本默认放在<code>/usr/libexec/kubernetes/kubelet-plugins/volume/exec/</code>，需要安装到所有Node节点上。</p>
<p>这样存储插件只需要通过<strong>外部脚本（out-of-tree）</strong>即可实现<code>attach</code>、<code>detach</code>、<code>mount</code>、<code>umount</code>等接口即可集成第三方存储，不需要动K8s源码，可以参考官方的一个<strong>LVM
FlexVolume Demo[1]</strong>。</p>
<p>但是这种方法也有问题：</p>
<ul>
<li>脚本文件放在host主机上，因此驱动不得不通过访问宿主机的根文件系统去运行脚本。</li>
<li>这些插件还有第三方程序以来或者OS兼容性要求，还需要在所有的Node节点安装这些依赖并解决兼容性问题。</li>
</ul>
<p>因此这种方式虽然解决了in-tree的问题，但是这种方式用起来不太优雅，不太原生。</p>
<p>因此Kubernetes从1.9开始就引入了Container Storage
Interface（CSI）容器存储接口，并与1.13版本正式GA。</p>
<p>CSI的实现方案和CRI类似，通过gRPC与volume
driver进行通信，存储厂商需要实现三个服务接口Identify Service、Control
Service、Node Service：</p>
<ul>
<li>Indentfy Service用于返回一些插件信息；</li>
<li>Control Service实现Volume的CURD操作；</li>
<li>Node
Service运行在所有的Node节点，用于实现把volume挂载在当前Node节点的指定目录，该服务会监听一个Socket，controller通过这个socket进行通信，可以参考官方提供的例子：<strong>CSI
Hostpath driver Sample[2]</strong>。</li>
</ul>
<p>更多CSI介绍可以参考官方的设计文档，<strong>CSI Volume Plugins in
Kubernetes Design Doc[3]</strong>。</p>
<p>通过CSI基本解决了in-tree以及FlexVolume的大多数问题，未来K8s会把in-tree的存储插件都迁移到CSI。</p>
<p>当然Flex Volume Plugin也会与新的CSI Volume
Plugin并存以便兼容现有的第三方FlexVolume存储插件。</p>
<h3 id="为什么需要云原生分布式存储">为什么需要云原生分布式存储</h3>
<p>通过CSI接口或者Flex Volume Plugin解决了K8s集成外部存储的问题。</p>
<p>目前K8s以及能够支持非常多的外部存储系统了，如NFS、GlusterFS、Ceph、OpenStack等，这些存储系统目前主流的部署方式还是运行在K8s集群之外单独部署和维护，不符合All
in K8s的原则。</p>
<p>如何没有分布式存储，则不得不单独部署一套分布式存储。</p>
<p>很多分布式存储部署还是比较复杂的。而K8s天生就具有快速部署和编排应用的能力，如果能把分布式存储的部署也能通过K8s编排起来，则显然能够大大降低分布式存储的部署和维护成本，甚至使用一条apply目录就可以部署一个集群。</p>
<p>这里主要有两种思路：</p>
<ul>
<li>一是重新针对云原生平台设计一个分布式存储，这个分布式存储系统组件是为服务化的，能够复用K8s的调度、故障恢复和编排能力，如后面介绍的Longhorn、OpenEBS。</li>
<li>二是设计微服务组件把已有的分布式存储系统包装管理起来，使原来的分布式存储能够运行在K8s平台上，实现通过K8s管理原有的分布式存储系统，如Rook</li>
</ul>
<h3 id="container-attached-storage容器存储的未来">Container Attached
Storage，容器存储的未来？</h3>
<p>我们都知道，组成云计算的三大基石为计算、存储和网络，K8s计算（Runtime）、存储（PV/PVC）和网络（Subnet/DNS/Service/Ingress）的设计都是开放的，可以集成不同的方案，比如网络通过CNI接口支持集成Flannel、Calico等方案，运行时（Runtime）通过CRI支持Docker、Rkt、Kata等运行时方案，存储通过Volume
Plugin支持集成如AWS EBS、Ceph、OpenStack等存储系统。</p>
<p>但是目前主流的方案中存储与计算、网络稍有不同，计算和网络都是以微服务的形式通过K8s统一编排管理的，即K8s既是计算和网络的消费者，也是计算和网络的编排者和管理者。</p>
<p>而存储不一样，虽然K8s已经设计了PV/PVC机制来管理外部存储，但是只是弄了个标准接口集成，存储本身还是通过独立的存储系统来管理，K8s是压根不知道底层存储是如何编排和调度的。</p>
<p>社区既然认为计算和网络都由K8s统一编排了，那存储也应该统一编排。</p>
<p>于是社区提出了Container Attached
Storage（CAS）的理念，这个理念的目标就是利用K8s来编排存储，从而实现K8s编排一切，这里的一切包括计算、存储、网络，还包括应用、服务和软件。</p>
<p>CAS提出如下方案：</p>
<ul>
<li>每个Volume都由一个轻量级的Controller来管理，这个Controller可以是单独的Pod。</li>
<li>这个Controller与使用该Volume的应用Pod在同一个Node（sidecar模式）</li>
<li>不同的Volume的数据使用多个独立的Controller Pod进行管理。</li>
</ul>
<figure>
<img data-src="Kubernetes安装云原生存储系统LongHorn/cas-768x614-1.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>由于Pod是通过K8s编排和存储的，因此毫无疑问通过这种形式就实现了K8s的编排和调度。</p>
<p>K8s目前毕竟是主流趋势，通过K8s编排和管理存储也必然是一种发展趋势。</p>
<h2 id="云原生存储系统longhorn">云原生存储系统Longhorn</h2>
<h3 id="longhorn简介">Longhorn简介</h3>
<p><strong>Longhorn</strong>最初由Rancher公司开发并贡献给社区，专门针对K8s设计开发的<strong>云原生分布式块存储系统</strong>，因此和K8s契合度很高，主要体现在以下两个方面：</p>
<ul>
<li>本身运行在K8s平台上，通过容器和微服务方式运行；</li>
<li>很好的和PV/PVC结合。</li>
</ul>
<p>与其他分布式块存储系统最大的不同点是，Longhorn并没有设计一个非常复杂的控制器来管理Volume数据卷，而是将控制器拆分成一个个非常轻量级的微控制器，这些控制器通过K8s等平台进行调度和编排。</p>
<p>每个微控制器只管理一个Volume，这种基于微服务的设计使得每个Volume相对独立，控制器升级时开业先选择一部分卷进行操作，如果升级出现问题，可以快速选择回滚到旧版本，升级过程中之可能会影响正在升级的Volume。不会导致其他Volume
IO中断。</p>
<p>Longhorn的实现和CAS的设计理念基本上是一致的，相比Ceph来说简单很多，而又具备分布式块存储的系统的一些基本功能：</p>
<ul>
<li><p>支持多副本，不存在单点故障</p></li>
<li><p>支持增量快照</p></li>
<li><p>支持备份到其他外部存储系统，比如S3；</p></li>
<li><p>精简配置</p></li>
</ul>
<p>Longhorn内置了一个Web
UI，能够通过UI很方便的管理Node、Volume以及Backup。</p>
<p>根据官方的说法，Longhorn不是为了取代其他的分布式块存储系统，而是为了设计一个更简单更适合容器环境的块存储系统，其他分布式存储有的一些高级功能Longhorn并没有实现，比如去重，压缩，分块，多路径等。</p>
<p>Longhorn存储管理机制比较简单，当在Longhorn中Node节点增加物理存储时，其本质就是把Node对应的路径通过HostPath挂载到Pod中。</p>
<h3 id="longhorn部署">Longhorn部署</h3>
<h4 id="安装">安装</h4>
<p>国外地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f https://raw.githubusercontent.com/longhorn/longhorn/master/deploy/longhorn.yaml</span><br></pre></td></tr></table></figure>
<p>Gitee加速</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f https://gitee.com/mirrors/longhorn/raw/master/deploy/longhorn.yaml</span><br></pre></td></tr></table></figure>
<p>最好是提前下载好镜像，参考地址：https://gitee.com/mirrors/longhorn/raw/master/deploy/longhorn-images.txt</p>
<p>稍后片刻，查看运行状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get pods -n longhorn-system</span><br></pre></td></tr></table></figure>
<figure>
<img data-src="Kubernetes安装云原生存储系统LongHorn/image-20220716153619243.png"
alt="image-20220716153619243" />
<figcaption aria-hidden="true">image-20220716153619243</figcaption>
</figure>
<p>如上图所示，说明安装成功。</p>
<h4 id="访问ui">访问UI</h4>
<p>查看UI Service的详细信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get svc longhorn-frontend -o wide -n longhorn-system</span><br></pre></td></tr></table></figure>
<figure>
<img data-src="Kubernetes安装云原生存储系统LongHorn/image-20220716154810558.png"
alt="image-20220716154810558" />
<figcaption aria-hidden="true">image-20220716154810558</figcaption>
</figure>
<p>可以看到服务类型是ClusterIP，此时只能<strong>在集群内部访问</strong>，由于我是远程管理的K8s集群，因此需要将过这个端口暴露出来。</p>
<p>暂时先使用NodePort的方式暴露这个服务，等到后面弄清楚Ingress的原理以后再迁移过去。</p>
<p>更改<code>longhorn-frontend</code>的配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl edit svc longhorn-frontend -n longhorn-system</span><br></pre></td></tr></table></figure>
<figure>
<img data-src="Kubernetes安装云原生存储系统LongHorn/image-20220716155901649.png"
alt="image-20220716155901649" />
<figcaption aria-hidden="true">image-20220716155901649</figcaption>
</figure>
<p>等待生效以后，就可以访问UI了。</p>
<p>访问的IP是集群的local
IP，端口则是30000。NodePort的默认端口是30000-32767，这个好像可以根据kubelet的选项进行修改，这里测试原因就没必要修改啦。</p>
<p><img data-src="Kubernetes安装云原生存储系统LongHorn/image-20220716161812262.png" /></p>
<p>我在这个work01所在的节点上挂载了一块硬盘，挂载路径在<code>/mnt</code>，大小只有1T，不过这里为啥Allocated了2T。。真是百思不得其解。</p>
<h4 id="声明pvc">声明PVC</h4>
<p>对于动态PV来说，只需要设置好StorageClass+PVC，在设置Pod
Volume时就可以使用Volume了</p>
<p>安装好longhorn以后，默认安装了StorageClass</p>
<p><img data-src="Kubernetes安装云原生存储系统LongHorn/image-20220716163325775.png" /></p>
<p>因此只需要设置PVC</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mysql-longborn-pvc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">longhorn</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">3Gi</span></span><br></pre></td></tr></table></figure>
<p>设置完PVC以后就可以设置Pod时候添加Volume了</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mysql-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">nodeName:</span> <span class="string">worker01</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mysql-pod-1</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:5</span></span><br><span class="line">    <span class="attr">args:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="string">--max_connections=10000</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--character-set-server=utf8mb4</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--collation-server=utf8mb4_general_ci</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--default-authentication-plugin=mysql_native_password</span></span><br><span class="line">    <span class="attr">env:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MYSQL_ROOT_PASSWORD</span></span><br><span class="line">      <span class="attr">value:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mysql-data</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/var/lib/mysql</span>             <span class="comment"># 容器挂载路径</span></span><br><span class="line">      <span class="attr">subPath:</span> <span class="string">mysql-data</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mysql-data</span></span><br><span class="line">    <span class="attr">persistentVolumeClaim:</span></span><br><span class="line">      <span class="attr">claimName:</span> <span class="string">mysql-longborn-pvc</span></span><br></pre></td></tr></table></figure>
<p>当我兴冲冲的执行完<code>kubectl apply -f</code>之后，才发现我的Pod怎么也启动不起来，他总是显示</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpc error: code = DeadlineExceeded desc = volume pvc-084b4ca7-c972-4de6-aa29-55101df79635 failed to attach to node worker01</span><br></pre></td></tr></table></figure>
<p>而Longhorn Dashbroad UI总是显示</p>
<p><img data-src="Kubernetes安装云原生存储系统LongHorn/image-20220716171407840.png" /></p>
<p>经过查找，发现了原因：</p>
<ul>
<li>当前集群内只有1个worker节点，而默认的<strong>Default Replica
Count</strong>被设置为3，因此控制器想做备份但是找不到合适的节点，因此调度失败；</li>
<li>安装在节点的StorageClass有一个numberOfReplicas字段被设置为3，造成了调度失败；而尝试直接修改这个StorageClass却显示<strong>Forbidden:
updates to parameters are
forbidden.</strong>，猜测是因为某个策略禁止修改了此参数；</li>
</ul>
<p>解决方案：</p>
<ol type="1">
<li><del>删除现在的StorageClass资源清单</del></li>
<li><del>更改StorageClass资源清单为符合要求，并重新应用</del></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl delete sc longhorn</span><br></pre></td></tr></table></figure>
<p>但。。。这种方法也没用，删除这个StorageClass后又会立马生成。</p>
<p>后来找到了方法：修改这个文件对应的ConfigMap</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl edit cm longhorn-storageclass -n longhorn-system</span><br></pre></td></tr></table></figure>
<p><img data-src="Kubernetes安装云原生存储系统LongHorn/image-20220716174724139.png" /></p>
<p>BUTTTTTTTTTTTTTTTTTT，还是失败了。麻了。</p>
]]></content>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes集群实践（一）使用Kubeadm创建一个K8s集群</title>
    <url>/p/create-a-k8s-cluster-with-kubeadm/</url>
    <content><![CDATA[<p>本文主要介绍如何使用一个kubeadm创建一个K8s集群。</p>
<p>关键词：<strong>docker，k8s</strong></p>
<span id="more"></span>
<h3 id="准备工作">准备工作</h3>
<p>首先确保你至少有两台机器，这里准备了四台机器：一台master节点，三台node节点，主机名分别为node1、node2、node3。</p>
<p>master节点配置了管理node集群的脚本，分别是批量执行命令的<strong>xcall</strong>脚本和批量拷贝文件的<strong>xsync</strong>脚本。</p>
<p>安装xcall和xsync脚本的机器需要先配置<strong>免密码登录</strong>，并安装<strong>rsync服务</strong>。</p>
<h4 id="xcall">xcall</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取控制台指令</span></span><br><span class="line"></span><br><span class="line">cmd=$*</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断指令是否为空</span></span><br><span class="line"><span class="keyword">if</span> [ ! -n <span class="string">&quot;<span class="variable">$cmd</span>&quot;</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;command can not be null !&quot;</span></span><br><span class="line">        <span class="built_in">exit</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取当前登录用户</span></span><br><span class="line">user=`<span class="built_in">whoami</span>`</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在从机执行指令,这里需要根据你具体的集群情况配置，host与具体主机名一致，同上</span></span><br><span class="line"><span class="keyword">for</span> host <span class="keyword">in</span> node1 node2 node3</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">        <span class="built_in">echo</span> =============== <span class="variable">$host</span> ===============</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;--&gt; excute command \&quot;<span class="variable">$cmd</span>\&quot;&quot;</span></span><br><span class="line">        ssh <span class="variable">$host</span> <span class="variable">$cmd</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;excute successfully !&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="xsync">xsync</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取输出参数，如果没有参数则直接返回</span></span><br><span class="line">pcount=<span class="variable">$#</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$pcount</span> -eq 0 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;no parameter find !&quot;</span>;</span><br><span class="line">        <span class="built_in">exit</span>;</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取传输文件名</span></span><br><span class="line">p1=<span class="variable">$1</span></span><br><span class="line">filename=`<span class="built_in">basename</span> <span class="variable">$p1</span>`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;load file <span class="variable">$p1</span> success !&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取文件的绝对路径</span></span><br><span class="line">pdir=`<span class="built_in">cd</span> -P $(<span class="built_in">dirname</span> <span class="variable">$p1</span>); <span class="built_in">pwd</span>`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;file path is <span class="variable">$pdir</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取当前用户（如果想使用root用户权限拷贝文件，在命令后加入-root参数即可）</span></span><br><span class="line">user=<span class="variable">$2</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;<span class="variable">$user</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line"><span class="string">&quot;-root&quot;</span>)</span><br><span class="line">        user=<span class="string">&quot;root&quot;</span>;;</span><br><span class="line"><span class="string">&quot;&quot;</span>)</span><br><span class="line">        user=`<span class="built_in">whoami</span>`;;</span><br><span class="line">*)</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;illegal parameter <span class="variable">$user</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$user</span></span><br><span class="line"><span class="comment"># 拷贝文件到从机(这里注意主机的host需要根据你的实际情况配置，要与你具体的主机名对应)</span></span><br><span class="line"><span class="keyword">for</span> host <span class="keyword">in</span> node1 node2 node3</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;================<span class="variable">$host</span>=================&quot;</span></span><br><span class="line">        ssh <span class="variable">$host</span> <span class="string">&quot;mkdir -p <span class="variable">$pdir</span>&quot;</span></span><br><span class="line">        rsync -av <span class="variable">$pdir</span>/<span class="variable">$filename</span> <span class="variable">$host</span>:<span class="variable">$pdir</span>/<span class="variable">$filename</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;complate !&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="设置主机公钥确认">设置主机公钥确认</h4>
<p>SSH
公钥检查是一个重要的安全机制，可以防范中间人劫持等黑客攻击。但是在特定情况下，严格的
SSH 公钥检查会破坏一些依赖 SSH
协议的自动化任务，就需要一种手段能够<strong>绕过 SSH
的公钥检查</strong>。</p>
<p>编辑<code>/etc/ssh/ssh_config</code>文件，修改<code>StrictHostKeyChecking=no</code>.</p>
<ol type="1">
<li><code>StrictHostKeyChecking=no</code>
最不安全的级别，当然也没有那么多烦人的提示了，相对安全的内网<strong>测试</strong>时建议使用。如果连接<strong>server</strong>的key在本地不存在，那么就自动添加到文件中（默认是known_hosts），并且给出一个警告。</li>
<li><code>StrictHostKeyChecking=ask</code>
默认的级别，就是出现刚才的提示了。如果连接和key不匹配，给出提示，并拒绝登录。</li>
<li><code>StrictHostKeyChecking=yes</code>
最安全的级别，如果连接与key不匹配，就拒绝连接，不会提示详细信息。</li>
</ol>
<h4
id="将两个脚本所在的目录添加到环境变量">将两个脚本所在的目录添加到环境变量</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;export PATH=<span class="variable">$PATH</span>:~/.bin&quot;</span> &gt;&gt; ~/.bashrc</span><br></pre></td></tr></table></figure>
<h4 id="检查脚本是否正常运行">检查脚本是否正常运行</h4>
<p><img data-src="image-20220504134400786.png" /></p>
<h3 id="安装kubeadm">安装kubeadm</h3>
<h4 id="开始之前">开始之前</h4>
<p>你需要准备：</p>
<ul>
<li>一台兼容的 Linux 主机。Kubernetes 项目为基于 Debian 和 Red Hat 的
Linux 发行版以及一些不提供包管理器的发行版提供通用的指令</li>
<li>每台机器 2 GB 或更多的 RAM
（如果少于这个数字将会影响你应用的运行内存)</li>
<li>2 CPU 核或更多</li>
<li>集群中的所有机器的网络彼此均能相互连接(公网和内网都可以)</li>
<li>节点之中不可以有重复的主机名、MAC 地址或 product_uuid。请参见<a
href="https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/install-kubeadm/#verify-mac-address">这里</a>了解更多详细信息。</li>
<li>开启机器上的某些端口。请参见<a
href="https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/install-kubeadm/#check-required-ports">这里</a>
了解更多详细信息。</li>
<li><strong>禁用交换分区</strong>。为了保证 kubelet 正常工作，你
<strong>必须</strong> 禁用交换分区。</li>
</ul>
<h5 id="禁用交换分区">禁用交换分区</h5>
<p>临时关闭</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">swapoff -a</span><br></pre></td></tr></table></figure>
<p>永久关闭</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/fstab</span><br></pre></td></tr></table></figure>
<p>注释掉最后一行的swap</p>
<p><img data-src="image-20220504135341965.png" /></p>
<h5 id="确保每个节点上-mac-地址和-product_uuid-的唯一性">确保每个节点上
MAC 地址和 product_uuid 的唯一性</h5>
<p>这里直接使用xcall脚本执行命令。</p>
<p>一般来讲，硬件设备会拥有唯一的地址，但是有些虚拟机的地址可能会重复。
Kubernetes 使用这些值来唯一确定集群中的节点。
如果这些值在每个节点上不唯一，可能会导致<strong>安装失败</strong>。</p>
<p>检查mac地址</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip <span class="built_in">link</span></span><br></pre></td></tr></table></figure></p>
<p><img data-src="image-20220504140036574.png" /></p>
<p>检查product_uuid</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">cat</span> /sys/class/dmi/id/product_uuid</span><br></pre></td></tr></table></figure>
<p><img data-src="image-20220504140019711.png" /></p>
<h5 id="检查网络适配器">检查网络适配器</h5>
<p>如果<strong>有一个以上的网络适配器</strong>，同时K8s通过默认路由不可达，此时需要先添加默认IP路由规则。</p>
<p>这里使用的是同一局域网的虚拟机，默认符合规则。</p>
<h4 id="允许-iptables-检查桥接流量">允许 iptables 检查桥接流量</h4>
<p>检查<code>br_netfilter</code>模块是否被加载</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsmod | grep br_netfilter</span><br></pre></td></tr></table></figure>
<p><img data-src="image-20220504140607226.png" /></p>
<p>这里没有加载，需要设置加载</p>
<p>显式加载</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo modprobe br_netfilter</span><br></pre></td></tr></table></figure>
<p>为了让Linux开机时就加载，需要修改<code>sysctl</code> 配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &lt;&lt;<span class="string">EOF | sudo tee /etc/modules-load.d/k8s.conf</span></span><br><span class="line"><span class="string">br_netfilter</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> &lt;&lt;<span class="string">EOF | sudo tee /etc/sysctl.d/k8s.conf</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-ip6tables = 1</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-iptables = 1</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line">sudo sysctl --system</span><br></pre></td></tr></table></figure>
<h4 id="安装ipvs所需要的模块">安装IPVS所需要的模块</h4>
<p>ipvs网络模式比iptables具有更优秀的性能</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &lt;&lt;<span class="string">EOF | sudo tee /etc/modules-load.d/k3s.conf</span></span><br><span class="line"><span class="string">ip_vs</span></span><br><span class="line"><span class="string">ip_vs_lc</span></span><br><span class="line"><span class="string">ip_vs_rr</span></span><br><span class="line"><span class="string">ip_vs_wrr</span></span><br><span class="line"><span class="string">ip_vs_sh</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>
<p>实时加载模块</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo modprobe ip_vs</span><br><span class="line">sudo modprobe ip_vs_lc</span><br><span class="line">sudo modprobe ip_vs_rr</span><br><span class="line">sudo modprobe ip_vs_wrr</span><br><span class="line">sudo modprobe ip_vs_sh</span><br></pre></td></tr></table></figure>
<p>安装查看ipvs表软件包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install ipvsadm -y</span><br></pre></td></tr></table></figure>
<p>服务起来以后，可以执行以下命令查看ipvs规则</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ipvsadm -<span class="built_in">ln</span></span><br></pre></td></tr></table></figure>
<h4 id="检查所需端口">检查所需端口</h4>
<p>为了和K8s组件通信，需要检查特定端口</p>
<p>具体请查看：https://kubernetes.io/zh/docs/reference/ports-and-protocols/</p>
<h4 id="安装容器运行时">安装容器运行时</h4>
<h5 id="设置运行时">设置运行时</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &lt;&lt;<span class="string">EOF | sudo tee /etc/modules-load.d/containerd.conf</span></span><br><span class="line"><span class="string">overlay</span></span><br><span class="line"><span class="string">br_netfilter</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line">sudo modprobe overlay</span><br><span class="line">sudo modprobe br_netfilter</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置必需的 sysctl 参数，这些参数在重新启动后仍然存在。</span></span><br><span class="line"><span class="built_in">cat</span> &lt;&lt;<span class="string">EOF | sudo tee /etc/sysctl.d/99-kubernetes-cri.conf</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-iptables  = 1</span></span><br><span class="line"><span class="string">net.ipv4.ip_forward                 = 1</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-ip6tables = 1</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 应用 sysctl 参数而无需重新启动</span></span><br><span class="line">sudo sysctl --system</span><br></pre></td></tr></table></figure>
<p>K8s支持以下运行时</p>
<table>
<thead>
<tr class="header">
<th>运行时</th>
<th>域套接字</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Docker Engine</td>
<td><code>/var/run/dockershim.sock</code></td>
</tr>
<tr class="even">
<td>containerd</td>
<td><code>/run/containerd/containerd.sock</code></td>
</tr>
<tr class="odd">
<td>CRI-O</td>
<td><code>/var/run/crio/crio.sock</code></td>
</tr>
</tbody>
</table>
<p>由于在<strong>1.24之后的版本不在支持Dockershim
</strong>，因此不推荐使用Docker
Engine作为K8s容器运行时，这里使用<strong>containerd</strong>。</p>
<p>方法1：使用docker-ce 镜像源</p>
<p>后期还可以通过安装docker-cli实现docker的一系列操作，如<strong>打包镜像、使用docker-compose运行容器</strong>等。</p>
<ul>
<li><p>按照安装docker的方法，安装docker需要的apt源；</p></li>
<li><p>执行以下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update &amp;&amp; sudo apt-get install containerd.io</span><br></pre></td></tr></table></figure></li>
</ul>
<p>配置运行时</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> -p /etc/containerd</span><br><span class="line">containerd config default | sudo <span class="built_in">tee</span> /etc/containerd/config.toml</span><br></pre></td></tr></table></figure>
<p>重新启动 containerd</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart containerd</span><br></pre></td></tr></table></figure>
<p><img data-src="image-20220504143744362.png" /></p>
<p>方法2：直接使用<code>nerdctl</code>打包好的containerd运行时和一系列插件</p>
<p>nerdctl是<code>containerd</code>项目下的和docker
cli兼容的命令行。现在已经支持docker-cli的大部分功能。甚至可以直接将nerdctl设置为docker，这样就可以无缝使用docker和docker
compose的命令啦。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">alias</span> docker=`sudo nerdctl`</span><br><span class="line"><span class="built_in">alias</span> docker-compose=`sudo nerdctl compose`</span><br></pre></td></tr></table></figure>
<p>项目地址：<a
href="https://github.com/containerd/nerdctl">https://github.com/containerd/nerdctl</a></p>
<p>直接下载<strong>Full</strong>的版本</p>
<p>下载完毕以后执行安装命令，以0.20.0版本为例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo tar Cxzvvf /usr/local nerdctl-full-0.20.0-linux-amd64.tar.gz</span><br></pre></td></tr></table></figure>
<p>设置自动启动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> buildkit.service --now</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> containerd.service --now</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> stargz-snapshotter.service --now</span><br></pre></td></tr></table></figure>
<h5 id="配置stargz-snapshotter">配置stargz-snapshotter</h5>
<p><strong>Fast container image distribution plugin with lazy
pulling</strong>，项目地址：<a
href="https://github.com/containerd/stargz-snapshotter">https://github.com/containerd/stargz-snapshotter</a></p>
<p>修改<code>/etc/containerd/config.toml</code>文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">version = 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># Plug stargz snapshotter into containerd</span></span><br><span class="line"><span class="comment"># Containerd recognizes stargz snapshotter through specified socket address.</span></span><br><span class="line"><span class="comment"># The specified address below is the default which stargz snapshotter listen to.</span></span><br><span class="line">[proxy_plugins]</span><br><span class="line">  [proxy_plugins.stargz]</span><br><span class="line">    <span class="built_in">type</span> = <span class="string">&quot;snapshot&quot;</span></span><br><span class="line">    address = <span class="string">&quot;/run/containerd-stargz-grpc/containerd-stargz-grpc.sock&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Use stargz snapshotter through CRI</span></span><br><span class="line">[plugins.<span class="string">&quot;io.containerd.grpc.v1.cri&quot;</span>.containerd]</span><br><span class="line">  snapshotter = <span class="string">&quot;stargz&quot;</span></span><br><span class="line">  disable_snapshot_annotations = <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h5 id="设置docker-hub镜像源">设置Docker Hub镜像源</h5>
<p>默认containerd在Docker Hub拉取镜像，这样速度很慢</p>
<p><img data-src="image-20220505115520415.png" /></p>
<p>在<code>/etc/containerd</code>创建mirrors.d文件夹</p>
<p><img data-src="image-20220505115710174.png" /></p>
<p>编辑hosts.toml，这里使用daocloud的源</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server</span> = <span class="string">&quot;https://docker.io&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[host.&quot;http://f1361db2.m.daocloud.io&quot;]</span></span><br><span class="line">  <span class="attr">capabilities</span> = [<span class="string">&quot;pull&quot;</span>, <span class="string">&quot;resolve&quot;</span>]</span><br></pre></td></tr></table></figure>
<h5 id="使用-systemd-cgroup-驱动程序">使用 <code>systemd</code> cgroup
驱动程序</h5>
<p>结合 <code>runc</code> 使用 <code>systemd</code> cgroup 驱动，在
<code>/etc/containerd/config.toml</code> 中设置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes.runc]</span><br><span class="line">  ...</span><br><span class="line">  [plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes.runc.options]</span><br><span class="line">    SystemdCgroup = true</span><br></pre></td></tr></table></figure>
<p>如果您应用此更改，请确保再次重新启动 containerd：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart containerd</span><br></pre></td></tr></table></figure>
<p>注意：此项更改并不能使用<code>crictl info</code> 、
<code>config dump</code>或<code>nerdctl info</code>查看，可以通过<code>systemctl status containerd</code>查看是否存在<code>/opt/dev/bin/containerd-shim-runc-v2</code>来判断是否生效。</p>
<blockquote>
<p>https://kubernetes.io/zh/docs/setup/production-environment/container-runtimes/#containerd</p>
<p>https://github.com/containerd/containerd/issues/4900#issuecomment-756085464</p>
</blockquote>
<h4 id="安装-kubeadmkubelet-和-kubectl">安装 kubeadm、kubelet 和
kubectl</h4>
<p>这里使用基于Debian的发行版</p>
<ol type="1">
<li>更新 <code>apt</code>包索引并安装使用 Kubernetes <code>apt</code>
仓库所需要的包</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install -y apt-transport-https ca-certificates curl</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>安装仓库密钥，这里使用<strong>阿里云的源</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | sudo apt-key add - </span><br><span class="line"><span class="built_in">cat</span> &lt;&lt; <span class="string">EOF &gt;/etc/apt/sources.list.d/kubernetes.list</span></span><br><span class="line"><span class="string">deb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>
<p>官方源：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add - </span><br><span class="line"><span class="built_in">cat</span> &lt;&lt; <span class="string">EOF &gt;/etc/apt/sources.list.d/kubernetes.list</span></span><br><span class="line"><span class="string">deb https://apt.kubernetes.io/ kubernetes-xenial main</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>更新apt包索引，安装 kubelet、kubeadm 和
kubectl，并<strong>锁定其版本</strong>：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install -y kubelet kubeadm kubectl</span><br><span class="line">sudo apt-mark hold kubelet kubeadm kubectl</span><br></pre></td></tr></table></figure>
<p>kubelet 现在每隔几秒就会重启，因为它陷入了一个等待 kubeadm
指令的死循环。</p>
<p><img data-src="image-20220504145739260.png" /></p>
<h4 id="配置容器运行时-cgroup-驱动">配置容器运行时 cgroup 驱动</h4>
<p>由于 kubeadm 把 kubelet 视为一个系统服务来管理，所以对基于 kubeadm
的安装， <strong>推荐使用 <code>systemd</code> 驱动</strong>，不推荐
<code>cgroupfs</code> 驱动。</p>
<p>一个示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># kubeadm-config.yaml</span></span><br><span class="line">kind: ClusterConfiguration</span><br><span class="line">apiVersion: kubeadm.k8s.io/v1beta3</span><br><span class="line">kubernetesVersion: v1.23.6</span><br><span class="line">imageRepository: registry.cn-hangzhou.aliyuncs.com/google_containers</span><br><span class="line">networking:</span><br><span class="line">  podSubnet: <span class="string">&quot;10.244.0.0/16&quot;</span> <span class="comment"># --pod-network-cidr # 网络插件地址</span></span><br><span class="line">---</span><br><span class="line">kind: KubeletConfiguration</span><br><span class="line">apiVersion: kubelet.config.k8s.io/v1beta1</span><br><span class="line">cgroupDriver: systemd</span><br></pre></td></tr></table></figure>
<h3 id="启动控制节点">启动控制节点</h3>
<p>启用控制平面前应先启动containerd服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> containerd --now</span><br></pre></td></tr></table></figure>
<p>修改<code>containerd.sock</code>权限，不使用sudo也可以拉取镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">chown</span> -R wf09:wf09 /run/containerd/</span><br></pre></td></tr></table></figure>
<p>运行master节点之前可以先拉取本地镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubeadm config images pull --config kubeadm-config.yaml</span><br></pre></td></tr></table></figure>
<p>在master节点运行以下命令，同时传递上文中说到的kubeadm-config.yaml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubeadm init --config kubeadm-config.yaml</span><br></pre></td></tr></table></figure>
<p>可以使用以下命令重新打印token和加入命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubeadm token create --print-join-command</span><br></pre></td></tr></table></figure>
<h3 id="删除控制节点">删除控制节点</h3>
<p>如果在启动后控制平面以后出现错误，必须先<strong>删除控制平面</strong></p>
<p>更详细的可以参考<a
href="https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/#tear-down">卸载集群</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo kubeadm reset</span><br></pre></td></tr></table></figure>
<p><img data-src="image-20220505095239821.png" /></p>
<h3 id="控制节点启动成功">控制节点启动成功</h3>
<p><img data-src="image-20220505101003030.png" /></p>
<p>如果使用非root用户运行kubectl，需要运行以下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">sudo <span class="built_in">cp</span> -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">sudo <span class="built_in">chown</span> $(<span class="built_in">id</span> -u):$(<span class="built_in">id</span> -g) <span class="variable">$HOME</span>/.kube/config</span><br></pre></td></tr></table></figure>
<p>如果使用root用户，则可以运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> KUBECONFIG=/etc/kubernetes/admin.conf</span><br></pre></td></tr></table></figure>
<p>还需要记录一下token，后面的节点<strong>加入集群</strong>需要这个</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubeadm <span class="built_in">join</span> 192.168.15.201:6443 --token 57hnhv.sy8wb7c1gsrzbotp \</span><br><span class="line">        --discovery-token-ca-cert-hash sha256:15cb23455b3cb846261b535dcbbf73ea36e3f089cf4b8b36623bf36b461b522d</span><br></pre></td></tr></table></figure>
<h3 id="安装-pod-网络附加组件">安装 Pod 网络附加组件</h3>
<p>必须部署一个基于Pod网络插件的容器网络接口，以便的Pod可以相互通信</p>
<p>安装之前需要先设置<strong>网络插件地址</strong>，在kubeadm-config.yaml添加以下配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">networking:</span></span><br><span class="line">  <span class="attr">podSubnet:</span> <span class="string">&quot;10.244.0.0/16&quot;</span> <span class="comment"># --pod-network-cidr # 网络插件地址</span></span><br></pre></td></tr></table></figure>
<p>这里使用<strong>flannel</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f https://raw.githubusercontent.com/flannel-io/flannel/master/Documentation/kube-flannel.yml</span><br></pre></td></tr></table></figure>
<p><img data-src="image-20220505112506790.png" /></p>
<p>检查节点状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get nodes</span><br></pre></td></tr></table></figure>
<p><img data-src="image-20220505112608594.png" /></p>
<p>当STATUS状态为Ready时说明集群已经启动成功了。</p>
<h3 id="设置master为可调度节点">设置Master为可调度节点</h3>
<p>默认情况下，<code>Master</code> 不参与 <code>Pod</code>
调度，也就是说不会在 <code>Master</code> 节点上部署其他非系统
<code>Pod</code>。可以使用以下命令调整这个策略</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 允许 Master 部署 Pod</span></span><br><span class="line">kubectl taint nodes master node-role.kubernetes.io/control-plane- --overwrite</span><br><span class="line"></span><br><span class="line"><span class="comment"># 禁止 Master 部署 Pod</span></span><br><span class="line">kubectl taint nodes master node-role.kubernetes.io/control-plane=:NoSchedule --overwrite</span><br><span class="line"></span><br><span class="line"><span class="comment"># 其中 master 是操作的节点名称</span></span><br></pre></td></tr></table></figure>
<h3 id="启动工作节点">启动工作节点</h3>
<p>准备工作首先也需要完成<strong>安装kubeadm</strong>的步骤。</p>
<p>剩下的步骤就比较简单了，找到上文中<strong>成功启动K8s控制节点</strong>中的token，在工作节点执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo kubeadm <span class="built_in">join</span> 192.168.15.201:6443 --token 57hnhv.sy8wb7c1gsrzbotp \</span><br><span class="line">--discovery-token-ca-cert-hash sha256:15cb23455b3cb846261b535dcbbf73ea36e3f089cf4b8b36623bf36b461b522d</span><br></pre></td></tr></table></figure>
<p><img data-src="image-20220505133657174.png" /></p>
<p>如果有类似的回显说明已经加入成功了。</p>
<p>如果忘记master节点的token可以在master节点上执行命令重新创建一个token</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo kubeadm token create --print-join-command</span><br></pre></td></tr></table></figure>
<h3 id="集群启动成功">集群启动成功</h3>
<p><img data-src="image-20220505141228217.png" /></p>
<h3 id="kubernetes排错">Kubernetes排错</h3>
<h4
id="wait-control-plane-waiting-for-the-kubelet-to-boot-up-the-control-plane-as-static-pods-from-directory-etckubernetesmanifests.-this-can-take-up-to-4m0s">[wait-control-plane]
Waiting for the kubelet to boot up the control plane as static Pods from
directory “/etc/kubernetes/manifests”. This can take up to 4m0s</h4>
<p>查看kubelet日志</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">journalctl -xeu kubelet</span><br></pre></td></tr></table></figure>
<p>出现频率较高的就是<strong>sandbox</strong>，应该和这个镜像有关</p>
<p><img data-src="image-20220505094125196.png" /></p>
<p>查看<code>containerd</code>默认配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/containerd/config.toml</span><br></pre></td></tr></table></figure>
<p><img data-src="image-20220505094253375.png" /></p>
<p>发现默认配置是<code>k8s.gcr.io</code>域的镜像，国内拉取不到。</p>
<p>上文中已经拉取了阿里云的镜像，执行以下命令可以查看镜像的拉取地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">crictl images</span><br></pre></td></tr></table></figure>
<p>如果报错应该是权限问题，<strong>即<code>containerd</code>
的创建的unix
socket文件权限是root</strong>，可以试试加上<code>sudo</code></p>
<p><img data-src="image-20220505094820005.png" /></p>
<h5 id="解决方案">解决方案</h5>
<p>将<code>k8s.gcr.io/pause</code>镜像更改为本地拉取的阿里云镜像即可。</p>
<h4
id="加入节点时提示getting-status-of-runtime-rpc-error-code-unimplemented-desc-unknown-service-runtime.v1alpha2.runtimeservice">加入节点时，提示"getting
status of runtime: rpc error: code = Unimplemented desc = unknown
service runtime.v1alpha2.RuntimeService"</h4>
<h5 id="解决方案-1">解决方案</h5>
<p>检查<code>/etc/containerd/config.toml</code>文件，将SystemdCgroup设置为true</p>
<p><img data-src="image-20220505140624811.png" /></p>
<p>重启containerd服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart containerd</span><br></pre></td></tr></table></figure>
<h4
id="failed-to-set-bridge-addr-cni0-already-has-an-ip-address-different-from-10.244.1.124">failed
to set bridge addr: "cni0" already has an IP address different from
10.244.1.1/24</h4>
<p>在集群出现异常，需要重置集群的时候可能会出现此问题。如果是第一次安装则不会，因为此时是集群第一次安装cni网络组件，不会出现地址冲突的问题。</p>
<h5 id="解决方案-2">解决方案</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ifconfig cni0 down    </span><br><span class="line">ip <span class="built_in">link</span> delete cni0</span><br></pre></td></tr></table></figure>
<h4
id="fata0000-failed-to-create-shim-task-oci-runtime-create-failed-runc-create-failed-unable-to-start-container-process-error-during-container-init-error-running-hook-0-error-running-hook-exit-status-1-stdout-stderr-time2022-05-24t022902z-levelfatal-msgfailed-to-call-cni.setup-plugin-typebridge-failed-add-incompatible-cni-versions-config-is-1.0.0-plugin-supports-0.1.0-0.2.0-0.3.0-0.3.1-0.4.0">FATA[0000]
failed to create shim task: OCI runtime create failed: runc create
failed: unable to start container process: error during container init:
error running hook #0: error running hook: exit status 1, stdout: ,
stderr: time="2022-05-24T02:29:02Z" level=fatal msg="failed to call
cni.Setup: plugin type="bridge" failed (add): incompatible CNI versions;
config is "1.0.0", plugin supports ["0.1.0" "0.2.0" "0.3.0" "0.3.1"
"0.4.0"]"</h4>
<p>未安装CNI组件导致容器运行失败</p>
<h5 id="解决方案-3">解决方案</h5>
<p>直接使用<code>nerdctl</code>打包好的containerd运行时和一系列插件即可，参考上文<strong>安装kubeadm——安装容器运行时——方法2</strong></p>
<h4
id="may-24-061748-aws-jp-4g-kubelet184529-e0524-061748.193006-184529-kubelet.go2419-error-getting-node-errnode-aws-jp-4g-not-found">May
24 06:17:48 aws-jp-4G kubelet[184529]: E0524 06:17:48.193006 184529
kubelet.go:2419] "Error getting node" err="node "aws-jp-4g" not
found"</h4>
<p>一般是因为API Server的IP没有绑定成功，导致无法访问到对应的API
Server端口，从而kubelet认为节点没有注册成功。</p>
<h5 id="解决方案-4">解决方案</h5>
<p>重新初始化集群，从新注册网络即可。</p>
<ul>
<li><p>https://github.com/flannel-io/flannel</p></li>
<li><p>https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/#pod-network</p></li>
<li><p>https://github.com/containerd/containerd/blob/main/docs/cri/registry.md</p></li>
</ul>
<h4 id="删除terminating的pod">删除Terminating的Pod</h4>
<p>在执行删除命令时应该使用一下两个flag</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl delete pod &lt;PODNAME&gt; --grace-period=0 --force --namespace &lt;NAMESPACE&gt;</span><br></pre></td></tr></table></figure>
<p>如果已经执行了删除命令而pod没有被立即删除，使用以下脚本删除Terminating的Pod</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get pods --all-namespaces | grep Terminating | <span class="keyword">while</span> <span class="built_in">read</span> line; <span class="keyword">do</span></span><br><span class="line">  pod_name=$(<span class="built_in">echo</span> <span class="variable">$line</span> | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span> ) \</span><br><span class="line">  name_space=$(<span class="built_in">echo</span> <span class="variable">$line</span> | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span> ); \</span><br><span class="line">  kubectl delete pods <span class="variable">$pod_name</span> -n <span class="variable">$name_space</span> --grace-period=0 --force</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>在Docker Destop启用k8s服务</title>
    <url>/p/enable-k8s-in-docker-desktop/</url>
    <content><![CDATA[<p>作为目前事实上的容器编排系统标准，K8s 无疑是现代应用的基石。</p>
<p>本文主要是开启Docker Desktop for Win/Mac 的K8s服务。</p>
<p>关键词：<strong>docker，k8s</strong></p>
<span id="more"></span>
<h3 id="确定k8s版本">确定k8s版本</h3>
<ul>
<li>需安装 Docker Desktop 的 Mac 或者 Windows 版本，如果没有请下载<a
href="https://store.docker.com/search?type=edition&amp;offering=community">下载
Docker CE最新版本</a></li>
<li>当前 master 分支已经在 Docker for Mac/Windows 4.4.2 (包含 Docker CE
20.10.12 和 Kubernetes 1.22.5) 版本测试通过</li>
<li>如果需要测试其他版本，请查看 Docker Desktop版本，Docker -&gt; About
Docker Desktop</li>
</ul>
<p><img data-src="image-20220429163406392.png" /></p>
<h3 id="切换到对应分支">切换到对应分支</h3>
<p>在任意目录下clone<a
href="https://github.com/AliyunContainerService/k8s-for-docker-desktop">k8s-for-docker-desktop</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/AliyunContainerService/k8s-for-docker-desktop.git</span><br></pre></td></tr></table></figure>
<p>这里的Kubernetes版本为 v1.22.5, 故使用 <a
href="https://github.com/AliyunContainerService/k8s-for-docker-desktop/tree/v1.22.5">v1.22.5
分支</a> <code>git checkout v1.22.5</code></p>
<h3 id="开启k8s">开启K8s</h3>
<p>为 Docker daemon 配置镜像加速，参考<a
href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors">阿里云镜像服务</a>
或中科大镜像加速地址<code>https://docker.mirrors.ustc.edu.cn</code></p>
<p><img data-src="image-20220429163857048.png" /></p>
<p>从阿里云镜像服务下载 Kubernetes 所需要的镜像</p>
<p>在 Mac 上执行如下脚本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./load_images.sh</span><br></pre></td></tr></table></figure>
<p>在Windows上，使用 PowerShell</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.\load_images.ps1</span><br></pre></td></tr></table></figure>
<p>说明:</p>
<ul>
<li>如果因为安全策略无法执行 PowerShell 脚本，请在 “以管理员身份运行” 的
PowerShell 中执行 <code>Set-ExecutionPolicy RemoteSigned</code>
命令。</li>
<li>如果需要，可以通过修改 <code>images.properties</code>
文件自行加载你自己需要的镜像</li>
</ul>
<p><img data-src="image-20220429164553018.png" /></p>
<p>开启 Kubernetes，并等待 Kubernetes 开始运行</p>
<p><img data-src="image-20220429164629527.png" /></p>
<p>当左下角出现k8s的图标时，说明开启成功</p>
<p><img data-src="image-20220429165336573.png" /></p>
<p>TIPS：</p>
<p>在Mac上:</p>
<p>如果在Kubernetes部署的过程中出现问题，可以通过docker
desktop应用日志获得实时日志信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pred=&#x27;process matches &quot;.*(ocker|vpnkit).*&quot;</span><br><span class="line">  || (process in &#123;&quot;taskgated-helper&quot;, &quot;launchservicesd&quot;, &quot;kernel&quot;&#125; &amp;&amp; eventMessage contains[c] &quot;docker&quot;)&#x27;</span><br><span class="line">/usr/bin/log stream --style syslog --level=debug --color=always --predicate &quot;$pred&quot;</span><br></pre></td></tr></table></figure>
<p>在Windows上:</p>
<p>如果在Kubernetes部署的过程中出现问题，可以在
<code>C:\ProgramData\DockerDesktop</code>下的service.txt 查看Docker日志,
在 <code>C:\Users\yourUserName\AppData\Local\Docker</code>下的log.txt
查看Kubernetes日志。</p>
<h3 id="配置k8s">配置K8s</h3>
<p>验证k8s集群状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl cluster-info</span><br><span class="line">kubectl get nodes</span><br></pre></td></tr></table></figure>
<p><img data-src="image-20220429170726815.png" /></p>
<p>配置K8s控制台</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create -f kubernetes-dashboard.yaml</span><br></pre></td></tr></table></figure>
<p><img data-src="image-20220429170904942.png" /></p>
<p>检查 kubernetes-dashboard 应用状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get pod -n kubernetes-dashboard</span><br></pre></td></tr></table></figure>
<p><img data-src="image-20220429171026647.png" /></p>
<p>开启API Server 访问代理</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl proxy</span><br></pre></td></tr></table></figure>
<p><img data-src="image-20220429171129620.png" /></p>
<p>通过如下URL访问kubernetes-dashboard</p>
<p>http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/</p>
<p>配置Mac环境</p>
<p>配置控制台访问令牌</p>
<p>对于Mac环境</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TOKEN=$(kubectl -n kube-system describe secret default| awk &#x27;$1==&quot;token:&quot;&#123;print $2&#125;&#x27;)</span><br><span class="line">kubectl config set-credentials docker-desktop --token=&quot;$&#123;TOKEN&#125;&quot;</span><br><span class="line">echo $TOKEN</span><br></pre></td></tr></table></figure>
<p>对于Windows环境</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$TOKEN=((kubectl -n kube-system describe secret default | Select-String &quot;token:&quot;) -split &quot; +&quot;)[1]</span><br><span class="line">kubectl config set-credentials docker-desktop --token=&quot;$&#123;TOKEN&#125;&quot;</span><br><span class="line">echo $TOKEN</span><br></pre></td></tr></table></figure>
<p><img data-src="image-20220429171807293.png" /></p>
<p>登录dashboard的时候选择令牌，输入上文控制台输出中的内容。</p>
<p>或者选择kubeconfig，路径如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Mac: <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">Win: %UserProfile%\.kube\config</span><br></pre></td></tr></table></figure>
<p>点击登陆，进入Kubernetes Dashboard</p>
]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>progit学习笔记</title>
    <url>/p/study-notebooks-for-pro-git/</url>
    <content><![CDATA[<p>本文是progit的学习记录。</p>
<p>关键词：<strong>git</strong></p>
<span id="more"></span>
<h2 id="介绍">介绍</h2>
<p>略。</p>
<h2 id="安装">安装</h2>
<p>略。</p>
<h2 id="初次运行git前的配置">初次运行Git前的配置</h2>
<p><code>git config</code>用来帮助设置控制Git的外观和行为的控制变量。这些变量存在三个不同位置：</p>
<ol type="1">
<li><code>/etc/gitconfig</code>：包含系统上每一个用户以及他们的仓库的通用配置。传递<code>--system</code>选项让Git读写此文件。</li>
<li><code>~/.gitconfig</code>或<code>~/.config/git/config</code>：只针对当前用户。传递<code>--global</code>选项让Git读写此文件。</li>
<li>当前使用仓库的Git目录的<code>.git/config</code>文件，只针对该仓库。</li>
</ol>
<p>每一个级别覆盖上一级别的配置。即当<code>.git/config</code>文件存在时，不读取其他文件，以此类推。</p>
<p>window中会查找
<code>$HOME</code>目录下（一般是<code>C:\\Users\\$USER</code>）的<code>.gitconfig</code>文件。Git同样会寻找
<code>/etc/gitconfig</code>文件，但是只限于安装Git时所选的目标位置。</p>
<h3 id="用户信息">用户信息</h3>
<p>设置用户名和邮件地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;wf09&quot;</span></span><br><span class="line">git config --global user.email wf.09@qq.com</span><br></pre></td></tr></table></figure>
<p>使用了<code>--global</code>选项则该命令只需要运行一次。</p>
<h3 id="文本编辑器">文本编辑器</h3>
<p>默认使用操作系统默认的文本编辑器，通常是Vim</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global core.editer vim</span><br></pre></td></tr></table></figure>
<h3 id="设置代理">设置代理</h3>
<p>这里的代理分为两种，一种是https/http</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 全局</span></span><br><span class="line">git config --global https.proxy socks5://127.0.0.1:7891</span><br><span class="line">git config --global https.proxy http://127.0.0.1:7890</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只对github进行代理</span></span><br><span class="line">git config --global https.https://github.com.proxy socks5://127.0.0.1:7891</span><br><span class="line">git config --global https.https://github.com.proxy socks5://127.0.0.1:7890</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取消</span></span><br><span class="line">git config --global --<span class="built_in">unset</span> https.proxy</span><br></pre></td></tr></table></figure>
<p>另外一种是ssh协议的代理</p>
<p>Linux/Unix环境下，在<code>~/.ssh/config</code>文件下加入如下行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Host github.com *.github.com</span><br><span class="line">    User git</span><br><span class="line">    Port 22</span><br><span class="line">    HostName %h</span><br><span class="line">    IdentityFile ~/.ssh/id_ed25519</span><br><span class="line">    ProxyCommand nc -x 127.0.0.1:7890 %h %p%</span><br></pre></td></tr></table></figure>
<p>其中<code>nc -x</code>后面跟的是socks5的代理地址</p>
<p>Windows环境下，在
<code>C:\User\$USER\.ssh\config</code>文件下加入如下行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Host github.com *.github.com *coding.net</span><br><span class="line">    User git</span><br><span class="line">    Port 22</span><br><span class="line">    HostName %h</span><br><span class="line">    IdentityFile /c/Users/wf09/.ssh/id_ed25519</span><br><span class="line">    ProxyCommand connect -S 127.0.0.1:10809 %h %p</span><br></pre></td></tr></table></figure>
<p>其中<code>connect -S</code>后面跟的是socks5的代理地址</p>
<h3 id="检查配置信息">检查配置信息</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --list</span><br><span class="line">core.excludesfile=~/.gitignore</span><br><span class="line">core.legacyheaders=<span class="literal">false</span></span><br><span class="line">core.quotepath=<span class="literal">false</span></span><br><span class="line">mergetool.keepbackup=<span class="literal">true</span></span><br><span class="line">push.default=simple</span><br><span class="line">color.ui=auto</span><br><span class="line">color.interactive=auto</span><br><span class="line">repack.usedeltabaseoffset=<span class="literal">true</span></span><br><span class="line">alias.s=status</span><br><span class="line">alias.a=!git add . &amp;&amp; git status</span><br><span class="line">alias.au=!git add -u . &amp;&amp; git status</span><br><span class="line">alias.aa=!git add . &amp;&amp; git add -u . &amp;&amp; git status</span><br><span class="line">alias.c=commit</span><br><span class="line">alias.cm=commit -m</span><br><span class="line">alias.ca=commit --amend</span><br><span class="line">alias.ac=!git add . &amp;&amp; git commit</span><br><span class="line">alias.acm=!git add . &amp;&amp; git commit -m</span><br><span class="line">alias.l=<span class="built_in">log</span> --graph --all --pretty=format:<span class="string">&#x27;%C(yellow)%h%C(cyan)%d%Creset %s %C(white)- %an, %ar%Creset&#x27;</span></span><br><span class="line">alias.ll=<span class="built_in">log</span> --<span class="built_in">stat</span> --abbrev-commit</span><br><span class="line">alias.lg=<span class="built_in">log</span> --color --graph --pretty=format:<span class="string">&#x27;%C(bold white)%h%Creset -%C(bold green)%d%Creset %s %C(bold green)(%cr)%Creset %C(bold blue)&lt;%an&gt;%Creset&#x27;</span> --abbrev-commit --<span class="built_in">date</span>=relative</span><br><span class="line">alias.llg=<span class="built_in">log</span> --color --graph --pretty=format:<span class="string">&#x27;%C(bold white)%H %d%Creset%n%s%n%+b%C(bold blue)%an &lt;%ae&gt;%Creset %C(bold green)%cr (%ci)&#x27;</span> --abbrev-commit</span><br><span class="line">alias.d=diff</span><br><span class="line">alias.master=checkout master</span><br><span class="line">alias.spull=svn rebase</span><br><span class="line">alias.spush=svn dcommit</span><br><span class="line">alias.alias=!git config --list | grep <span class="string">&#x27;alias\.&#x27;</span> | sed <span class="string">&#x27;s/alias\.\([^=]*\)=\(.*\)/\1\	 =&gt; \2/&#x27;</span> | <span class="built_in">sort</span></span><br><span class="line">include.path=~/.gitcinclude</span><br><span class="line">include.path=.githubconfig</span><br><span class="line">include.path=.gitcredential</span><br><span class="line">diff.exif.textconv=exif</span><br><span class="line">credential.helper=osxkeychain</span><br></pre></td></tr></table></figure>
<p>可能会看到重复的用户名，因为Git会在不同的文件中读取同一个配置（例如：<code>/etc/gitconfig</code>和<code>~/.gitconfig</code>。后一个配置会覆盖前一个配置。</p>
<p>可以用过<code>git config &lt;key&gt;</code>来检查Git的某一项配置。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config user.name</span><br></pre></td></tr></table></figure>
<h2 id="git基础">git基础</h2>
<h3 id="获取git仓库">获取Git仓库</h3>
<h4 id="初始化仓库">初始化仓库</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>
<h4 id="克隆现有仓库">克隆现有仓库</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/git/git.git</span><br><span class="line"><span class="comment"># 自定义本地仓库名</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/git/git.git git-repo</span><br></pre></td></tr></table></figure>
<h3 id="记录每次更新到仓库">记录每次更新到仓库</h3>
<p>请注意，工作目录下的每一个文件不外乎两种状态：<strong>已跟踪或未跟踪</strong>。其中<strong>已跟踪的文件</strong>是指那些被纳入了版本控制的文件，在<strong>上一次快照</strong>中有他们的记录。他们的状态可能处于<strong>未修改，已修改或已放入暂存区</strong>。工作目录中除了已跟踪文件目录以外的其他所有文件都属于<strong>未跟踪文件</strong>，他们既不存在于上次快照的记录中，也没有放入暂存区。初次克隆某个仓库时，工作目录中的文件都属于已跟踪文件，并且处于未修改状态。</p>
<p>编辑过某些文件后，由于自上次提交后你对他们做了修改，Git将他们标记为已修改文件。将这些修改过的文件放入暂存区，然后提交所有暂存了的修改，如此反复，所以使用GIT时文件的生命周期如下：<img data-src="lifecycle.png" /></p>
<h4 id="检查当前文件状态">检查当前文件状态</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch main</span><br><span class="line">Your branch is up to <span class="built_in">date</span> with <span class="string">&#x27;origin/main&#x27;</span>.</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to include <span class="keyword">in</span> what will be committed)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">source</span>/_posts/progit学习笔记.md</span><br><span class="line">        <span class="built_in">source</span>/_posts/progit学习笔记/</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use <span class="string">&quot;git add&quot;</span> to track)</span><br></pre></td></tr></table></figure>
<p>在状态报告中可以看到新建的<code>progit学习笔记.md文件</code>和<code>progit学习笔记/</code>出现在<code>Untracked files</code>下面。未跟踪的文件意味着Git在之前的快照（提交）中没有这些文件；Git不会自动将其纳入跟踪范围，除非你明明白白的告诉他需要跟踪该文件。</p>
<h4 id="跟踪新文件">跟踪新文件</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add <span class="built_in">source</span>/_posts/progit学习笔记.md</span><br></pre></td></tr></table></figure>
<p>此时在运行<code>git status</code>命令，会看到上面的文件<strong>已被跟踪</strong>，并处于<strong>暂存</strong>的状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch main</span><br><span class="line">Your branch is up to <span class="built_in">date</span> with <span class="string">&#x27;origin/main&#x27;</span>.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git reset HEAD &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line"></span><br><span class="line">        new file:   <span class="built_in">source</span>/_posts/progit学习笔记.md</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git checkout -- &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">        modified:   <span class="built_in">source</span>/_posts/progit学习笔记.md</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to include <span class="keyword">in</span> what will be committed)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">source</span>/_posts/progit学习笔记/</span><br></pre></td></tr></table></figure>
<p>只要在<code>Changes to be committed</code>这一行下面的，说明是已暂存的状态，如果此时提交，那么该文件此时的版本将会被留在历史记录中。</p>
<p><code>git add</code>命令使用文件或者目录的路径作为参数，如果是目录的参数，该命令递归的跟踪该目录下的所有文件。</p>
<h4 id="暂存已修改文件">暂存已修改文件</h4>
<p>修改一个已经被跟踪的文件，然后运行命令，就会看到上面所示的内容：</p>
<p>文件<code>source/_posts/progit学习笔记.md</code>同时出现在出现在暂存区和非暂存区。此时Git只暂存了你运行的<code>git add</code>命令似的版本，如果现在提交，<code>source/_posts/progit学习笔记.md</code>版本是最后一次运行<code>git add</code>命令似的版本，而不是执行<code>git commit</code>时工作目录的版本。需要继续运行<code>git add</code>把最新版本重新暂存起来：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$git</span> add .</span><br></pre></td></tr></table></figure>
<p><code>git add .</code>表示将所有修改过的文件移动到暂存区。</p>
<p><code>git add</code>是一个多功能命令：</p>
<ul>
<li>可以开始跟踪新文件</li>
<li>可以把已跟踪的文件放到暂存区</li>
<li>合并时把有冲突的文件修改为已解决状态等。</li>
</ul>
<p>应该将<code>git add</code>命令应理解为<strong>添加内容到下一次提交中</strong>而不是<strong>将一个文件添加到项目中</strong>。</p>
<h4 id="状态简览">状态简览</h4>
<p><code>git status</code>命令的输出十分详细。使用<code>git status -s</code>命令或者<code>git status --short</code>命令将得到一种更为紧凑的格式输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$git</span> status -s</span><br><span class="line">AM <span class="built_in">source</span>/_posts/progit学习笔记.md</span><br><span class="line">A  <span class="built_in">source</span>/_posts/progit学习笔记/lifecycle.png</span><br></pre></td></tr></table></figure>
<p>未被跟踪的文件有<code>??</code>标记，新添加到暂存区中文件有<code>A</code>标记，修改过的文件有<code>M</code>标记。</p>
<p>出现靠左边的M表示该文件被修改了并放入到了暂存区；出现在靠右边的M表示该文件被修改了但是还没放到ss暂存区。</p>
<blockquote>
<p>和我实际操作的不一致。貌似版本原因。如果一个文件在工作区中被修改并提交到暂存区后又在工作区中被修改，文件前面的标记应该是AM，而不是上文中的MM。</p>
</blockquote>
<h4 id="忽略文件">忽略文件</h4>
<p>创建一个<code>.gitignore</code>的文件，列出要忽略的文件模式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> .gitignore</span><br><span class="line">*.[oa]</span><br><span class="line">*~</span><br></pre></td></tr></table></figure>
<p>第一行告诉Git忽略所有<code>.o</code>或者<code>.a</code>结尾的文件。一般这类对象文件和存档文件都是编译过程中出现的。</p>
<p>第二行告诉Git忽略所有以波浪符号<code>~</code>为结尾的文件。通常这是用来保存文件副本的。</p>
<p>此外可能还需要需要忽略log，tmp或者pid目录，以及自动生成的文档等。</p>
<p><code>.gitignore</code>的格式规范如下：</p>
<ul>
<li>所有空行或以<code>#</code>开头的行都会被git忽略；</li>
<li>可以是由标准的<code>glob</code>模式进行匹配；</li>
<li>匹配模式可以以<code>/</code>开头防止递归；</li>
<li>匹配模式可以以<code>/</code>结尾制定目录</li>
<li>要忽略制定模式意外的文件或目录，可以在模式前面加上
感叹号(!)并取反。</li>
</ul>
<blockquote>
<p>glob模式是shell所使用的简化的正则表达式：</p>
<ul>
<li>星号（*）匹配零个或者多个任意字符；</li>
<li>[abc]匹配任意一个在方括号中的字符，这个例子要么匹配一个a，要么匹配一个b，要么匹配一个c；</li>
<li>问号（?）只匹配一个任意字符；</li>
<li>如果在方括号内使用短划线分割两个字符，表示所有在这两个字符范围内的都可以匹配（比如[0-9]匹配所有0到的数字）；</li>
<li>使用两个星号（*）表示匹配任意中间目录，如<code>a/**z</code>可以匹配<code>a/z,a/b/z,a/b/c/z</code>等</li>
</ul>
</blockquote>
<p>一个<code>.gitignore</code>文件的例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># no .a files</span></span><br><span class="line">*.a</span><br><span class="line"></span><br><span class="line"><span class="comment"># but do track lib.a, even though you&#x27;re ignoring .a files above</span></span><br><span class="line">!lib.a</span><br><span class="line"></span><br><span class="line"><span class="comment"># only ignore the TODO file in the current directory, not subdir/TODO</span></span><br><span class="line">/TODO</span><br><span class="line"></span><br><span class="line"><span class="comment"># ignore all files in the build/ directory</span></span><br><span class="line">build/</span><br><span class="line"></span><br><span class="line"><span class="comment"># ignore doc/notes.txt, but not doc/server/arch.txt</span></span><br><span class="line">doc/*.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># ignore all .pdf files in the doc/ directory</span></span><br><span class="line">doc/**/*.pdf</span><br></pre></td></tr></table></figure>
<h4 id="查看已暂存和未暂存的修改">查看已暂存和未暂存的修改</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>
<p><img data-src="image-20220504184931180.png" /></p>
<p>要查看尚未暂存的文件更新了那些部分，直接输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure>
<p><img data-src="image-20220504185045124.png" /></p>
<p>此命令用来比较工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容。</p>
<p>若要查看已暂存的将要添加到下次提交里的内容，可以用如下命令，该条命令将比对已暂存的和最后一次提交的文件差异：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git diff --staged</span><br></pre></td></tr></table></figure>
<p><code>git diff</code>本身<strong>只显示尚未暂存的改动</strong>，而不是自上次提交以来所做的所有改动。</p>
<h4 id="提交更新">提交更新</h4>
<p>交互方式提交更新</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit </span><br></pre></td></tr></table></figure></p>
<p><img data-src="image-20220504190419351.png" /></p>
<p>将提交信息和命令放在同一行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;update progit学习笔记&quot;</span></span><br></pre></td></tr></table></figure>
<p><img data-src="image-20220504190442634.png" /></p>
<p>可以看到，当前是在那个分支（main）提交的，本次提交的完整的SHA-1校验和<code>5f66f52</code>
，有三个文件修订过，有35行添加并且有一行删改。</p>
<p>提交时记录的<strong>是放在暂存区的快照</strong>，任何还未暂存的文件仍然保持已修改状态，可以在下次提交的时候纳入版本管理。</p>
<p>每提交一次，都是对项目做一次快照，以后可以<strong>回到这个状态</strong>，或者进行<strong>比较</strong></p>
<h4 id="跳过使用暂存区">跳过使用暂存区</h4>
<p>自动把已经跟踪过的文件暂存起来一并提交</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;update message&quot;</span> -a</span><br></pre></td></tr></table></figure>
<h4 id="移除文件">移除文件</h4>
<p>从暂存区移除，并<strong>连带从工作目录中删除</strong>指定的文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">rm</span> file</span><br></pre></td></tr></table></figure>
<p>从暂存区移除，<strong>但仍保留在当前目录</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">rm</span> --cached file</span><br></pre></td></tr></table></figure>
<p><code>git rm</code>命令后面可以列出文件或者目录的名字，也可以使用glob模式。注意<code>*</code>号后面的反斜杠<code>\</code>.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">rm</span> <span class="built_in">log</span>/\*<span class="built_in">log</span></span><br></pre></td></tr></table></figure>
<p>以上命令将删除<code>log/</code>
目录下所有拓展名为<code>.log</code>的所有文件。</p>
<h4 id="移动文件">移动文件</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">mv</span> file_from file_to</span><br></pre></td></tr></table></figure>
<p>相当于运行了以下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> file_from file_to</span><br><span class="line">git <span class="built_in">rm</span> README.md</span><br><span class="line">git add README</span><br></pre></td></tr></table></figure>
<h3 id="查看提交历史">查看提交历史</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure>
<p><img data-src="image-20220504192609395.png" /></p>
<ul>
<li>在不传任何参数的默认情况下，
<code>git log</code>会按照时间先后顺序列出所有的提交，最近的更新排在最上面。</li>
</ul>
<h4
id="按补丁的格式显示最近1次提交引入的差异">按补丁的格式显示<strong>最近1次</strong>提交引入的差异</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> -p -1</span><br></pre></td></tr></table></figure>
<p><img data-src="image-20220504193112496.png" /></p>
<h4 id="查看每次提交的简略统计信息">查看每次提交的简略统计信息</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --<span class="built_in">stat</span></span><br></pre></td></tr></table></figure>
<p><img data-src="image-20220504193301800.png" /></p>
<ul>
<li><code>--stats</code>选项在每次提交的下面列出了所有被修改过的文件、有多少文件被修改了一集被修改文件的那些行被移除了或者添加了。</li>
</ul>
<h4 id="将commit消息显示为一行">将commit消息显示为一行</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --pretty=oneline</span><br></pre></td></tr></table></figure>
<p><img data-src="image-20220504193659106.png" /></p>
<p>也可以只显示sha1校验和的前几位</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --oneline</span><br></pre></td></tr></table></figure>
<p><img data-src="image-20220504193756345.png" /></p>
<h4 id="定制格式显示提交历史">定制格式显示提交历史</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --pretty=format:<span class="string">&quot;%h - %an, %ar : %s&quot;</span></span><br></pre></td></tr></table></figure>
<p><img data-src="image-20220504194214332.png" /></p>
<p>以下是<code>--pretty</code>的常用选项</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">选项</th>
<th style="text-align: left;">说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>%H</code></td>
<td style="text-align: left;">提交对象（commit）的完整哈希字串</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>%h</code></td>
<td style="text-align: left;">提交对象的简短哈希字串</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>%T</code></td>
<td style="text-align: left;">树对象（tree）的完整哈希字串</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>%t</code></td>
<td style="text-align: left;">树对象的简短哈希字串</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>%P</code></td>
<td style="text-align: left;">父对象（parent）的完整哈希字串</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>%p</code></td>
<td style="text-align: left;">父对象的简短哈希字串</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>%an</code></td>
<td style="text-align: left;">作者（author）的名字</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>%ae</code></td>
<td style="text-align: left;">作者的电子邮件地址</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>%ad</code></td>
<td style="text-align: left;">作者修订日期（可以用 --date=
选项定制格式）</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>%ar</code></td>
<td style="text-align: left;">作者修订日期，按多久以前的方式显示</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>%cn</code></td>
<td style="text-align: left;">提交者（committer）的名字</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>%ce</code></td>
<td style="text-align: left;">提交者的电子邮件地址</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>%cd</code></td>
<td style="text-align: left;">提交日期</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>%cr</code></td>
<td style="text-align: left;">提交日期，按多久以前的方式显示</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>%s</code></td>
<td style="text-align: left;">提交说明</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>作者</strong>是实际作出修改的人，<strong>提交者</strong>指的是最后将此工作成果提交到仓库的人</li>
</ul>
<p><code>online</code>或<code>format</code>与另一个选项<code>--graph</code>结合使用，可以清晰的展示你的分支、合并历史</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --pretty=format:<span class="string">&quot;%h %s&quot;</span> --graph</span><br></pre></td></tr></table></figure>
<p><img data-src="image-20220504195321176.png" /></p>
<p>以下是<code>git log</code>的常用选项</p>
<table>
<colgroup>
<col style="width: 22%" />
<col style="width: 77%" />
</colgroup>
<thead>
<tr class="header">
<th><code>-p</code></th>
<th>按补丁格式显示每个更新之间的差异。</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>--stat</code></td>
<td>显示每次更新的文件修改统计信息。</td>
</tr>
<tr class="even">
<td><code>--shortstat</code></td>
<td>只显示 --stat 中最后的行数修改添加移除统计。</td>
</tr>
<tr class="odd">
<td><code>--name-only</code></td>
<td>仅在提交信息后显示已修改的文件清单。</td>
</tr>
<tr class="even">
<td><code>--name-status</code></td>
<td>显示新增、修改、删除的文件清单。</td>
</tr>
<tr class="odd">
<td><code>--abbrev-commit</code></td>
<td>仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。</td>
</tr>
<tr class="even">
<td><code>--relative-date</code></td>
<td>使用较短的相对时间显示（比如，“2 weeks ago”）。</td>
</tr>
<tr class="odd">
<td><code>--graph</code></td>
<td>显示 ASCII 图形表示的分支合并历史。</td>
</tr>
<tr class="even">
<td><code>--pretty</code></td>
<td>使用其他格式显示历史提交信息。可用的选项包括
oneline，short，full，fuller 和 format（后跟指定格式）。</td>
</tr>
</tbody>
</table>
<h4 id="限制输出长度">限制输出长度</h4>
<p><code>-&lt;n&gt;</code> 选项的写法，其中的 <code>n</code>
可以是任何整数，表示仅显示最近的若干条提交。</p>
<h4 id="限制输出时间">限制输出时间</h4>
<p>列出所有<strong>最近两周内的</strong>提交</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --since=2.weeks</span><br></pre></td></tr></table></figure>
<p>列出5天之前的提交</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --<span class="keyword">until</span> 5.days</span><br></pre></td></tr></table></figure></p>
<p>时间可以是<strong>具体的某一天
<code>"2008-01-15"</code></strong>，也可以是<strong>相对时间</strong>
<code>"2 years 1 day 3 minutes ago"</code>。</p>
<h4 id="筛选commit作者">筛选commit作者</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --author wf09</span><br></pre></td></tr></table></figure>
<h4 id="筛选commit关键字">筛选commit关键字</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --grep update</span><br></pre></td></tr></table></figure>
<h4
id="筛选添加或移除了某些字符串的提交">筛选添加或移除了某些字符串的提交</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> -Supdate</span><br></pre></td></tr></table></figure>
<h4 id="筛选某些文件和目录的历史提交">筛选某些文件和目录的历史提交</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> &lt;file_name&gt;</span><br></pre></td></tr></table></figure>
<p>以下是限制<code>git log</code>输出的选项</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">选项</th>
<th style="text-align: left;">说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>-(n)</code></td>
<td style="text-align: left;">仅显示最近的 n 条提交</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>--since</code>,
<code>--after</code></td>
<td style="text-align: left;">仅显示指定时间之后的提交。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>--until</code>,
<code>--before</code></td>
<td style="text-align: left;">仅显示指定时间之前的提交。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>--author</code></td>
<td style="text-align: left;">仅显示指定作者相关的提交。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>--committer</code></td>
<td style="text-align: left;">仅显示指定提交者相关的提交。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>--grep</code></td>
<td style="text-align: left;">仅显示含指定关键字的提交</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>-S</code></td>
<td style="text-align: left;">仅显示添加或移除了某个关键字的提交</td>
</tr>
</tbody>
</table>
<h3 id="撤销操作">撤销操作</h3>
<p>提交后发现忘记了暂存某些需要的修改，可以像下面这样操作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;commit message&quot;</span></span><br><span class="line">git add forgotten_file</span><br><span class="line">git commit --amend</span><br></pre></td></tr></table></figure>
<p>最终会只有一个提交，第二次提交的结果会代替第一次提交的结果。</p>
<h4 id="取消暂存的文件">取消暂存的文件</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset HEAD [filename]</span><br></pre></td></tr></table></figure>
<p>忽略文件名就是取消所有暂存的文件</p>
<p><img data-src="image-20220504204117234.png" /></p>
<ul>
<li>不加选项的执行<code>git reset</code><strong>只会修改暂存区域</strong></li>
<li><code>--hard</code>选项<strong>会丢失工作区</strong>的更改！</li>
</ul>
<h4 id="撤销对文件的更改">撤销对文件的更改</h4>
<p>还原到上次提交的状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -- [filename]</span><br></pre></td></tr></table></figure>
<p>注意：<code>git checkout --</code>会<strong>完全撤销对当前文件的更改</strong>，和
<code>git reset --hard</code>选项类似</p>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>WebRTC学习笔记(一)|基于开源WebRTC，从0到1实现实时音视频聊天功能</title>
    <url>/p/WebRTC-study-notes-01/</url>
    <content><![CDATA[<p>实习公司一直开展的项目突然停滞了，因为一个老板的需求我们一直无法满足：</p>
<ul>
<li>老板想用现有的WebRTC技术，我们使用了现有的技术，但是效果不够好；</li>
<li>使用别的公司的技术但是收费又太贵了，初创公司没有那么多钱；</li>
<li>初创公司没有技术leader，第一批员工大部分都是实习员工；</li>
</ul>
<p>别问我为啥不跑路，说多了都是泪。</p>
<p>借着这个机会，好好学习一下webRTC技术，同时学会怎么阅读golang库的源码。</p>
<span id="more"></span>
<h2
id="零基础入门基于开源webrtc从0到1实现实时音视频聊天功能">零基础入门：<strong>基于开源WebRTC，从0到1实现实时音视频聊天功能</strong></h2>
<h3 id="知识准备">知识准备</h3>
<h4 id="音视频理论基础">音视频理论基础</h4>
<h4 id="什么是webrtc">什么是WebRTC</h4>
<h4 id="webrtc学习资源">WebRTC学习资源</h4>
<h3 id="技术组成">技术组成</h3>
<p>简单来说，WebRTC 是一个可以在 Web
应用程序中实现音频，视频和数据的实时通信的开源项目。在实时通信中，音视频的采集和处理是一个很复杂的过程。比如音视频流的编解码、降噪和回声消除等，但是在
WebRTC
中，这一切都交由浏览器的底层封装来完成。我们可以直接拿到优化后的媒体流，然后将其输出到本地屏幕和扬声器，或者转发给其对等端。</p>
<figure>
<img data-src="WebRTC学习笔记(一)/webp.webp" alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<ul>
<li>WebAPI层：面向开发者提供标准API（javascirpt），前端应用通过这一层接入使用WebRTC能力。</li>
<li>C++ API层：面向浏览器开发者，使浏览器制造商能够轻松地实现Web
API方案。</li>
<li>音频引擎（VoiceEngine）：音频引擎是一系列音频多媒体处理的框架，包括从视频采集卡到网络传输端等整个解决方案。
<ul>
<li>iSAC/iLBC/Opus等编解码</li>
<li>NetEQ语音信号处理</li>
<li>回声消除和降噪</li>
</ul></li>
<li>视频引擎（VideoEngine）：
是一系列视频处理的整体框架，从摄像头采集视频、视频信息网络传输到视频显示整个完整过程的解决方案。
<ul>
<li>VP8编解码</li>
<li>jitter buffer：动态抖动缓冲</li>
<li>Image enhancements：图像增益</li>
</ul></li>
<li>传输（Transport)：传输 / 会话层，会话协商 + NAT穿透组件
<ul>
<li>RTP 实时协议</li>
<li>P2P传输 STUN+TRUN+ICE实现的网络穿越</li>
</ul></li>
</ul>
<p>虽然浏览器给我们解决了大部分音视频处理问题，但是从浏览器请求音频和视频时，我们还是需要特别注意流的大小和质量。因为即便硬件能够捕获高清质量流，CPU
和带宽也不一定可以跟上，这也是我们在建立多个对等连接时，不得不考虑的问题。</p>
<h3 id="webrtc的p2p通信原理">WebRTC的P2P通信原理</h3>
<h4 id="技术难点">技术难点</h4>
<p>P2P即点对点通信。</p>
<p>要实现两个不同的网络环境（具有麦克风、摄像头设备）的客户端（可能是不同的Web浏览器或者手机APP）之间的音视频通信的问题：</p>
<ol type="1">
<li>怎么知道彼此的存在也就是如何发现对方？</li>
<li>彼此音视频编码能力如何沟通？</li>
<li>音视频数据如何传输，怎么让对方看得到自己？</li>
</ol>
<h4 id="怎么知道彼此的存在">怎么知道彼此的存在</h4>
<p>WebRTC虽然支持端对端通信，但是这不意味着WebRTC不再需要服务器。</p>
<p>P2P通信过程中，双方需要交换一些元数据如媒体信息、网络数据等信息，通常把这一过程叫做信令（signaling）。</p>
<p>对应的服务器既为信令服务器，也被称为房间服务器。因为它不仅可以交换彼此的媒体信息和网络信息，也可以管理网络信息。</p>
<p>如：</p>
<ol type="1">
<li>通知彼此who加入了房间</li>
<li>who离开了房间</li>
<li>告诉第三方房间人数是否已满可以加入房间。</li>
</ol>
<p>为了避免出现冗余，并最大限度提高与已有技术的兼容性，WebTRTC并没有规定信令和协议。在本文后面的实践章节会基于Node.js实现一个信令服务器。</p>
<h4 id="彼此音视频编码能力如何沟通">彼此音视频编码能力如何沟通</h4>
<p>不同浏览器对于音视频的编解码能力是不同的。为了保证双方都可以正确的编解码，最简单的方法就是使用<strong>客户端支持编码方式的交集</strong>。</p>
<p>在WebRTC中有一个专门的协议，<strong>Session Description
Protocol（SDP）</strong>，可以用于描述上述这类信息。</p>
<p>参与音视频通讯的双方想要了解对方支持的媒体格式，必须交换SDP信息，而交换SDP的过程，通常被称为媒体协商。</p>
<h4
id="音视频数据如何传输怎么能让对方看见自己">音视频数据如何传输，怎么能让对方看见自己</h4>
<p>其问题的本质是网络协商的过程，即参与音视频实时通信的双方要了解彼此之间的网络状况，这样才能找到一条互相通讯的链路。</p>
<p>理想的网络情况是每个浏览器都有自己的公网IP地址，这样的话就可以直接进行点对点连接。</p>
<p>然而大部分情况是我们的设备基本上都是处于某个局域网内，需要<strong>Network
Address
Translation（NAT），网络地址转换</strong>才能和外部的ip地址通信。</p>
<p>什么是ICE？</p>
<p><strong>Interactive Connectivity
Establishment（ICE），交互式连接建立</strong>。ICE不是一种协议，而是整合了STUN和TURN两种协议的框架。</p>
<p>其中：<strong>STUN（Session Traversal Utilities for
NAT，NAT会话穿越应用程序）</strong>，它允许位于NAT或多重NAT后的客户端找出自己对应的公网IP地址和端口，也就是俗称的P2P打洞。</p>
<p>但是，如果NAT类型对称型的话，那么就无法打动成功。这是TURN就派上用场了。<strong>TURN（Traversal
Using Replays around
NAT）</strong>是STUN/RFC5389的一个扩展协议在其基础上添加了Replay（中继）功能。</p>
<p>简单说，其目的就是解决对称型NAT无法穿越的问题，在STUN分配公网失败以后，可以通过TURN服务器请求公网IP地址作为中继地址。</p>
<p>在WebRCT中有三种类型的ICE候选者，分别是：</p>
<ul>
<li>主机候选者：表示的是本地局域网内的IP地址和端口，他是三个候选者中优先级最高的，也就是WebRTC底层首先会尝试本地局域网建立连接。</li>
<li>反射候选者：表示的是获取NAT内主机的外网IP地址和端口，其优先级低于主机候选者。也就是说当WebRTC尝试本地连接不通时，会尝试通过反射候选者获得的IP地址和端口进行连接；</li>
<li>中级候选者：表示的是中继服务器的IP地址和端，即通过服务器中转媒体数据，当WebRTC客户端通信双方无法穿越P2P时，为了保证双方可以通讯，此时只能通过服务器中转来保证服务质量。</li>
</ul>
<p><img data-src="WebRTC学习笔记(一)/110413q4zdfkzfemkmmfhk.png" /></p>
<p>从上图可以看出：在非本地局域网内WebRTC通过STUN
Server获得自己的外网IP和端口，然后通过信令服务器与远端的WebRTC交换网络信息，之后双方就可以尝试建立P2P连接了。当NAT穿越不成功时，则会通过Relay
Server（TURN）中转。</p>
<p>值得一提的是：在WebRTC中网络信息通常用candidate来描述，而上图中的STUN
server和Replay
server也可以同一个server。本文使用继承了STUN（打洞）和TURN（中继）的开源项目coturn。</p>
<p>综上对三个问题的解释，我们可以用下图来说明WebRTC实现点对点的通信的基本原理。</p>
<p><img data-src="WebRTC学习笔记(一)/110424jt8q1v49mqki3128.png" /></p>
<p>简而言之：就是通过WebRTC提供的API获取各段的媒体信息SDP以及网络信息candidate，并通过信令服务器交换，进而建立了两端的连接通道完成实时视频语音通话。</p>
<h3 id="webrtc几个重要api">WebRTC几个重要API</h3>
<h4 id="音视频采集api">音视频采集API</h4>
<p>音视频采集 API，即 MediaDevices.<a
href="https://developer.mozilla.org/zh-CN/docs/Web/API/MediaDevices/getDisplayMedia">getUserMedia()</a>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> constraints = &#123;</span><br><span class="line">        <span class="attr">video</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">audio</span>: <span class="literal">true</span></span><br><span class="line">     </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//   非安全模式（非https/localhost）下 navigator.mediaDevices 会返回 undefined</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> stream = <span class="keyword">await</span> navigator.<span class="property">mediaDevices</span>.<span class="title function_">getUserMedia</span>(constraints);</span><br><span class="line">        <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;video&#x27;</span>).<span class="property">srcObject</span> = stream;</span><br><span class="line">    &#125;   <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(error);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="获取音视频设备输入输出列表">获取音视频设备输入输出列表</h4>
<p>获取音视频设备输入输出列表API，即 MediaDevices.<a
href="https://developer.mozilla.org/zh-CN/docs/Web/API/MediaDevices/enumerateDevices">enumerateDevices()</a>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> devices = <span class="keyword">await</span> navigator.<span class="property">mediaDevices</span>.<span class="title function_">enumerateDevices</span>();</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">videoinputs</span> = devices.<span class="title function_">filter</span>(<span class="function"><span class="params">device</span> =&gt;</span> device.<span class="property">kind</span> === <span class="string">&#x27;videoinput&#x27;</span>);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">audiooutputs</span> = devices.<span class="title function_">filter</span>(<span class="function"><span class="params">device</span> =&gt;</span> device.<span class="property">kind</span> === <span class="string">&#x27;audiooutput&#x27;</span>);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">audioinputs</span> = devices.<span class="title function_">filter</span>(<span class="function"><span class="params">device</span> =&gt;</span> device.<span class="property">kind</span> === <span class="string">&#x27;audioinput&#x27;</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(error);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<h4 id="创建点对点连接">创建点对点连接</h4>
<p><a
href="https://developer.mozilla.org/zh-CN/docs/Web/API/RTCPeerConnection">RTCPeerConnection</a>
作为创建点对点连接的 API,是我们实现音视频实时通信的关键。</p>
<p>在本文的实践章节中，主要运用到了以下方法。</p>
<p><strong>媒体协商方法：</strong></p>
<ul>
<li><a
href="https://developer.mozilla.org/zh-CN/docs/Web/API/RTCPeerConnection/createOffer">createOffer</a></li>
<li><a
href="https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/createAnswer">createAnswer</a></li>
<li><a
href="https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/localDescription">localDesccription</a></li>
<li><a
href="https://developer.mozilla.org/zh-CN/docs/Web/API/RTCPeerConnection/remoteDescription">remoteDesccription</a></li>
</ul>
<p><strong>重要事件：</strong></p>
<ul>
<li><a
href="https://developer.mozilla.org/zh-CN/docs/Web/API/RTCPeerConnection/onicecandidate">onicecandidate</a></li>
<li><a
href="https://developer.mozilla.org/zh-CN/docs/Web/API/RTCPeerConnection/onaddstream">onaddstream</a></li>
</ul>
<p>P2P通信中一个最重要的环节就是交换媒体信息。</p>
<p>原理图：</p>
<p><img data-src="WebRTC学习笔记(一)/115037opmgs8r3s5c5zycp.png" /></p>
<p>从上图不难发现，整个媒体协过程也可以简化为三个步骤对应上述四个媒体协商方法。</p>
<ul>
<li>呼叫端Amy<strong>创建Offer（createOffer）</strong>并将offer消息（内容是呼叫段Amy的SDP信息）通过信令服务器传送给接收端Bob，同时调用<strong>setLocalDescription</strong>将含有本地SDP的Offer保存起来；</li>
<li>接收端Bob收到对端的Offer信息调用<strong>setRemoteDescription</strong>方法将含有对端SDP信息的Offer保存起来，并<strong>创建Answer（createAnswer）</strong>并将Answer消息（内容是接受端Bob的SDP消息）通过信令服务器传送给呼叫端Amy；</li>
<li>呼叫端Amy收到对端的Answer消息后调用<strong>setRemoteDescription</strong>方法将对端SDP信息的Answer保存起来。</li>
</ul>
<p>经过上述三个步骤，则完成了P2P通信过程中的媒体协商部分。</p>
<p>实际上：在呼叫端以及接收端调用<strong>setLocalDescription</strong>他同时也开始了收集各端自己的<strong>网络信息（candidate）</strong>，然后各端<strong>通过监听事件（onicecandidate）</strong>收集到了各自的<strong>candidate</strong>并通过信令服务器传输给对端，进而打通了P2P的网络通道，并通过<strong>监听onaddstream事件</strong>拿到了对方的视频流进而完成了整个视频通话过程。</p>
<h3 id="动手编码实践">动手编码实践</h3>
<p>代码操作的部分可以可参考下文中的原文链接</p>
<h2 id="参考">参考</h2>
<p>http://www.52im.net/thread-3680-1-1.html#2</p>
]]></content>
      <tags>
        <tag>WebRTC</tag>
      </tags>
  </entry>
  <entry>
    <title>kafaka学习笔记之快速入门</title>
    <url>/p/introduction-to-kafaka-study-notes-02/</url>
    <content><![CDATA[<p>业务需要，最近在看尚硅谷的教程，本着好记性不如烂笔头的原则，有了这一系列的文章。</p>
<p>关键词：<strong>kafaka</strong></p>
<span id="more"></span>
<h2 id="安装部署">安装部署</h2>
<h3 id="docker安装">docker安装</h3>
<p>这里使用docker的安装方式，这里贴出使用的镜像地址：https://hub.docker.com/r/bitnami/kafka/</p>
<p>docker安装方式十分简单，这里贴出使用的docker-compose.yml文件：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">zookeeper:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">&#x27;bitnami/zookeeper:latest&#x27;</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;2181:2181&#x27;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ALLOW_ANONYMOUS_LOGIN=yes</span></span><br><span class="line">  <span class="attr">kafka:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">&#x27;bitnami/kafka:latest&#x27;</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;9092:9092&#x27;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">KAFKA_BROKER_ID=1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">KAFKA_CFG_LISTENERS=PLAINTEXT://:9092</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">KAFKA_CFG_ADVERTISED_LISTENERS=PLAINTEXT://127.0.0.1:9092</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">KAFKA_CFG_ZOOKEEPER_CONNECT=zookeeper:2181/kafka</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ALLOW_PLAINTEXT_LISTENER=yes</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">zookeeper</span></span><br></pre></td></tr></table></figure>
<p>有几点需要注意：</p>
<ul>
<li><p><code>KAFKA_BROKER_ID</code>：设置<code>broker.id</code>，每一个broker必须设置不同的值，否则会启动失败；</p></li>
<li><p><code>KAFKA_CFG_LISTENERS</code>：设置kafka服务端监听的网络地址，这里是默认值0.0.0.0；</p></li>
<li><p><code>KAFKA_CFG_ADVERTISED_LISTENERS</code>：向外通告kafka实例的网络地址，一般使用宿主机的局域网地址或者公网地址；</p></li>
<li><p><code>KAFKA_CFG_ZOOKEEPER_CONNECT</code>：设置zookeeper的地址，这里最好是加上<code>/kafka</code>后缀，不然导致zookeeper的一级目录看起来混乱；</p></li>
</ul>
<h3 id="配置文件">配置文件</h3>
<p>可以通过环境变量快速设置几个关键选项，其他选项可以通过挂载配置文件进行修改：</p>
<ul>
<li>环境变量设置</li>
</ul>
<blockquote>
<p>The configuration can easily be setup with the Bitnami Apache Kafka
Docker image using the following environment variables:</p>
<ul>
<li><code>ALLOW_PLAINTEXT_LISTENER</code>: Allow to use the PLAINTEXT
listener. Default: <strong>no</strong>.</li>
<li><code>KAFKA_INTER_BROKER_USER</code>: Apache Kafka inter broker
communication user. Default: admin. Default: <strong>user</strong>.</li>
<li><code>KAFKA_INTER_BROKER_PASSWORD</code>: Apache Kafka inter broker
communication password. Default: <strong>bitnami</strong>.</li>
<li><code>KAFKA_CERTIFICATE_PASSWORD</code>: Password for certificates.
No defaults.</li>
<li><code>KAFKA_HEAP_OPTS</code>: Apache Kafka's Java Heap size.
Default: <strong>-Xmx1024m -Xms1024m</strong>.</li>
<li><code>KAFKA_ZOOKEEPER_PROTOCOL</code>: Authentication protocol for
Zookeeper connections. Allowed protocols: <strong>PLAINTEXT</strong>,
<strong>SASL</strong>, <strong>SSL</strong>, and
<strong>SASL_SSL</strong>. Defaults: <strong>PLAINTEXT</strong>.</li>
<li><code>KAFKA_ZOOKEEPER_USER</code>: Apache Kafka Zookeeper user for
SASL authentication. No defaults.</li>
<li><code>KAFKA_ZOOKEEPER_PASSWORD</code>: Apache Kafka Zookeeper user
password for SASL authentication. No defaults.</li>
<li><code>KAFKA_ZOOKEEPER_TLS_KEYSTORE_PASSWORD</code>: Apache Kafka
Zookeeper keystore file password and key password. No defaults.</li>
<li><code>KAFKA_ZOOKEEPER_TLS_TRUSTSTORE_PASSWORD</code>: Apache Kafka
Zookeeper truststore file password. No defaults.</li>
<li><code>KAFKA_ZOOKEEPER_TLS_VERIFY_HOSTNAME</code>: Verify Zookeeper
hostname on TLS certificates. Defaults: <strong>true</strong>.</li>
<li><code>KAFKA_ZOOKEEPER_TLS_TYPE</code>: Choose the TLS certificate
format to use. Allowed values: <code>JKS</code>, <code>PEM</code>.
Defaults: <strong>JKS</strong>.</li>
<li><code>KAFKA_CFG_SASL_ENABLED_MECHANISMS</code>: Allowed mechanism
when using SASL either for clients, inter broker, or zookeeper
comunications. Allowed values: <code>PLAIN</code>,
<code>SCRAM-SHA-256</code>, <code>SCRAM-SHA-512</code> or a comma
separated combination of those values. Default:
<strong>PLAIN,SCRAM-SHA-256,SCRAM-SHA-512</strong></li>
<li><code>KAFKA_CFG_SASL_MECHANISM_INTER_BROKER_PROTOCOL</code>: SASL
mechanism to use for inter broker communications. No defaults.</li>
<li><code>KAFKA_TLS_CLIENT_AUTH</code>: Configures kafka brokers to
request client authentication. Allowed values: <code>required</code>,
<code>requested</code>, <code>none</code>. Defaults:
<strong>required</strong>.</li>
<li><code>KAFKA_TLS_TYPE</code>: Choose the TLS certificate format to
use. Allowed values: <code>JKS</code>, <code>PEM</code>. Defaults:
<strong>JKS</strong>.</li>
<li><code>KAFKA_CLIENT_USERS</code>: Users that will be created into
Zookeeper when using SASL for client communications. Separated by
commas. Default: <strong>user</strong></li>
<li><code>KAFKA_CLIENT_PASSWORDS</code>: Passwords for the users
specified at<code>KAFKA_CLIENT_USERS</code>. Separated by commas.
Default: <strong>bitnami</strong></li>
<li><code>KAFKA_CFG_MAX_PARTITION_FETCH_BYTES</code>: The maximum amount
of data per-partition the server will return. Default: 1048576</li>
<li><code>KAFKA_CFG_MAX_REQUEST_SIZE</code>: The maximum size of a
request in bytes. Default: 1048576</li>
</ul>
<p>Additionally, any environment variable beginning with
<code>KAFKA_CFG_</code> will be mapped to its corresponding Apache Kafka
key. For example, use <code>KAFKA_CFG_BACKGROUND_THREADS</code> in order
to set <code>background.threads</code> or
<code>KAFKA_CFG_AUTO_CREATE_TOPICS_ENABLE</code> in order to configure
<code>auto.create.topics.enable</code>.</p>
</blockquote>
<ul>
<li>挂载配置文件</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">kafka:</span></span><br><span class="line">    <span class="string">...</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;kafka_data:/bitnami&#x27;</span></span><br><span class="line"><span class="string">+</span>     <span class="bullet">-</span> <span class="string">/path/to/server.properties:/bitnami/kafka/config/server.properties</span></span><br></pre></td></tr></table></figure>
<p>一些推荐配置</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment">#broker 的全局唯一编号，不能重复，只能是数字。 </span></span><br><span class="line"><span class="attr">broker.id</span>=<span class="number">0</span></span><br><span class="line"><span class="comment">#处理网络请求的线程数量</span></span><br><span class="line"><span class="attr">num.network.threads</span>=<span class="number">3</span></span><br><span class="line"><span class="comment">#用来处理磁盘 IO 的线程数量</span></span><br><span class="line"><span class="attr">num.io.threads</span>=<span class="number">8</span> <span class="comment">#发送套接字的缓冲区大小</span></span><br><span class="line"><span class="attr">socket.send.buffer.bytes</span>=<span class="number">102400</span></span><br><span class="line"><span class="comment">#接收套接字的缓冲区大小 </span></span><br><span class="line"><span class="attr">socket.receive.buffer.bytes</span>=<span class="number">102400</span></span><br><span class="line"><span class="comment">#请求套接字的缓冲区大小</span></span><br><span class="line"><span class="attr">socket.request.max.bytes</span>=<span class="number">104857600</span></span><br><span class="line"><span class="comment">#kafka 运行日志(数据)存放的路径，路径不需要提前创建，kafka 自动帮你创建，可以 配置多个磁盘路径，路径与路径之间可以用&quot;，&quot;分隔 </span></span><br><span class="line"><span class="attr">log.dirs</span>=/opt/module/kafka/datas</span><br><span class="line"><span class="comment">#topic 在当前 broker 上的分区个数</span></span><br><span class="line"><span class="attr">num.partitions</span>=<span class="number">1</span></span><br><span class="line"><span class="comment">#用来恢复和清理 data 下数据的线程数量 </span></span><br><span class="line"><span class="attr">num.recovery.threads.per.data.dir</span>=<span class="number">1</span></span><br><span class="line"><span class="comment"># 每个topic创建时的副本数，默认时1个副本 </span></span><br><span class="line"><span class="attr">offsets.topic.replication.factor</span>=<span class="number">1</span></span><br><span class="line"><span class="comment">#segment 文件保留的最长时间，超时将被删除</span></span><br><span class="line"><span class="attr">log.retention.hours</span>=<span class="number">168</span></span><br><span class="line"><span class="comment">#每个 segment 文件的大小，默认最大 1G </span></span><br><span class="line"><span class="attr">log.segment.bytes</span>=<span class="number">1073741824</span></span><br><span class="line"><span class="comment"># 检查过期数据的时间，默认5分钟检查一次是否数据过期 </span></span><br><span class="line"><span class="attr">log.retention.check.interval.ms</span>=<span class="number">300000</span></span><br><span class="line"><span class="comment">#配置连接 Zookeeper 集群地址(在 zk 根目录下创建/kafka，方便管理)</span></span><br><span class="line"><span class="attr">zookeeper.connect</span>=hadoop102:<span class="number">2181</span>,hadoop103:<span class="number">2181</span>,hadoop104:<span class="number">2181</span>/kafka</span><br></pre></td></tr></table></figure>
<h2 id="kafka命令行操作">kafka命令行操作</h2>
<p><img data-src="image-20220419214422212.png" /></p>
<h3 id="主题命令行参数">主题命令行参数</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bin/kafka-topics.sh</span><br></pre></td></tr></table></figure>
<table>
<colgroup>
<col style="width: 67%" />
<col style="width: 32%" />
</colgroup>
<thead>
<tr class="header">
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>--bootstrap-server &lt;String: server toconnect to&gt;</td>
<td>链接kafka broker主机名称</td>
</tr>
<tr class="even">
<td>--topic &lt;String: topic&gt;</td>
<td>操作的 topic 名称</td>
</tr>
<tr class="odd">
<td>--create</td>
<td>创建主题</td>
</tr>
<tr class="even">
<td>--alter</td>
<td>修改主题</td>
</tr>
<tr class="odd">
<td>--delete</td>
<td>删除主题</td>
</tr>
<tr class="even">
<td>--list</td>
<td>查看所有主题</td>
</tr>
<tr class="odd">
<td>--describe</td>
<td>查看主题详细描述</td>
</tr>
<tr class="even">
<td>--partitions &lt;Integer: # of partitions&gt;</td>
<td>设置分区数</td>
</tr>
<tr class="odd">
<td>--replication-factor&lt;Integer: replication factor&gt;</td>
<td>设置分区副本</td>
</tr>
<tr class="even">
<td>--config &lt;String: name=value&gt;</td>
<td>更新系统默认的配置</td>
</tr>
</tbody>
</table>
<h3 id="主题命令行相关操作">主题命令行相关操作</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看当前服务器所有topic</span></span><br><span class="line">bin/kafka-topics.sh --bootstrap-server hadoop102:9092 --list</span><br><span class="line"><span class="comment"># 指定topic名、定义副本数、分区数，创建topic</span></span><br><span class="line">bin/kafka-topics.sh --bootstrap-server hadoop102:9092 --create --partitions 1 --replication-factor 3 --topic first</span><br><span class="line"><span class="comment"># 查看first主题的详情</span></span><br><span class="line">bin/kafka-topics.sh --bootstrap-server hadoop102:9092 --describe --topic first</span><br><span class="line"><span class="comment"># 修改分区数（分区数只能增加不能减少）</span></span><br><span class="line">bin/kafka-topics.sh --bootstrap-server hadoop102:9092 --alter --topic first --partitions 3</span><br><span class="line"><span class="comment"># 删除主题（需要将server.properties 中设置 delete.topic.enable=true，否则只是标记删除）</span></span><br><span class="line">bin/kafka-topics.sh --bootstrap-server hadoop102:9092 --delete --topic first</span><br></pre></td></tr></table></figure>
<h2 id="生产者命令行操作">生产者命令行操作</h2>
<h3 id="生产者命令行参数">生产者命令行参数</h3>
<table>
<colgroup>
<col style="width: 57%" />
<col style="width: 42%" />
</colgroup>
<thead>
<tr class="header">
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>--bootstrap-server &lt;String: server toconnect to&gt;</td>
<td>连接的 Kafka Broker 主机名称和端口号</td>
</tr>
<tr class="even">
<td>--topic &lt;String: topic&gt;</td>
<td>操作的 topic 名称</td>
</tr>
</tbody>
</table>
<h3 id="发送消息">发送消息</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bin/kafka-console-producer.sh --bootstrap-server hadoop102:9092 --topic first</span><br></pre></td></tr></table></figure>
<h2 id="消费者命令行参操作">消费者命令行参操作</h2>
<h3 id="消费者命令行参数">消费者命令行参数</h3>
<table>
<colgroup>
<col style="width: 58%" />
<col style="width: 41%" />
</colgroup>
<thead>
<tr class="header">
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>--bootstrap-server &lt;String: server toconnect to&gt;</td>
<td>链接的kafka broker主机名和短端口号</td>
</tr>
<tr class="even">
<td>--topic</td>
<td>操作的topic名称</td>
</tr>
<tr class="odd">
<td>--from-beginning</td>
<td>从头开始消费</td>
</tr>
<tr class="even">
<td>--group &lt;String: consumer group id&gt;</td>
<td>指定消费者组名称</td>
</tr>
</tbody>
</table>
<h3 id="消费消息">消费消息</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bin/kafka-console-consumer.sh --bootstrap-server hadoop102:9092 --topic first</span><br><span class="line"><span class="comment"># 从主题的开始消费消息</span></span><br><span class="line">bin/kafka-console-consumer.sh --bootstrap-server hadoop102:9092 --from-beginning --topic first</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>kafaka学习笔记之绪论</title>
    <url>/p/introduction-to-kafaka-study-notes/</url>
    <content><![CDATA[<p>业务需要，最近在看尚硅谷的教程，本着好记性不如烂笔头的原则，有了这一系列的文章。</p>
<p>关键词：<strong>kafaka</strong></p>
<span id="more"></span>
<h2 id="定义">定义</h2>
<h3 id="传统定义">传统定义</h3>
<p>kafka是一个<strong>分布式</strong>的基于<strong>发布/订阅模式</strong>的消息队列（Message
Queue），主要应用于大数据实时处理。</p>
<h4 id="发布订阅">发布/订阅</h4>
<p>消息的发布者不会将数据直接发送给特定的订阅者，而是<strong>将发布的消息分为不同的类别</strong>，订阅者<strong>只接受感兴趣的消息</strong>。</p>
<h3 id="kafka最新定义">kafka最新定义</h3>
<p>kafka是一个<strong>开源的分布式事件流平台</strong>，用于高性能数据管道，流分析、数据集成、和关键任务应用。</p>
<h2 id="应用场景">应用场景</h2>
<h3 id="流量缓冲削峰">流量缓冲、削峰</h3>
<ul>
<li>有助于控制和优化数据流经过系统的速度，解决生产消息和消费消息处理速度不一致的情况。</li>
</ul>
<p><img data-src="image-20220419165347641.png" /></p>
<h3 id="解耦">解耦</h3>
<ul>
<li>允许独立的扩展和修改两边的处理过程，只需确保他们遵守同样的接口约束。</li>
</ul>
<p><img data-src="image-20220419165511301.png" /></p>
<h3 id="异步通信">异步通信</h3>
<ul>
<li>允许用户把一个消息放入队列，但是不立刻处理它，需要的时候再去处理。</li>
</ul>
<p><img data-src="image-20220419165706773.png" /></p>
<h2 id="消息队列的两种方式">消息队列的两种方式</h2>
<h3 id="点对点方式">点对点方式</h3>
<ul>
<li>消费者主动拉取数据，消息收到后清除消息</li>
</ul>
<p><img data-src="image-20220419165858779.png" /></p>
<h3 id="发布订阅方式">发布订阅方式</h3>
<ul>
<li>可以有多个topic主题（浏览、点赞、收藏、评论）</li>
<li>消费者消费以后不删除数据</li>
<li>每个消费者相互独立，都可以消费到数据</li>
</ul>
<p><img data-src="image-20220419170024390.png" /></p>
<h2 id="基础架构">基础架构</h2>
<p><img data-src="image-20220419170301160.png" /></p>
<ol type="1">
<li>producer：消息生产者，就是向kafka broker发消息的客户端。</li>
<li>consumer：消息消费者，就是向kafka broker取消息的客户端。</li>
<li>consumer
group（CG）：消费者组，多个consumer组成。<strong>消费者组内每个消费者负责消费不同分区的数据，一个分区只能由一个组内消费者消费；消费者组之间互不影响</strong>。所有消费者都属于某个消费者组。<strong>消费者组属于逻辑上的一个订阅者。</strong></li>
<li>broker：一台kafka服务器就是一个broker，一个集群由多个broker组成。一个broker可以容纳多个topic。</li>
<li>topic：生产者和消费者逻辑上操作的对象，即生产者向某个topic写数据，消费者从从某个topic读取数据。</li>
<li>partition：每个topic有多个partition，可以提高broker的负载（生产者可以向同一个topic发送多条数据，数据可以存储在不同的partition）。每个topic在每个partition上的数据是不重复的。partition表现为一个个的文件夹。</li>
<li>replica：副本。一个topic的每个partition都有若干个副本，副本分为leader和follower，leader是生产者和消费者物理上操作的对象，follower主动从leader拉取更新的内容。当某个分区的leader挂掉后，通过某种算法，将某一个follower升级为leader。</li>
</ol>
]]></content>
      <tags>
        <tag>kafaka</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣二叉树之二叉搜索树</title>
    <url>/p/binary-search-tree/</url>
    <content><![CDATA[<p>本文主要介绍LeetCode上关于二叉搜索树的题目。</p>
<p>关键词：<strong>二叉搜索树</strong></p>
<span id="more"></span>
<h2 id="定义">定义</h2>
<p>二叉搜索树是一个有序树。</p>
<ul>
<li>若他的左子树不为空，则左子树上所有节点的值均小于根节点的值；</li>
<li>若他的右子树不为空，则右子树上所有节点的值均大于根节点的值；</li>
<li>他的左子树和右子树也为二叉搜索树。</li>
</ul>
<p>一句话总结：左子树非空，左子树上节点小于根节点；右子树非空，右子树的节点大于根节点。</p>
<h2 id="题目">题目</h2>
<h3 id="验证二叉搜索树">验证二叉搜索树</h3>
<p>给定二叉搜索树，判断其是否是二叉搜索树。</p>
<p>注意二叉搜索树的特征：左子树非空，左子树小于根节点；右子树非空，右子树大于根节点。</p>
<h4 id="解法">解法</h4>
<p>设计一个递归函数<code>helper(root, lower, upper)</code>来递归判断。考虑以<code>root</code>为根的子树，判断子树中所有节点的值是否在<code>(lower, upper)</code>的范围内（开区间）。如果<code>root</code>节点的值<code>val</code>不在<code>(lower, upper)</code>的范围内说明不满足条件直接返回，否则我们要继续递归检查左右子树是否满足。</p>
<p>根据二叉搜索树的性质，在递归调用左子树时，需要把上界<code>upper</code>修改为当前节点的值；在递归调用右子树时，把下界<code>lower</code>修改为当前节点的值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValidBST</span><span class="params">(root *TreeNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> helper <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode, lower, upper <span class="type">int</span>)</span></span> <span class="type">bool</span> </span><br><span class="line">    helper = <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> root.Val &gt;= upper &amp;&amp; root.Val &lt;= lower &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> helper(root.Left, lower, root.Val) &amp;&amp; helper(root.Right, root.Val, upper)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> helper(root, math.MinInt64, math.MaxInt64)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉搜索树的搜索">二叉搜索树的搜索</h3>
<p>给定二叉搜索树（BST）的根节点和一个值。
你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。
如果节点不存在，则返回 NULL。</p>
<h4 id="解法-1">解法</h4>
<p>根据二叉搜索树（BST）的性质，左节点非空时，左节点的值小于根节点的值；右节点非空时，右节点的值大于根节点的值。</p>
<p>当给定值小于根节点值时，根节点变为左节点；当给定值大于根节点，根节点变为右节点，代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchBST</span><span class="params">(root *TreeNode, val <span class="type">int</span>)</span></span> *TreeNode &#123;</span><br><span class="line">    <span class="keyword">for</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> val &lt; root.Val &#123;</span><br><span class="line">           root = root.Left</span><br><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span> val &gt; root.Val &#123;</span><br><span class="line">           root = root.Right</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> root</span><br><span class="line">       &#125;</span><br><span class="line">   	<span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉搜索树的最近公共祖先">二叉搜索树的最近公共祖先</h3>
<p>给定二叉搜索树，找到该树中两个指定节点的最新公共祖先。</p>
<h4 id="解法-2">解法</h4>
<p>根据二叉搜索树（BST）的性质，左节点非空时，左节点的值小于根节点的值；右节点非空时，右节点的值大于根节点的值。</p>
<p>当某节点值的值在两个指定节点的值之间时，该节点就是两指定节点的最近公共祖先，代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lowestCommonAncestor</span><span class="params">(root, p, q *TreeNode)</span></span> *TreeNode &#123;</span><br><span class="line">    <span class="keyword">for</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> root.Val &lt; p.Val &amp;&amp; root.Val &lt; q.Val &#123;</span><br><span class="line">			root = root.Left</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> root.Val &gt; p.Val &amp;&amp; root.Val &gt; q.Val &#123;</span><br><span class="line">            root = root.Right</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉搜索树的插入操作">二叉搜索树的插入操作</h3>
<p>给定二叉搜索树（BST）的根节点 root 和要插入树中的值 value
，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证
，新值和原始二叉搜索树中的任意节点值都不同。</p>
<p>注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。你可以返回<strong>任意有效</strong>的结果。</p>
<h4 id="解法-3">解法</h4>
<p>根据二叉搜索树的性质，左节点非空时，左节点的值小于根节点的值；当右节点非空时，右节点的值大于根节点的值。</p>
<p>若根节点为空，直接返回值为给定值的二叉树节点；若非空，判断根节点的值和当前值的大小关系：</p>
<ul>
<li>若当前值大且右节点非空，则根节点到右节点；若右节点为空，则直接赋值右节点为当前值的节点。程序返回root节点</li>
<li>若当前值小且左节点非空，则根节点到左节点；若左节点为空，则直接赋值左节点为当前值的节点。程序返回root节点</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertIntoBST</span><span class="params">(root *TreeNode, val <span class="type">int</span>)</span></span> *TreeNode &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;TreeNode &#123;</span><br><span class="line">            Val: val,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    p := root</span><br><span class="line">    <span class="keyword">for</span> p != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> p.Val &lt; val &#123;</span><br><span class="line">            <span class="keyword">if</span> p.Left == <span class="literal">nil</span> &#123;</span><br><span class="line">                p.Left = &amp;TreeNode&#123; <span class="comment">// 直接赋值左节点</span></span><br><span class="line">                    Val: val,</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            p = p.Left</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> p.Right == <span class="literal">nil</span> &#123;  </span><br><span class="line">                p.Right = &amp;TreeNode&#123;</span><br><span class="line">                    Val: val, <span class="comment">// 直接赋值右节点</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            p = p.Right</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除二叉搜索树的节点">删除二叉搜索树的节点</h3>
<p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key
对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p>
<h4 id="解法-4">解法</h4>
<p>对于二叉搜索树，中序遍历的结果递增排序的序列。中序遍历的过程是<code>Left -&gt; Node-&gt; Right</code></p>
<p>若<code>Successor</code>
代表的是中序遍历序列的后一个节点，即比当前节点大的最小节点，则<code>Successor</code>的求解方法为：</p>
<ul>
<li>先取当前节点的右节点，然后一直取该节点的左节点，直到左节点为空，最后指向的节点为<code>Successor</code>。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sucessor</span><span class="params">(node *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    node = node.Right</span><br><span class="line">    <span class="keyword">for</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">        node = node.Left</span><br><span class="line">    &#125;</span><br><span class="line">   	<span class="keyword">return</span> node.Val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若<code>Predecessor</code>
代表的是中序遍历序列的前一个节点，即比当前节点小的最大节点，则<code>Predecessor</code>的求解方法为：</p>
<ul>
<li>先取当前节点的右节点，然后一直取该节点的右节点，直到右节点为空，最后指向的节点为<code>Predecessor</code>。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">predecessor</span><span class="params">(node *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    node = node.Right</span><br><span class="line">    <span class="keyword">for</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">        node = node.Right</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node.Val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有三种删除节点的情况：</p>
<ul>
<li>要删除的节点为叶子节点，可以直接删除。</li>
</ul>
<p><img data-src="b86c5d5866fb8b1f6a2f15f47262adf3ae68e56498c9e261a031bbb8ebc55588-file_1576477912302.jpeg" /></p>
<ul>
<li>要删除的节点不是叶子节点且<strong>拥有右节点</strong>，则该节点可以由<code>Successor节点</code>即中序遍历序列的后一个节点替代，该节点位于右子树较低的位置，可以从<code>Successor节点</code>的位置向下递归以删除从<code>Successor节点</code>；</li>
</ul>
<p><img data-src="12353e5c71267aafd355319a8b881f0b9efae0680358b7ce738228151a42d3cc-file_1576477912312.jpeg" /></p>
<ul>
<li>要删除的节点不是叶子节点且<strong>没有右节点但是有左节点</strong>。这意味着<code>Successor节点</code>在他的上面，此时我们可以使用<code>Predecessor</code>节点进行替代，再向下递归删除<code>Predecessor节点</code>
；</li>
</ul>
<p><img data-src="2a9aa44aab7948e78e06182791e2eaaf00fb72eff054a1f4612030a047dde59a-file_1576477912315.jpeg" /></p>
<p>算法：</p>
<ul>
<li>如果<code>key &gt; root.Val</code>，说明要删除的节点在右子树，<code>root.Right = deleteNode(root.Right, key)</code>；</li>
<li>如果<code>key &lt; root.Val</code>，说明要删除的节点在左子树，<code>root.Left = deleteNode(root.Left, key)</code>；</li>
<li>如果<code>key == root.Val</code>，说明了找到了要删除的节点：
<ul>
<li>如果该节点是叶子节点，直接删除：<code>root == nil</code>；</li>
<li>如果该节点不是叶子节点且<strong>拥有右节点</strong>，则用他的
<code>Sucessor</code>节点的值替换：<code>root.Val = sucessor(root)</code>，并递归删除<code>Sucessor</code>节点：<code>root.Right = deleteNode(root.Right, root.Val)</code>；</li>
<li>如果该节点不是叶子节点且<strong>没有右节点，拥有左节点</strong>，则用他的<code>Predecessor</code>节点值替换：<code>root.Val = predecessor(root)</code>，并递归删除<code>Precessor</code>节点：<code>root.Left = deleteNode(root.Left, root.Val)</code>；</li>
</ul></li>
<li>返回root。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sucessor</span><span class="params">(node *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	node = node.Right</span><br><span class="line">	<span class="keyword">for</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">		node = node.Left</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> node.Val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">predecessor</span><span class="params">(node *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	node = node.Left</span><br><span class="line">	<span class="keyword">for</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">		node = node.Right</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> node.Val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteNode</span><span class="params">(root *TreeNode, key <span class="type">int</span>)</span></span> *TreeNode &#123;</span><br><span class="line">	<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> key &gt; root.Val &#123;</span><br><span class="line">		root.Right = deleteNode(root.Right, key)</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> key &lt; root.Val &#123;</span><br><span class="line">		root.Left = deleteNode(root.Left, key)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> root.Left == <span class="literal">nil</span> &amp;&amp; root.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">			root = <span class="literal">nil</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> root.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">			root.Val = sucessor(root)</span><br><span class="line">			root.Right = deleteNode(root.Right, root.Val)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			root.Val = predecessor(root)</span><br><span class="line">			root.Left = deleteNode(root.Left, root.Val)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="修剪二叉树">修剪二叉树</h3>
<p>给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界
high。通过修剪二叉搜索树，使得所有节点的值在[low, high]中。修剪树 不应该
改变保留在树中的元素的相对结构
(即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在
唯一的答案 。</p>
<p>所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，<strong>根节点</strong>可能会根据给定的边界发生改变。</p>
<h4 id="解法-5">解法</h4>
<ul>
<li>当<code>node.Val &gt; R</code>，那么修剪后的二叉树必定出现在节点的左边；</li>
<li>当<code>node.Val &lt; L</code>，那么修剪后的二叉树必定出现在节点的右边；</li>
<li>其他情况修剪树的两边</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trimBST</span><span class="params">(root *TreeNode, L, R <span class="type">int</span>)</span></span> *TreeNode &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> root.Val &gt; R &#123;</span><br><span class="line">        <span class="keyword">return</span> trimBST(root.Left, L, R)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> root.Val &lt; L &#123;</span><br><span class="line">        <span class="keyword">return</span> trimBST(root.Right, L, R)</span><br><span class="line">    &#125;</span><br><span class="line">    root.Left = trimBST(root.Left, L, R)</span><br><span class="line">    root.Right = trimBST(root.Right, L, R)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="将有序数组转换为二叉搜索树">将有序数组转换为二叉搜索树</h3>
<p>给你一个整数数组nums ，其中元素已经按 <strong>升序</strong>
排列，请你将其转换为一棵 <strong>高度平衡</strong> 二叉搜索树。</p>
<p>高度平衡
二叉树是一棵满足「每个节点的左右两个子树的<strong>高度差的绝对值不超过
1</strong> 」的二叉树。</p>
<h4 id="解法-6">解法</h4>
<p>选择中间数字作为二叉搜索树的根节点，这样分给左右子树的数字个数相同或者只相差1个，因此可以保持树平衡。</p>
<p>如果数组的长度为奇数，则根节点的选择是唯一的。如果数组的长度是偶数，则可以选择你<strong>中间位置左边的数字作为根节点或者中间位置右边的数字作为根节点</strong>。选择不同的数字作为根节点，则创建的平衡二叉搜索树也是不同的。</p>
<p>确定平衡二叉搜索树的根节点之后，其余数字分别位于平衡二叉搜索树的左子树和右子树，左子树和右子树分别也是平衡二叉搜索树，因此可以通过递归的方式创建平衡二叉搜索树。</p>
<p>递归的基准情形是<strong>平衡二叉搜索树不包含任何数字</strong>，此时二叉搜索树为空。</p>
<p>在给定中序遍历数组的情况下，每一个子树的数字在数组中一定是连续的，因此可以通过数组下标范围确定子树包含的数字，下标范围记为<code>[left, right]</code>。对于整个中序遍历序列，下标范围从<code>left=0</code>到<code>right=nums.length-1</code>。当<code>left&gt;right</code>时，平衡二叉搜索树为空。</p>
<p>方法一：中序遍历，总是选择中间左边的数字作为根节点</p>
<p>选择中间位置左边的数字作为根节点，则根节点的下标为<code>mid = (left + right) / 2</code>，此处的除法为整数除法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortedArrayToRST</span><span class="params">(num []<span class="type">int</span>)</span></span> *TreeNode &#123;</span><br><span class="line">    <span class="keyword">return</span> helper(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helper</span><span class="params">(nums []<span class="type">int</span>, left, right <span class="type">int</span>)</span></span> *TreeNode &#123;</span><br><span class="line">    <span class="keyword">if</span> left &gt; right &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    mid := (left + right) / <span class="number">2</span></span><br><span class="line">    root = &amp;TreeNode&#123;Val: nums[mid]&#125;</span><br><span class="line">    root.Left = helper(nums, left, mid<span class="number">-1</span>)</span><br><span class="line">    root.Right = helper(nums, mid+<span class="number">1</span>, right)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="扩展">扩展</h4>
<p>根据中序和后序序列遍历二叉树</p>
<p>从前序与中序遍历序列构造二叉树</p>
<h3 id="把二叉搜索树转换为累加树">把二叉搜索树转换为累加树</h3>
<p>给出二叉搜索树的根节点，该树的节点各不相同，请你将其转换为累加树，使得每个节点<code>node</code>的新值等于原树中大于或等于<code>node.Val</code>的值之和。</p>
<h4 id="解法-7">解法</h4>
<p>二叉搜索树的中序遍历是单调递增的序列，对中序遍历进行反序操作可以得到单调递减的序列。对这个单调递减的序列进行操作即可得到这个累加树。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sum <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convertBST</span><span class="params">(root *TreeNode)</span></span> *TreeNode &#123;</span><br><span class="line">    <span class="keyword">if</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">        convertBST(root.Right)</span><br><span class="line">        sum += root.Val</span><br><span class="line">        root.Val = sum</span><br><span class="line">        convertBST(root.Left)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="拓展">拓展</h4>
<p>递归函数是否需要返回值的问题？</p>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣二叉树基础之深度优先遍历</title>
    <url>/p/DFS-in-binary-tree/</url>
    <content><![CDATA[<p>本文主要介绍LeetCode上关于二叉搜索树的题目。</p>
<p>本文主要介绍二叉树的深度优先（DFS）遍历其实就是递归遍历。</p>
<p>关键词：<strong>二叉树，递归遍历</strong></p>
<span id="more"></span>
<h2 id="什么是递归">什么是递归</h2>
<p>二叉树是什么，相信大家都知道，这里不在赘述。这里主要介绍函数的递归调用。</p>
<h3 id="递归函数三要素">递归函数三要素</h3>
<p>既然前人已经替我们总结了经验，那我们直接切入正题。</p>
<p>三要素指的是：</p>
<ol type="1">
<li>确定递归函数的参数和返回值</li>
<li>确定终止条件</li>
<li>确定单层递归函数的逻辑</li>
</ol>
<p>以二叉树的<strong>前序（迭代）遍历</strong>为例</p>
<ol type="1">
<li>确定递归函数的参数和返回值：遍历主要就是返回二叉树节点的值，因此参数就是二叉节点；</li>
<li>确定终止条件，终止条件就是<strong>节点为空；</strong></li>
<li>确定单层递归的逻辑：前序遍历指的是<code>Node-&gt;Left-&gt;Right</code>，即<strong>中、左、右</strong>，因此代码如下</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preorder</span><span class="params">(root *TreeNode)</span></span> (res []<span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> worker <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span></span> <span class="comment">// 递归函数</span></span><br><span class="line">    worker = <span class="function"><span class="keyword">func</span> <span class="params">(node *TreeNode)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">append</span>(res, node.Val) <span class="comment">// 中</span></span><br><span class="line">        worker(node.Left)           <span class="comment">// 左</span></span><br><span class="line">        worker(node.Right)          <span class="comment">// 右</span></span><br><span class="line">    &#125;</span><br><span class="line">    worker(root)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>中序（迭代）遍历</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inorder</span><span class="params">(root *TreeNode)</span></span> (res []<span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> worker <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span></span></span><br><span class="line">    worker = <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        worker(node.Left)</span><br><span class="line">        res = <span class="built_in">append</span>(res, node.Val)</span><br><span class="line">        worker(node.Right)</span><br><span class="line">    &#125;</span><br><span class="line">    worker(root)</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后序（迭代）遍历</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">postorder</span><span class="params">(root *TreeNode)</span></span> (res []<span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> worker <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span></span><br><span class="line">    worker = <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        worker(node.Left)</span><br><span class="line">        worker(node.Right)</span><br><span class="line">        res = <span class="built_in">append</span>(res, node.Val)</span><br><span class="line">    &#125;</span><br><span class="line">    worker(root)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题目">题目</h2>
<p>未完待续</p>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客SQL刷题</title>
    <url>/p/niuke-SQL-brush-questions/</url>
    <content><![CDATA[<p>本文主要介绍牛客网上SQL刷题的题目。</p>
<p>后端开发，必须要学SQL，不学习SQL怎么行。</p>
<p>关键词：<strong>SQL</strong></p>
<span id="more"></span>
<p>构造数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop table if exists user_profile;</span><br><span class="line">CREATE TABLE `user_profile` (</span><br><span class="line">`id` int NOT NULL,</span><br><span class="line">`device_id` int NOT NULL,</span><br><span class="line">`gender` varchar(14) NOT NULL,</span><br><span class="line">`age` int ,</span><br><span class="line">`university` varchar(32) NOT NULL,</span><br><span class="line">`province` varchar(32)  NOT NULL);</span><br><span class="line">INSERT INTO user_profile VALUES(1,2138,&#x27;male&#x27;,21,&#x27;北京大学&#x27;,&#x27;BeiJing&#x27;);</span><br><span class="line">INSERT INTO user_profile VALUES(2,3214,&#x27;male&#x27;,null,&#x27;复旦大学&#x27;,&#x27;Shanghai&#x27;);</span><br><span class="line">INSERT INTO user_profile VALUES(3,6543,&#x27;female&#x27;,20,&#x27;北京大学&#x27;,&#x27;BeiJing&#x27;);</span><br><span class="line">INSERT INTO user_profile VALUES(4,2315,&#x27;female&#x27;,23,&#x27;浙江大学&#x27;,&#x27;ZheJiang&#x27;);</span><br><span class="line">INSERT INTO user_profile VALUES(5,5432,&#x27;male&#x27;,25,&#x27;山东大学&#x27;,&#x27;Shandong&#x27;);;</span><br></pre></td></tr></table></figure>
<p>查询所有列</p>
<p><strong>一般不用</strong>*</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select id, device_id, gender, age, university, province from  user_profile;</span><br></pre></td></tr></table></figure>
<p>查询多列</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> device_id, gender, age, university <span class="keyword">from</span>  user_profile;</span><br></pre></td></tr></table></figure>
<p>查询用户所在学校并去重</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select distinct university from user_profile;</span><br><span class="line">select university from user_profile group by university;</span><br></pre></td></tr></table></figure>
<p>查询前两条device_id</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT device_id FROM user_profile LIMIT 2;</span><br></pre></td></tr></table></figure>
<p>给查询后的列重新命名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT device_id as user_infos_example FROM user_profile LIMIT 2;</span><br></pre></td></tr></table></figure>
<p>查询指定学校的信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT device_id, university from user_profile where university = &#x27;北京大学&#x27;;</span><br></pre></td></tr></table></figure>
<p>查询年龄大于24岁的信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT device_id, gender, age, university from user_profile where age &gt; 24;</span><br></pre></td></tr></table></figure>
<p>查询某个年龄段的用户信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT device_id, gender, age from user_profile where age &gt;= 20 and age &lt;= 23;</span><br></pre></td></tr></table></figure>
<p>查询不是复旦大学的信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT device_id, gender, age, university from user_profile where university != &#x27;复旦大学&#x27;;</span><br></pre></td></tr></table></figure>
<p>查询年龄不为null的信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT device_id, gender, age, university from user_profile where age is not null ;</span><br></pre></td></tr></table></figure>
<p>查询GPA&gt;3.5的男性信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select device_id, gender, age, university, gpa from user_profile where gpa &gt; 3.5 and gender = &#x27;male&#x27;;</span><br></pre></td></tr></table></figure>
<p>查询学校为北大或GPA在3.7以上(不包括3.7)信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select device_id, gender, age, university, gpa from user_profile where university = &#x27;北京大学&#x27; or gpa &gt; 3.7;</span><br></pre></td></tr></table></figure>
<p>查询学校为北大、复旦和山大的同学</p>
<p>推荐使用第二种方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select device_id, gender, age, university, gpa from user_profile where university = &#x27;北京大学&#x27; or university = &#x27;复旦大学&#x27; or university = &#x27;山东大学&#x27;;</span><br><span class="line">select device_id, gender, age, university, gpa from user_profile where university in(&#x27;北京大学&#x27;, &#x27;复旦大学&#x27;, &#x27;山东大学&#x27;); # 复用</span><br></pre></td></tr></table></figure>
<p>查询gpa在3.5以上(不包括3.5)的山东大学用户 或
gpa在3.8以上(不包括3.8)的复旦大学同学</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select device_id, gender, age, university, gpa from user_profile where (university  &#x27;复旦大学&#x27; and gpa &gt; 3.7) or (university = &#x27;山东大学&#x27; and gpa &gt; 3.5);</span><br></pre></td></tr></table></figure>
<p>查看学校名称中含北京的用户</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select device_id, age, university from user_profile where university REGEXP &#x27;.*北京.*&#x27;; # 正则</span><br><span class="line">select device_id, age, university from user_profile where university LIKE &#x27;%北京%&#x27;; # 模糊匹配</span><br><span class="line">select device_id, age, university from user_profile where locate(&#x27;北京&#x27;, university) &gt; 0; # 查找子串</span><br></pre></td></tr></table></figure>
<p>查找GPA最高值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select max(gpa) as gpa from user_profile where university = &#x27;复旦大学&#x27;; # max函数</span><br><span class="line">select gpa from user_profile where university = &#x27;复旦大学&#x27; order by gpa desc limit 1; # 降序排列</span><br></pre></td></tr></table></figure>
<p>计算男生人数平均GPA，其中平均GPA保留小数点后一位</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select count(id) as male_num, round(avg(gpa), 1) as avg_gpa from user_profile where gender = &#x27;male&#x27;;</span><br></pre></td></tr></table></figure>
<p>计算出每个学校每种性别的用户数、30天内平均活跃天数和平均发帖数量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select gender,</span><br><span class="line">       university,</span><br><span class="line">       count(*)                             as user_num,</span><br><span class="line">       round(avg(active_days_within_30), 1) as avg_active_day,</span><br><span class="line">       round(avg(question_cnt), 1)          as avg_question_cnt</span><br><span class="line">from user_profile</span><br><span class="line">group by gender, university;  #多分组，分组计算</span><br></pre></td></tr></table></figure>
<p>取出平均发贴数低于5的学校或平均回帖数小于20的学校</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select university, avg(question_cnt) as avg_question_cnt, avg(answer_cnt) as avg_answer_cnt</span><br><span class="line">from user_profile</span><br><span class="line">group by university</span><br><span class="line">having avg_question_cnt &lt; 5 or avg_answer_cnt &lt; 20; # 分组过滤，不能用where，要用having</span><br></pre></td></tr></table></figure>
<p>查询不同大学的用户平均发帖情况，按照平均发帖情况进行升序排列</p>
]]></content>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>利用heroku实现自动发布博客</title>
    <url>/p/automate-blog-posting-with-heroku/</url>
    <content><![CDATA[<p>之前博客都是使用Github
Actions实现自动构建的。最近不知道为啥老是不能构建成功，大概是因为资源被使用的太多了吧。。又想起来还有几个付费的heroku账户，于是便把构建仓库迁移到heroku平台。遂写一下这篇文章，也算是做个记录。</p>
<p>关键词：<strong>heroku，自动化构建</strong></p>
<span id="more"></span>
<h2 id="安装heroku-cli并登录">安装heroku cli并登录</h2>
<h3 id="安装">安装</h3>
<p>官网提供了<a
href="https://devcenter.heroku.com/articles/heroku-cli#install-the-heroku-cli">snap</a>的安装方式，不过这里使用脚本安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl https://cli-assets.heroku.com/install.sh | sh</span><br></pre></td></tr></table></figure>
<h3 id="登录">登录</h3>
<p>这里使用<strong>非浏览器登录</strong>的方式，使用<code>-i</code>参数。</p>
<p>如果出现Logged in as 则表示登陆成功。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">heroku login -i</span><br><span class="line"><span class="comment">#heroku: Enter your login credentials</span></span><br><span class="line"><span class="comment">#Email: zlb@mail.io</span></span><br><span class="line"><span class="comment">#Password: ***************</span></span><br><span class="line"><span class="comment">#Logged in as zlb@mail.io</span></span><br></pre></td></tr></table></figure>
<h2 id="使用-docker-进行部署">使用 Docker 进行部署</h2>
<p>heroku提供两种方式，第一种是部署预先构建的docker镜像到heroku；第二种是使用heroku.yml发布镜像到heroku平台。</p>
<p><img data-src="image-20220409100956279.png" /></p>
<p>为了简化步骤，这里先使用第一种方式。</p>
<h3
id="部署预先构建的docker镜像到heroku">部署预先构建的docker镜像到heroku</h3>
<h4 id="登录heroku容器仓库">登录heroku容器仓库</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">heroku container:login</span><br></pre></td></tr></table></figure>
<h4 id="编写流程的dockerfile">编写流程的Dockerfile</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM node:16-bullseye-slim</span><br><span class="line">ENV GH_TOKEN=***</span><br><span class="line">ENV GH_REF=***</span><br><span class="line">ENV TZ=Asia/Shanghai</span><br><span class="line">ARG DEBIAN_FRONTEND=noninteractive</span><br><span class="line">WORKDIR /opt/</span><br><span class="line">COPY run.sh /opt</span><br><span class="line">RUN <span class="built_in">set</span> -ex \</span><br><span class="line">&amp;&amp; sed -i <span class="string">&#x27;s/deb.debian.org/mirrors.ustc.edu.cn/g&#x27;</span> /etc/apt/sources.list \</span><br><span class="line">&amp;&amp; apt-get update \</span><br><span class="line">&amp;&amp; apt-get install wget git -y \</span><br><span class="line">&amp;&amp; wget -O /tmp/pandoc.deb -q https://github.com/jgm/pandoc/releases/download/2.14.2/pandoc-2.14.2-1-amd64.deb \</span><br><span class="line">&amp;&amp; dpkg -i /tmp/pandoc.deb \</span><br><span class="line">&amp;&amp; npm config <span class="built_in">set</span> registry https://registry.npmmirror.com \</span><br><span class="line">&amp;&amp; npm config get registry \</span><br><span class="line">&amp;&amp; npm i hexo-cli @next-theme/plugins -g --save \</span><br><span class="line">&amp;&amp; npm un hexo-renderer-marked \</span><br><span class="line">&amp;&amp; npm i hexo-renderer-pandoc -g --save</span><br><span class="line">CMD [<span class="string">&quot;bash&quot;</span>,<span class="string">&quot;run.sh&quot;</span>]</span><br></pre></td></tr></table></figure>
<p>而bash脚本里面做的主要就是拉取仓库，利用hexo生成静态文件，然后推送到指定的仓库。这样可以利用github
pages等其他可以托管静态文件的服务了。</p>
<h4
id="构建镜像并且推送到heroku的镜像仓库">构建镜像并且推送到heroku的镜像仓库</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">heroku container:push worker -a &lt;APP_NAME&gt;</span><br></pre></td></tr></table></figure>
<p>ps：worker是区别于web的进程类型，由于这里不是web服务，故使用worker。</p>
<p>折腾了半天，生成的镜像倒是可以推送新的静态文件到指定的仓库了，但是这个操作无法利用博客源码的更新自动执行！！！</p>
<p><img data-src="image-20220409125928022.png" /></p>
<p>由于我这里使用的是heroku
cli进行操作的，无法连接到GitHub仓库，也就无法触发更新了。看来只能使用第二种方法，<strong>使用heroku.yml部署镜像到heroku了</strong></p>
<h3 id="使用heroku.yml部署镜像">使用heroku.yml部署镜像</h3>
<p>在博客源码的根目录增加heroku.yml，heroku.yml描述的就是容器需要完成的操作。</p>
<p>如果是使用这种方法，那么就需要更改一下Dockerfile。因为heroku.yml和博客源码在同一目录，而拉取源码的操作就可以去掉了。</p>
]]></content>
      <tags>
        <tag>heroku</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker打包镜像文件</title>
    <url>/p/export-docker-images-to-file/</url>
    <content><![CDATA[<p>最近需要离线部署一个项目，项目是跑在docker容器里的，而部署环境无法链接外网。本来是考虑在笔记本上跑一个<strong>私有的docker
registry</strong>，部署时从笔记本拉取镜像。但是这种情况必须是笔记本和部署机在<strong>同一个内网</strong>下，两者可以相互访问。因此必须要考虑Plan
B，Plan B就是将本地镜像打包成tar文件，部署时传到部署机即可。</p>
<p>但是这种情况也存在问题，一旦容器内的依赖（如maven、pip）发生变化，基础镜像就需要重新打包，这种情况还没想好需要怎么操作。。不过还是那句话，做了再说，遇到了问题再想办法解决。</p>
<p>关键字：<strong>docker，打包镜像文件</strong></p>
<span id="more"></span>
<h4 id="打包镜像文件">打包镜像文件</h4>
<p>第一个参数是文件名，第二个参数是镜像名</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker save -o jenkinsci.tar.gz jenkinsci/blueocean</span><br></pre></td></tr></table></figure>
<h4 id="读取镜像文件">读取镜像文件</h4>
<p>第一个参数是文件名称</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker load -i jenkinsci.tar.gz</span><br><span class="line"><span class="comment"># Loaded image: jenkinsci/blueocean:latest</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>离线安装docker</title>
    <url>/p/offline-install-docker-offline/</url>
    <content><![CDATA[<p>最近在部署项目，甲方的部署环境有可能内网环境，而我们现在的项目是部署在docker中的，所以需要记录一下如何离线安装docker。这里的步骤对于其他需要离线安装的deb包也是适用的。</p>
<p>关键字：<strong>docker，离线安装</strong></p>
<span id="more"></span>
<h2 id="下载docker相关的依赖包">下载docker相关的依赖包</h2>
<p>首先需要一台能上外网的机器，下载和docker相关的依赖。</p>
<ol type="1">
<li>安装必要工具，这里把相关依赖都下载下来</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install apt-transport-https ca-certificates curl software-properties-common -yd</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>安装GPG证书，这里以aliyun的为例</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure>
<p>ps：一般发行版都有curl了，所以不用安装，实在没有也可以导出相关的deb包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install --reinstall curl -yd</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>写入软件源信息</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository <span class="string">&quot;deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu <span class="subst">$(lsb_release -cs)</span> stable&quot;</span></span><br></pre></td></tr></table></figure>
<ol start="4" type="1">
<li>更新并导出Docker-CE相关的安装包</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get -y update</span><br><span class="line">sudo apt-get  install docker-ce -yd</span><br></pre></td></tr></table></figure>
<ol start="5" type="1">
<li>导出生成索引文件的安装包</li>
</ol>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install dpkg-dev -yd</span><br></pre></td></tr></table></figure></p>
<ol start="6" type="1">
<li>将docker相关的依赖包转移到U盘或者其他文件夹，准备下一步安装</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo tar zcvf docker.tar.gz docker <span class="comment"># 压缩</span></span><br><span class="line">sudo tar zxvf docker.tar.gz		  <span class="comment"># 解压</span></span><br></pre></td></tr></table></figure>
<h2 id="在需要离线安装的主机上操作">在需要离线安装的主机上操作</h2>
<p>这里有两者方案，第一种方案是使用<code>dpkg</code>进行安装，命令比较简单：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /your-path/docker</span><br><span class="line">sudo dpkg -i *.deb</span><br></pre></td></tr></table></figure>
<p>第二种方案，就是使用apt安装。需要首先创建apt本地仓库</p>
<ol type="1">
<li>离线安装dpkg-dev</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /your-path/dpkg-deb</span><br><span class="line">sudo dpkg -i *.deb</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>利用上一步生成的docker安装包，建立deb包的依赖关系</li>
</ol>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 777 -R /your-path</span><br><span class="line">sudo <span class="built_in">touch</span> /your-path/docker/Packages.gz</span><br><span class="line">sudo dpkg-scanpackages docker /dev/null  | gzip &gt; /your-path/docker/Packages.gz</span><br></pre></td></tr></table></figure></p>
<ol start="3" type="1">
<li>将所有下载的文件和生成的gz文件拷贝到离线的ubuntu机器上，将<code>/etc/apt/sources.list</code>原有内容注释掉，新增：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deb file:/your-path /docker</span><br></pre></td></tr></table></figure>
<ol start="4" type="1">
<li>更新apt索引，这里设置允许不安全的仓库</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update --allow-insecure-repositories</span><br></pre></td></tr></table></figure>
<ol start="5" type="1">
<li>安装docker-ce</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install docker-ce -y</span><br></pre></td></tr></table></figure>
<ol start="6" type="1">
<li>查看是否安装成功</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker info</span><br></pre></td></tr></table></figure>
<p><img data-src="image-20220408123754001.png" /></p>
]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins实战（一）Jenkins和持续集成</title>
    <url>/p/jenkins-and-CI/</url>
    <content><![CDATA[<p>最近实习公司的项目要在甲方那边部署了，而现在还没有开发完毕。因此需要一个持续集成的系统，来实现<strong>定时构建镜像或者jar包的功能</strong>。现在我司是用的<code>coding webhook</code>
+
自己实现的监听程序，当代码更新时，coding发送一个webhook通知到程序，根据webhook消息的内容来重启容器，从而实现了持续集成的功能。</p>
<p>然而由于是自己实现的代码，在实际部署过程中遇到了很多bug，因此这套系统肯定不能部署在甲方爸爸那里。</p>
<p>于是我就去网上搜索，发现jenkins是一个比较好用的持续集成开源软件，于是有了这一系列文章。</p>
<p>关键词：<strong>jenkins，持续集成</strong></p>
<span id="more"></span>
<h2 id="为什么需要持续集成">为什么需要持续集成？</h2>
<p>持续集成，Continuous Integration，简称CI。</p>
<p>随着软件开发复杂度的不断提高，团队开发成员间如何更好地协同工作以确保软件开发的质量已经慢慢成为开发过程中不可回避的问题。尤其是近些年来，敏捷（Agile）
在软件工程领域越来越红火，如何能再不断变化的需求中快速适应和保证软件的质量也显得尤其的重要。</p>
<p>持续集成正是针对这一类问题的一种软件开发实践。它倡导团队开发成员必须经常集成他们的工作，甚至每天都可能发生多次集成。而每次的集成都是通过自动化的构建来验证，包括<strong>自动编译、发布和测试</strong>，从而尽快地发现集成错误，让团队能够更快的开发内聚的软件。</p>
<h3 id="持续集成的特点">持续集成的特点</h3>
<ul>
<li><p>持续集成是一个自动化的周期性的集成测试过程，从检出代码、编译构建、运行测试、结果记录和测试统计都是自动完成的，无需人工干预；</p></li>
<li><p>持续集成需要专门的集成服务器来执行执行构建；</p></li>
<li><p>需要代码托管工具支持</p></li>
</ul>
<h3 id="持续集成的作用">持续集成的作用</h3>
<ul>
<li>保证了团队开发人员提交代码的质量，减轻了软件发布时的压力；</li>
<li>由于持续集成中的每一个环节都是自动完成的，无需人工干预，有利于减少重复过程以节省时间、费用、和工作量；</li>
</ul>
<h2 id="如何实现持续集成">如何实现持续集成？</h2>
<h3 id="jenkins介绍">Jenkins介绍</h3>
<p>Jenkins，原名Hudson，2011年改为现在的名字，它是一个开源的实现持续集成的软件工具。官方网站：http://jenkins-ci.org/。</p>
<p>Jenkins
能实施监控集成中存在的错误，提供详细的日志文件和提醒功能，还能用图表的形式形象地展示项目构建的趋势和稳定性。</p>
<p>目前持续集成（CI）已成为当前许多软件开发团队在整个软件开发生命周期内侧重于保证代码质量的常见做法。它是一种实践，旨在<strong>缓和和稳固软件</strong>的构建过程。并且能够帮助您的开发团队应对如下挑战：</p>
<ul>
<li><p>软件构建自动化
：配置完成后，CI系统会依照预先制定的时间表，或者针对某一特定事件，对目标软件进行构建；</p></li>
<li><p>构建可持续的自动化检查
：CI系统能持续地获取新增或修改后签入的源代码，也就是说，当软件开发团队需要周期性的检查新增或修改后的代码时，CI系统会不断确认这些新代码是否破坏了原有软件的成功构建。这减少了开发者们在检查彼此相互依存的代码中变化情况需要花费的时间和精力；</p></li>
<li><p>构建可持续的自动化测试
：构建检查的扩展部分，构建后执行预先制定的一套测试规则，完成后触发通知(Email,RSS等等)给相关的当事人；</p></li>
<li><p>生成后后续过程的自动化
：当自动化检查和测试成功完成，软件构建的周期中可能也需要一些额外的任务，诸如生成文档、打包软件、部署构件到一个运行环境或者软件仓库。这样，构件才能更迅速地提供给用户使用；</p></li>
</ul>
<p>部署一个CI系统需要的最低要求是，<strong>一个可获取的源代码的仓库，一个包含构建脚本的项目。</strong></p>
<h3 id="jenkins特点">Jenkins特点</h3>
<ul>
<li><p>易安装：仅一个
jenkins.war文件，从官网下载该文件后，直接运行，无需额外的安装，无需安装数据库等；</p></li>
<li><p>易配置：提供友好的GUI配置界面；</p></li>
<li><p>变更支持：Jenkins能从代码仓库（Subversion/CVS）中获取并产生代码更新列表并输出到编译输出信息中；</p></li>
<li><p>支持永久链接：用户是通过web来访问Jenkins的，而这些web页面的链接地址都是永久链接地址，因此，你可以在各种文档中直接使用该链接；</p></li>
<li><p>集成E-Mail/RSS/IM：当完成一次集成时，可通过这些工具实时告诉你集成结果（据我所知，构建一次集成需要花费一定时间，有了这个功能，你就可以在等待结果过程中，干别的事情）；</p></li>
<li><p>JUnit/TestNG测试报告：也就是用以图表等形式提供详细的测试报表功能；</p></li>
<li><p>支持分布式构建：Jenkins可以把集成构建等工作分发到多台计算机中完成；</p></li>
<li><p>文件指纹信息：Jenkins会保存哪次集成构建产生了哪些jars文件，哪一次集成构建使用了哪个版本的jars文件等构建记录；</p></li>
<li><p>支持第三方插件：使得 Jenkins 变得越来越强大；</p></li>
</ul>
<h3 id="其他集成工具">其他集成工具</h3>
<p>其它比较著名的持续集成工具有：CruiseControl，TeamCity，Continuum等。</p>
<p>原文链接：https://wiki.eryajf.net/pages/56.html</p>
]]></content>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins实战（三）设置邮件推送</title>
    <url>/p/set-mail-push-in-jenkins/</url>
    <content><![CDATA[<p>本文主要介绍如何在Jenkins上设置邮件推送。</p>
<p>关键词：<strong>Jenkins</strong></p>
<span id="more"></span>
<h3 id="需求来源">需求来源</h3>
<p>持续集成时设置邮件推送是一个很清晰的需求，当部署失败时，提示一个消息到群或者是群发邮件，然后运维在查看失败的原因，然后根据问题提出解决方案。</p>
<h3 id="操作演示">操作演示</h3>
<h4 id="设置邮件管理员">设置邮件管理员</h4>
<p>这个设置很重要，即发送邮件地址必须在是邮件管理员或者在邮件管理员列表里</p>
<p><img data-src="image-20220526165013137.png" /></p>
<h4 id="设置邮件服务器等信息">设置邮件服务器等信息</h4>
<ol type="1">
<li>在主页依次找到<strong>系统管理——系统配置——Extended E-mail
Notification</strong></li>
</ol>
<p><img data-src="image-20220526143632620.png" /></p>
<ol start="2" type="1">
<li>根据自己的邮件服务提供商选择SMTP服务地址和授权码，这里以<strong>网易的yeah邮箱为例</strong></li>
</ol>
<ul>
<li><p>POP3服务器: pop.yeah.net</p></li>
<li><p>SMTP服务器: smtp.yeah.net</p></li>
<li><p>IMAP服务器: imap.yeah.net</p></li>
</ul>
<p><img data-src="image-20220526144249859.png" /></p>
<ol start="3" type="1">
<li>将上文生成的授权码以<strong>机密</strong>的形式存入Jenkins的全局<strong>Credentials</strong>中，然后选中这个Credentials，端口选择465</li>
</ol>
<p><img data-src="image-20220526145055905.png" /></p>
<ol start="4" type="1">
<li><p>修改附件等其他设置</p>
<p>这里设置为-1，即不限制大小。</p></li>
</ol>
<p><img data-src="image-20220526145136224.png" /></p>
<h4 id="增加邮件推送到构建后操作">增加邮件推送到构建后操作</h4>
<ul>
<li>选择<strong>E-mail Editable Notification</strong></li>
</ul>
<p><img data-src="image-20220526145725924.png" /></p>
<p>下面分析下这个功能下的各个选项</p>
<h5 id="disable-extended-email-publisher">Disable Extended Email
Publisher</h5>
<p>关闭邮件推送，这个功能可以在测试功能时使用。</p>
<h5 id="project-from"><strong>Project From</strong></h5>
<p>项目来自，这个写项目构建人即可。</p>
<h5 id="project-recipient-list项目收件人"><strong>Project Recipient
List（项目收件人）</strong></h5>
<p>默认选项是<code>$DEFAULT_RECIPIENTS</code>，对应一个邮件列表。</p>
<p>也可自定义填写需要收到邮件的人的邮件。在公司中也可以填写邮件组来简化操作。</p>
<h5 id="project-reply-to-list"><strong>Project Reply-To
List</strong></h5>
<p>默认选项是<code>$DEFAULT_REPLYTO</code>，含义是此项目的回复标头中的电子邮件地址的逗号分隔列表。由于这里就是单纯的发送一个邮件，所以默认即可。</p>
<h5 id="content-type">Content Type</h5>
<p>发送内容类型，保持默认即可。</p>
<h5 id="default-subject"><strong>Default Subject</strong></h5>
<p>默认邮件主题，保持默认即可。</p>
<p><strong>Default Content</strong></p>
<p>默认邮件内容。这个可以在下面进行个性化配置的时候进行设置。这里先保存默认。</p>
<h5 id="attachments">Attachments</h5>
<p>附件内容。可以将打包好的软件或者其他附属产品发送给开发人员测试。直接指定文件即可，如<code>module/dist/**/*.zip</code></p>
<h5 id="attach-build-log">Attach Build Log</h5>
<p>附加构建日志。这个功能很有用，当构建失败时可以直接在邮箱中看到日志。</p>
<p>这里选择<strong>Attach Build
Log</strong>，而不是选压缩的选项。这样可以直接看到日志。</p>
<p><strong>Content Token Reference（内容令牌参考）</strong></p>
<p>这个很有用，可以根据这些Token生成邮件内容。</p>
<h5 id="triggers邮件触发器">Triggers（邮件触发器）</h5>
<p>这个可以设置什么情况下发送邮件，这里选择Always。</p>
<h4 id="测试推送">测试推送</h4>
<p>折腾了快半个小时，终于设置成功。看似一个很简单的东西，此时也是有技术含量的。</p>
<p><img data-src="Jenkins实战（三）Jenkins设置邮件推送/image-20220526165337834.png" /></p>
<h3 id="总结">总结</h3>
<p>设置邮件推送主要有以下步骤</p>
<ol type="1">
<li>设置邮件管理员</li>
<li>设置credentials</li>
<li>设置stmp全局设置</li>
<li>根据不同的任务设置邮件推送信息（一般不用变）</li>
</ol>
]]></content>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker in docker</title>
    <url>/p/docker-in-docker/</url>
    <content><![CDATA[<p>啥是docker in
docker？字如其义，就是在docker里面实现docker，换句话说，就是如何在docker执行docker命令。</p>
<p>有人可能会问了，为啥要这么麻烦，直接裸机跑容器不就完了吗？</p>
<p>读完这篇文章，你应该会有所了解。</p>
<p>关键字：<strong>docker in docker</strong></p>
<span id="more"></span>
<h2 id="docker-in-dockerdind">docker in docker(dind)</h2>
<p>有时需要在容器里面执行docker命令，比如在<strong>jenkins 容器内运行
docker 命令执行构建镜像</strong>等。</p>
<p>事实上，docker是支持嵌套的。但是直接在docker容器里面安装docker有点臃肿。</p>
<p>更好的方法是：容器里面仅仅部署docker-cli（作为客户端），实际执行交给宿主机内的
docker-engine（服务端）</p>
<h2 id="两种方式">两种方式</h2>
<p>一种方式是，通过宿主机的<code>docker.sock</code>文件，将宿主机docker服务端的socket文件挂载到容器内，同时将docker二进制文件挂载到容器内，这样，容器内就不需要安装docker程序。当容器内使用docker命令时，实际上调用的是宿主机的docker
daemon和docker命令。也就是说，容器内并未真正运行docker
server，但是能通过宿主机执行docker任务，从而实现轻量级docker in
docker。这种情况下，真正执行docker命令的是跑在宿主机上的docker-engine，<strong>并不是真正的docker
in
docker</strong>。但是这种情况速度较快，然后存在一定的安全问题。<strong>不过，这种情况就是我们所需要的呀！！</strong></p>
<p>还有一种方式是，启动一个<code>docker:dind</code>
容器A，再启动一个docker容器B，容器B指定DOCKER_HOST为A容器内的docker
daemon。</p>
<h3 id="使用宿主机的socket文件">使用宿主机的socket文件</h3>
<p>本想着挂载宿主机的<code>docker.sock</code>文件和docker二进制文件到容器即可实现<code>dind</code>，无奈默认情况下<code>docker.sock</code>文件是经过tls证书加密的，而在默认情况下加密的根证书却没有找到，通过宿主机执行<code>docker info</code>命令会提示以下错误：</p>
<p><img data-src="image-20220406163343550.png" /></p>
<p>翻阅资料知道<code>docker daemon</code>可以通过暴露tcp端口实现通信，而默认情况<strong>不是加密的</strong>，于是这个路就通了！！</p>
<h3
id="通过暴露宿主机的tcp端口实现通信">通过暴露宿主机的tcp端口实现通信</h3>
<ol type="1">
<li>查看宿主机<code>docker</code>服务单元文件地址</li>
</ol>
<p><img data-src="image-20220406163920282.png" /></p>
<ol start="2" type="1">
<li>修改宿主机<code>docker</code>服务单元文件</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /lib/systemd/system/docker.service</span><br></pre></td></tr></table></figure>
<p>安全起见，指定IP地址为局域网内网地址即可。</p>
<p><img data-src="image-20220406164257539.png" /></p>
<ol start="3" type="1">
<li>重载服务单元文件</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br></pre></td></tr></table></figure>
<ol start="4" type="1">
<li>重启服务</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart docker.service</span><br></pre></td></tr></table></figure>
<ol start="5" type="1">
<li>设置容器环境实现和宿主机<code>docker daemon</code>通信</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">version: <span class="string">&#x27;3&#x27;</span></span><br><span class="line">services:</span><br><span class="line">  jenkins:</span><br><span class="line">    container_name: jenkins</span><br><span class="line">    image: ubuntu</span><br><span class="line">    environment:</span><br><span class="line">      - DOCKER_HOST=tcp://192.168.15.118:2375</span><br><span class="line">    volumes:</span><br><span class="line">      - /var/lib/docker:/var/lib/docker</span><br><span class="line">      - /usr/bin/docker:/usr/bin/docker</span><br><span class="line">      - /usr/local/bin/docker-compose:/usr/local/bin/docker-compose</span><br><span class="line">    <span class="built_in">command</span>: [<span class="string">&quot;docker&quot;</span>, <span class="string">&quot;info&quot;</span>]</span><br></pre></td></tr></table></figure>
<ol start="6" type="1">
<li>测试</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker-compose up</span><br></pre></td></tr></table></figure>
<p><img data-src="image-20220406165727628.png" /></p>
<p>通过上述方法，即可实现<strong>在jenkins容器中操作docker容器啦</strong></p>
<h2 id="后记">后记</h2>
<p>本来是想通过上述第一种方式来实现<strong>jenkins容器中操作docker容器</strong>，但是发现这种方法有点问题：</p>
<ul>
<li>容器内使用的是实际上宿主机的<code>docker daemon</code>，因此挂载路径时，实际上挂上去的是<strong>宿主机的目录</strong>。而不是<strong>jenkins容器</strong>内的文件！！因此如果要使用上面第一种dind的方式，那么每次部署的时候都需要<strong>重新打包镜像</strong>！！而不是<strong>挂载目录</strong>！！！</li>
<li>如果采用了上面的方案实现了dind，那么怎么监听部署没部署成功呢？看来又要写相应脚本判断了。
<ul>
<li>更新：不用脚本，不用脚本，直接<code>docker inspect</code>即可获得容器的状态！！！</li>
</ul></li>
</ul>
]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>初探docker(三) | docker-compose 简介</title>
    <url>/p/docker-tutorial-03/</url>
    <content><![CDATA[<p>本文主要介绍<code>Docker Compose</code>.</p>
<p><code>Docker Compose</code> 是 Docker
官方编排（Orchestration）项目之一，负责快速的部署分布式应用。</p>
<p><strong>关键词：</strong>Docker</p>
<span id="more"></span>
<h2 id="简介">简介</h2>
<p>Compose定位是<strong>定义和运行多个 Docker 容器的应用（Defining and
running multi-container Docker applications）</strong>.</p>
<p>日常工作中，经常会碰到需要多个容器相互配合来完成某项任务的情况，例如要实现一个项目，除了Web服务容器本身，往往还需要再加上后端的数据库服务器，甚至包括负载均衡容器等。</p>
<p>Compose允许用户通过一个单独的<code>docker-compose.yml</code>模板文件（YAML格式）来定义一组相关联的应用容器为一个项目。</p>
<p>Compose有以下两个重要的概念：</p>
<ul>
<li>服务(<code>service</code>)：一个应用的容器，实际上可以包括若干个相同镜像的容器实例。</li>
<li>项目(<code>project</code>)：由一组关联的应用容器组成一个完整的业务单元，在<code>docker-compose.yml</code>文件中定义。</li>
</ul>
<p>Compose的默认管理对象是项目，通过子命令对项目中的一组容器进行声明周期管理.</p>
<h2 id="安装">安装</h2>
<p>项目地址：https://github.com/docker/compose/releases</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://github.com/docker/compose/releases/latest/download/docker-compose-linux-x86_64</span><br><span class="line"><span class="built_in">chmod</span> +x docker-compose-linux-x86_64</span><br><span class="line">sudo install docker-compose-linux-x86_64 /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure>
<h2 id="一个简单的场景">一个简单的场景</h2>
<p>最常见的场景是web网站，该项目应该包含web应用和缓存。下面用<code>Python</code>来建立一个能够记录页面访问次数的网站。</p>
<h3 id="web应用">web应用</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> redis <span class="keyword">import</span> Redis</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">redis = Redis(host=<span class="string">&#x27;redis&#x27;</span>, host=<span class="number">6379</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>():</span><br><span class="line">    count = redis.incr(<span class="string">&#x27;hits&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello World! 此页面已经被访问&#123;&#125;次数. \n&#x27;</span>.<span class="built_in">format</span>(count)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(host, <span class="string">&quot;0.0.0.0&quot;</span>, debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<h3 id="dockerfile">Dockerfile</h3>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">From</span> python:<span class="number">3.6</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> . /app</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip install redis flask</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;python&quot;</span>, <span class="string">&quot;app.py&quot;</span>]</span></span><br></pre></td></tr></table></figure>
<h3 id="docker-compose.yml">docker-compose.yml</h3>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">	<span class="attr">web:</span></span><br><span class="line">		<span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">		<span class="attr">ports:</span></span><br><span class="line">			<span class="bullet">-</span> <span class="number">5000</span><span class="string">:5000</span></span><br><span class="line">	<span class="attr">redis:</span></span><br><span class="line">		<span class="attr">image:</span> <span class="string">redis</span></span><br></pre></td></tr></table></figure>
<h3 id="运行">运行</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>
<p>每访问一次5000端口，页面的次数都会+1</p>
<h2 id="命令说明">命令说明</h2>
<p>大部分命令可以是项目本身，也可以是项目中的服务或者容器。如果没有特别说明，命令的对象是<strong>项目本身</strong>。</p>
<p>命令的基本使用格式为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker-compose [-f=&lt;arg&gt;...] [options] [COMMAND] [ARGS...]</span><br></pre></td></tr></table></figure>
<h3 id="命令选项">命令选项</h3>
<ul>
<li><code>-f, --file FILE</code>指定使用的模板文件，默认为<code>docker-compose.yml</code>，可以多次指定。</li>
<li><code>-p, --project-name NAME</code>指定项目名称，默认使用目录所在名称为项目名。</li>
<li><code>--verbose</code>输出更多调试信息</li>
<li><code>-v, --version</code>打印版本并退出。</li>
</ul>
<h4 id="命令使用说明">命令使用说明</h4>
<h4 id="build"><code>build</code></h4>
<p>格式为<code>docker-compose build [options] [SERVICE...]</code></p>
<p>构建（重新构建）项目中的服务容器。</p>
<p>服务容器一旦构建，将会带一个标记名。例如<code>web</code>项目中的一个<code>db</code>容器，可能是<code>web_db</code>。</p>
<p>可以随时在项目目录下运行
<code>docker-compose build</code>来重新构建服务。</p>
<p>选项</p>
<ul>
<li><p><code>--force-rm</code> 删除构建过程中的临时容器。</p></li>
<li><p><code>--no-cache</code> 构建镜像过程中不使用
cache（这将加长构建过程）。</p></li>
<li><p><code>--pull</code> 始终尝试通过 pull
来获取更新版本的镜像。</p></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage:  docker compose build [SERVICE...]</span><br><span class="line">Build or rebuild services</span><br><span class="line">Options:</span><br><span class="line">      --build-arg stringArray   Set build-time variables <span class="keyword">for</span> services.</span><br><span class="line">      --no-cache                Do not use cache when building the image</span><br><span class="line">      --progress string         Set <span class="built_in">type</span> of progress output (auto, <span class="built_in">tty</span>, plain, quiet) (default <span class="string">&quot;auto&quot;</span>)</span><br><span class="line">      --pull                    Always attempt to pull a newer version of the image.</span><br><span class="line">  -q, --quiet                   Don<span class="string">&#x27;t print anything to STDOUT</span></span><br></pre></td></tr></table></figure>
<h4 id="config"><code>config</code></h4>
<p>验证文件格式是否正确，正确显示配置，错误显示错误原因</p>
<h4 id="down"><code>down</code></h4>
<p>停止<code>up</code>命令所启动的容器，并移除网络</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Stop and remove containers, networks</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">      --remove-orphans    Remove containers <span class="keyword">for</span> services not defined <span class="keyword">in</span> the Compose file.</span><br><span class="line">      --rmi string        Remove images used by services. <span class="string">&quot;local&quot;</span> remove only images that don<span class="string">&#x27;t have a custom tag (&quot;local&quot;|&quot;all&quot;)</span></span><br><span class="line"><span class="string">  -t, --timeout int       Specify a shutdown timeout in seconds (default 10)</span></span><br><span class="line"><span class="string">  -v, --volumes volumes    Remove named volumes declared in the volumes section of the Compose file and anonymous volumes attached to containers.</span></span><br></pre></td></tr></table></figure>
<h4 id="exec"><code>exec</code></h4>
<p>进入指定的容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> Usage: docker compose <span class="built_in">exec</span> [options] [-e KEY=VAL...] [--] SERVICE COMMAND [ARGS...]</span><br><span class="line"> Execute a <span class="built_in">command</span> <span class="keyword">in</span> a running container.</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -d, --detach                       Detached mode: Run <span class="built_in">command</span> <span class="keyword">in</span> the background.</span><br><span class="line">  -e, --<span class="built_in">env</span> stringArray              Set environment variables</span><br><span class="line">      --index int                    index of the container <span class="keyword">if</span> there are multiple instances of a service [default: 1]. (default 1)</span><br><span class="line">  -T, --no-TTY docker compose <span class="built_in">exec</span>   Disable pseudo-TTY allocation. By default docker compose <span class="built_in">exec</span> allocates a TTY.</span><br><span class="line">      --privileged                   Give extended privileges to the process.</span><br><span class="line">  -u, --user string                  Run the <span class="built_in">command</span> as this user.(user or uid)</span><br><span class="line">  -w, --workdir string               Path to workdir directory <span class="keyword">for</span> this <span class="built_in">command</span>.</span><br></pre></td></tr></table></figure>
<h4 id="images"><code>images</code></h4>
<p>列出compose文件包含的镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage:  docker compose images [SERVICE...]</span><br><span class="line"></span><br><span class="line">List images used by the created containers</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -q, --quiet   Only display IDs</span><br></pre></td></tr></table></figure>
<h4 id="kill"><code>kill</code></h4>
<p>发送<code>SIGKILL</code>来强制停止服务容器</p>
<p>支持通过<code>-s</code>参数指定发送的信号，默认发送<code>SIGKILL</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage:  docker compose <span class="built_in">kill</span> [options] [SERVICE...]</span><br><span class="line"></span><br><span class="line">Force stop service containers.</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -s, --signal string   SIGNAL to send to the container. (default <span class="string">&quot;SIGKILL&quot;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="logs"><code>logs</code></h4>
<p>查看日志</p>
<p>查看服务容器的输出。默认情况下，docker-compose
将对不同的服务输出使用不同的颜色来区分。可以通过 <code>--no-color</code>
来关闭颜色</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage:  docker compose logs [SERVICE...]</span><br><span class="line"></span><br><span class="line">View output from containers</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -f, --follow          Follow <span class="built_in">log</span> output.</span><br><span class="line">      --no-color        Produce monochrome output.</span><br><span class="line">      --no-log-prefix   Don<span class="string">&#x27;t print prefix in logs.</span></span><br><span class="line"><span class="string">      --since string    Show logs since timestamp (e.g. 2013-01-02T13:23:37Z) or relative (e.g. 42m for 42 minutes)</span></span><br><span class="line"><span class="string">      --tail string     Number of lines to show from the end of the logs for each container. (default &quot;all&quot;)</span></span><br><span class="line"><span class="string">  -t, --timestamps      Show timestamps.</span></span><br><span class="line"><span class="string">      --until string    Show logs before a timestamp (e.g. 2013-01-02T13:23:37Z) or relative (e.g. 42m for 42 minutes)</span></span><br></pre></td></tr></table></figure>
<p><code>pause</code></p>
<p>暂停一个容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage:  docker compose pause [SERVICE...]</span><br></pre></td></tr></table></figure>
<h4 id="port"><code>port</code></h4>
<p>打印某个容器端口映射的公共端口</p>
<p>选项：</p>
<ul>
<li><p><code>--protocol=proto</code> 指定端口协议，tcp（默认值）或者
udp。</p></li>
<li><p><code>--index=index</code>
如果同一服务存在多个容器，指定命令对象容器的序号（默认为 1）</p></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage:  docker compose port [options] [--] SERVICE PRIVATE_PORT</span><br><span class="line"></span><br><span class="line">Print the public port <span class="keyword">for</span> a port binding.</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">      --index int         index of the container <span class="keyword">if</span> service has multiple replicas (default 1)</span><br><span class="line">      --protocol string   tcp or udp (default <span class="string">&quot;tcp&quot;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="ps"><code>ps</code></h4>
<p>列出项目中目前的所有容器</p>
<p>选项：</p>
<ul>
<li><code>-q</code> 只打印容器的 ID 信息。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage:  docker compose ps [SERVICE...]</span><br><span class="line"></span><br><span class="line">List containers</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -a, --all                  Show all stopped containers (including those created by the run <span class="built_in">command</span>)</span><br><span class="line">      --format string        Format the output. Values: [pretty | json] (default <span class="string">&quot;pretty&quot;</span>)</span><br><span class="line">  -q, --quiet                Only display IDs</span><br><span class="line">      --services             Display services</span><br><span class="line">      --status stringArray   Filter services by status. Values: [paused | restarting | removing | running | dead | created | exited]</span><br></pre></td></tr></table></figure>
<h4 id="pull"><code>pull</code></h4>
<p>拉取服务依赖的镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage:  docker compose pull [SERVICE...]</span><br><span class="line">Pull service images</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">      --ignore-pull-failures   Pull what it can and ignores images with pull failures</span><br><span class="line">      --include-deps           Also pull services declared as dependencies</span><br><span class="line">  -q, --quiet                  Pull without printing progress information</span><br></pre></td></tr></table></figure>
<h4 id="push"><code>push</code></h4>
<p>推送服务依赖的镜像到Docker镜像仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage:  docker compose push [SERVICE...]</span><br><span class="line"></span><br><span class="line">Push service images</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">      --ignore-push-failures   Push what it can and ignores images with push failures</span><br></pre></td></tr></table></figure>
<h4 id="restart"><code>restart</code></h4>
<p>重启项目中的服务</p>
<p>选项：</p>
<ul>
<li><code>-t, --timeout TIMEOUT</code> 指定重启前停止容器的超时（默认为
10 秒）。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage:  docker compose restart</span><br><span class="line"></span><br><span class="line">Restart containers</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -t, --<span class="built_in">timeout</span> int   Specify a shutdown <span class="built_in">timeout</span> <span class="keyword">in</span> seconds (default 10)</span><br></pre></td></tr></table></figure>
<h4 id="rm"><code>rm</code></h4>
<p>格式为 <code>docker-compose rm [options] [SERVICE...]</code>。</p>
<p>删除所有（停止状态的）服务容器。推荐先执行
<code>docker-compose stop</code> 命令来停止容器。</p>
<p>选项：</p>
<ul>
<li><code>-f, --force</code>
强制直接删除，包括非停止状态的容器。一般尽量不要使用该选项。</li>
<li><code>-v</code> 删除容器所挂载的数据卷。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage:  docker <span class="built_in">rm</span> [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class="line"></span><br><span class="line">Remove one or more containers</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -f, --force     Force the removal of a running container (uses SIGKILL)</span><br><span class="line">  -l, --<span class="built_in">link</span>      Remove the specified <span class="built_in">link</span></span><br><span class="line">  -v, --volumes   Remove anonymous volumes associated with the container</span><br></pre></td></tr></table></figure>
<h4 id="run"><code>run</code></h4>
<p>在指定服务上执行一个命令</p>
<p>默认情况下，如果存在关联，则所有关联的服务将会被自动启动。除非这些服务已经在运行中。</p>
<p>该命令类似启动容器后运行指定的命令，相关卷、链接等等都将会按照配置自动创建。</p>
<p>两个不同点：</p>
<ul>
<li>给定命令将会覆盖原有的自动运行命令；</li>
<li>不会自动创建端口，以避免冲突。</li>
</ul>
<p>选项：</p>
<ul>
<li><p><code>-d</code> 后台运行容器。</p></li>
<li><p><code>--name NAME</code> 为容器指定一个名字。</p></li>
<li><p><code>--entrypoint CMD</code> 覆盖默认的容器启动指令。</p></li>
<li><p><code>-e KEY=VAL</code>
设置环境变量值，可多次使用选项来设置多个环境变量。</p></li>
<li><p><code>-u, --user=""</code> 指定运行容器的用户名或者
uid。</p></li>
<li><p><code>--no-deps</code> 不自动启动关联的服务容器。</p></li>
<li><p><code>--rm</code> 运行命令后自动删除容器，<code>d</code>
模式下将忽略。</p></li>
<li><p><code>-p, --publish=[]</code> 映射容器端口到本地主机。</p></li>
<li><p><code>--service-ports</code>
配置服务端口并映射到本地主机。</p></li>
<li><p><code>-T</code> 不分配伪 tty，意味着依赖 tty
的指令将无法运行。</p></li>
<li><p><code>--no-deps</code> 不自动启动关联的容器。</p></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage:  docker compose run [options] [-v VOLUME...] [-p PORT...] [-e KEY=VAL...] [-l KEY=VALUE...] SERVICE [COMMAND] [ARGS...]</span><br><span class="line"></span><br><span class="line">Run a one-off <span class="built_in">command</span> on a service.</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -d, --detach                Run container <span class="keyword">in</span> background and <span class="built_in">print</span> container ID</span><br><span class="line">      --entrypoint string     Override the entrypoint of the image</span><br><span class="line">  -e, --<span class="built_in">env</span> stringArray       Set environment variables</span><br><span class="line">  -i, --interactive           Keep STDIN open even <span class="keyword">if</span> not attached. (default <span class="literal">true</span>)</span><br><span class="line">  -l, --label stringArray     Add or override a label</span><br><span class="line">      --name string            Assign a name to the container</span><br><span class="line">  -T, --no-TTY                Disable pseudo-noTty allocation. By default docker compose run allocates a TTY</span><br><span class="line">      --no-deps               Don<span class="string">&#x27;t start linked services.</span></span><br><span class="line"><span class="string">  -p, --publish stringArray   Publish a container&#x27;</span>s port(s) to the host.</span><br><span class="line">      --quiet-pull            Pull without printing progress information.</span><br><span class="line">      --<span class="built_in">rm</span>                    Automatically remove the container when it exits</span><br><span class="line">      --service-ports         Run <span class="built_in">command</span> with the service<span class="string">&#x27;s ports enabled and mapped to the host.</span></span><br><span class="line"><span class="string">      --use-aliases           Use the service&#x27;</span>s network useAliases <span class="keyword">in</span> the network(s) the container connects to.</span><br><span class="line">  -u, --user string           Run as specified username or uid</span><br><span class="line">  -v, --volume stringArray    Bind mount a volume.</span><br><span class="line">  -w, --workdir string        Working directory inside the container</span><br></pre></td></tr></table></figure>
<h4 id="top"><code>top</code></h4>
<p>查看各个服务容器运行的进程</p>
<h4 id="unpause"><code>unpause</code></h4>
<p>恢复处于暂停状态的服务容器</p>
<h4 id="up"><code>up</code></h4>
<p>创建并启动容器</p>
<p>该命令将自动完成包括<strong>构建镜像，（重新）创建服务，启动服务，并关联服务相关容器</strong>的一系列操作。</p>
<p>默认情况下，<code>docker-compose up</code>启动的容器在前台，控制台将会同时打印所有容器的输出信息，可以很方便进行调试。通过<code>Ctrl-C</code>停止命令时，所有的容器将会停止。</p>
<p>通过<code>docker-compose up -d</code>将会在后台启动并运行所有的容器。</p>
<p>默认情况下，如果服务容器已经存在，<code>docker-compose</code>将会尝试停止容器，然后重新创建（保持使用volumes-from挂载的卷），以保证新启动的服务匹配<code>docker-compose.yml</code>文件的最新内容。</p>
<p>如果用户不希望容器被停止并重新创建，可以使用<code>docker-compose up --no-recreate</code>。这样将只会启动处于停止状态的容器，而忽略已经运行的服务。</p>
<p>如果用户只想重新部署某个服务，可以使用<code>docker-compose up --no-deps -d &lt;SERVICE_NAME&gt;</code>来重新创建服务并后台停止旧服务，启动新服务，并不会影响所依赖的服务。</p>
<p>选项：</p>
<p>选项：</p>
<ul>
<li><code>-d</code> 在后台运行服务容器。</li>
<li><code>--no-color</code>
不使用颜色来区分不同的服务的控制台输出。</li>
<li><code>--no-deps</code> 不启动服务所链接的容器。</li>
<li><code>--force-recreate</code> 强制重新创建容器，不能与
<code>--no-recreate</code> 同时使用。</li>
<li><code>--no-recreate</code> 如果容器已经存在了，则不重新创建，不能与
<code>--force-recreate</code> 同时使用。</li>
<li><code>--no-build</code> 不自动构建缺失的服务镜像。</li>
<li><code>-t, --timeout TIMEOUT</code> 停止容器时候的超时（默认为 10
秒）。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage:  docker compose up [SERVICE...]</span><br><span class="line"></span><br><span class="line">Create and start containers</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">      --abort-on-container-exit   Stops all containers <span class="keyword">if</span> any container was stopped. Incompatible with -d</span><br><span class="line">      --always-recreate-deps      Recreate dependent containers. Incompatible with --no-recreate.</span><br><span class="line">      --attach stringArray        Attach to service output.</span><br><span class="line">      --attach-dependencies       Attach to dependent containers.</span><br><span class="line">      --build                     Build images before starting containers.</span><br><span class="line">  -d, --detach                    Detached mode: Run containers <span class="keyword">in</span> the background</span><br><span class="line">      --exit-code-from string     Return the <span class="built_in">exit</span> code of the selected service container. Implies --abort-on-container-exit</span><br><span class="line">      --force-recreate            Recreate containers even <span class="keyword">if</span> their configuration and image haven<span class="string">&#x27;t changed.</span></span><br><span class="line"><span class="string">      --no-build                  Don&#x27;</span>t build an image, even <span class="keyword">if</span> it<span class="string">&#x27;s missing.</span></span><br><span class="line"><span class="string">      --no-color                  Produce monochrome output.</span></span><br><span class="line"><span class="string">      --no-deps                   Don&#x27;</span>t start linked services.</span><br><span class="line">      --no-log-prefix             Don<span class="string">&#x27;t print prefix in logs.</span></span><br><span class="line"><span class="string">      --no-recreate               If containers already exist, don&#x27;</span>t recreate them. Incompatible with --force-recreate.</span><br><span class="line">      --no-start                  Don<span class="string">&#x27;t start the services after creating them.</span></span><br><span class="line"><span class="string">      --quiet-pull                Pull without printing progress information.</span></span><br><span class="line"><span class="string">      --remove-orphans            Remove containers for services not defined in the Compose file.</span></span><br><span class="line"><span class="string">  -V, --renew-anon-volumes        Recreate anonymous volumes instead of retrieving data from the previous containers.</span></span><br><span class="line"><span class="string">      --scale scale               Scale SERVICE to NUM instances. Overrides the scale setting in the Compose file if present.</span></span><br><span class="line"><span class="string">  -t, --timeout int               Use this timeout in seconds for container shutdown when attached or when containers are already</span></span><br><span class="line"><span class="string">                                  running. (default 10)</span></span><br><span class="line"><span class="string">      --wait                      Wait for services to be running|healthy. Implies detached mode.</span></span><br></pre></td></tr></table></figure>
<h2 id="模板文件">模板文件</h2>
<p>Compose文件格式具有多个版本，其中版本和docker引擎的版本相关：</p>
<p><a
href="https://docs.docker.com/compose/compose-file/compose-file-v3/#compose-and-docker-compatibility-matrix">Compose
and Docker compatibility matrix</a></p>
<p>目前最新版是3.8，以此为例：</p>
<h3 id="demo">demo</h3>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.9&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:alpine</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;6379&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">frontend</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">      <span class="attr">update_config:</span></span><br><span class="line">        <span class="attr">parallelism:</span> <span class="number">2</span></span><br><span class="line">        <span class="attr">delay:</span> <span class="string">10s</span></span><br><span class="line">      <span class="attr">restart_policy:</span></span><br><span class="line">        <span class="attr">condition:</span> <span class="string">on-failure</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">postgres:9.4</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db-data:/var/lib/postgresql/data</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">backend</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">placement:</span></span><br><span class="line">        <span class="attr">max_replicas_per_node:</span> <span class="number">1</span></span><br><span class="line">        <span class="attr">constraints:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">&quot;node.role==manager&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">vote:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">dockersamples/examplevotingapp_vote:before</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;5000:80&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">frontend</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">      <span class="attr">update_config:</span></span><br><span class="line">        <span class="attr">parallelism:</span> <span class="number">2</span></span><br><span class="line">      <span class="attr">restart_policy:</span></span><br><span class="line">        <span class="attr">condition:</span> <span class="string">on-failure</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">result:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">dockersamples/examplevotingapp_result:before</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;5001:80&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">backend</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">update_config:</span></span><br><span class="line">        <span class="attr">parallelism:</span> <span class="number">2</span></span><br><span class="line">        <span class="attr">delay:</span> <span class="string">10s</span></span><br><span class="line">      <span class="attr">restart_policy:</span></span><br><span class="line">        <span class="attr">condition:</span> <span class="string">on-failure</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">worker:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">dockersamples/examplevotingapp_worker</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">frontend</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">backend</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">mode:</span> <span class="string">replicated</span></span><br><span class="line">      <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">labels:</span> [<span class="string">APP=VOTING</span>]</span><br><span class="line">      <span class="attr">restart_policy:</span></span><br><span class="line">        <span class="attr">condition:</span> <span class="string">on-failure</span></span><br><span class="line">        <span class="attr">delay:</span> <span class="string">10s</span></span><br><span class="line">        <span class="attr">max_attempts:</span> <span class="number">3</span></span><br><span class="line">        <span class="attr">window:</span> <span class="string">120s</span></span><br><span class="line">      <span class="attr">placement:</span></span><br><span class="line">        <span class="attr">constraints:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">&quot;node.role==manager&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">visualizer:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">dockersamples/visualizer:stable</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8080:8080&quot;</span></span><br><span class="line">    <span class="attr">stop_grace_period:</span> <span class="string">1m30s</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;/var/run/docker.sock:/var/run/docker.sock&quot;</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">placement:</span></span><br><span class="line">        <span class="attr">constraints:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">&quot;node.role==manager&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">frontend:</span></span><br><span class="line">  <span class="attr">backend:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">db-data:</span></span><br></pre></td></tr></table></figure>
<p>以上按照顶级键的字母顺序组织，反映了compose文件本身的结构。</p>
<h3 id="服务配置文件参考">服务配置文件参考</h3>
<p>默认文件路径是<code>./docker-compose.yml</code></p>
<blockquote>
<p>yaml和yml扩展名都可以，两者都能工作</p>
</blockquote>
<p>服务定义包含应用为该服务启动的每个容器的配置，就像命令行参数传递给<code>docker run</code>。同样，网络和卷的定义分别类似于<code>docker network create</code>和<code>docker volume create</code>.</p>
<p>与<code>docker run</code>Dockerfile指定的选项：<code>CMD</code>一样，默认情况下会读取<code>EXPOSE</code>
、<code>VOLUME</code>、<code>ENV</code>等，无需在<code>docker-compose.yml</code>中定义。</p>
<p>可以使用类似Bash的<code>$&#123;VARIABLE&#125;</code>语法在配置值中使用环境变量：参考<a
href="https://docs.docker.com/compose/compose-file/compose-file-v3/#variable-substitution">变量替换</a></p>
<h4 id="在docker-compose中使用gpu">在Docker Compose中使用GPU</h4>
<h5 id="旧版docker-compose">旧版docker compose</h5>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">test:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nvidia/cuda:10.2-base</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">nvidia-smi</span></span><br><span class="line">    <span class="attr">runtime:</span> <span class="string">nvidia</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="新版本">新版本</h5>
<p>使用指定数目的GPU</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">test:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nvidia/cuda:10.2-base</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">nvidia-smi</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">resources:</span></span><br><span class="line">        <span class="attr">reservations:</span></span><br><span class="line">          <span class="attr">devices:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">driver:</span> <span class="string">nvidia</span></span><br><span class="line">              <span class="attr">count:</span> <span class="number">1</span></span><br><span class="line">              <span class="attr">capabilities:</span> [<span class="string">gpu</span>]</span><br></pre></td></tr></table></figure>
<p>使用全部的GPU <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">test:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">tensorflow/tensorflow:latest-gpu</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">python</span> <span class="string">-c</span> <span class="string">&quot;import tensorflow as tf;tf.test.gpu_device_name()&quot;</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">resources:</span></span><br><span class="line">        <span class="attr">reservations:</span></span><br><span class="line">          <span class="attr">devices:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">capabilities:</span> [<span class="string">gpu</span>]</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言基础（一）文件操作</title>
    <url>/p/go-file/</url>
    <content><![CDATA[<p>本文主要介绍了Go语言中文件读写的相关操作。</p>
<p>关键词：<strong>golang</strong></p>
<span id="more"></span>
<h3 id="获得当前路径下的所有文件">获得当前路径下的所有文件</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">filenames, err := ioutil.ReadDir(<span class="string">&quot;./&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;读取文件夹失败, 错误: %s&quot;</span>, err.Error())</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, file := <span class="keyword">range</span> filenames &#123;</span><br><span class="line">   fmt.Println(file.Name())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="打开和关闭文件">打开和关闭文件</h3>
<h4 id="只读打开">只读打开</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只读打开</span></span><br><span class="line">file, err := os.Open(<span class="string">&quot;./main.go&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;打开文件失败, 错误: %s&quot;</span>, err.Error())</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> file.Close() <span class="comment">// defer注册文件关闭语句</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="读取文件">读取文件</h3>
<h4 id="file.read">file.Read()</h4>
<blockquote>
<p>基本使用</p>
</blockquote>
<p>函数原型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> Read(b []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>
<p>举例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  file, err := os.Open(<span class="string">&quot;main.go&quot;</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">defer</span> file.Close()</span><br><span class="line">  <span class="comment">// 一次只能读128字节</span></span><br><span class="line">  <span class="keyword">var</span> tmp = <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">128</span>) <span class="comment">// 开辟一个可以存放128字符的字节数组，存放读取的字符</span></span><br><span class="line">  n, err := file.Read(tmp)    <span class="comment">// n: 读数据的大小</span></span><br><span class="line">  <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;文件读完了&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;读取了%d个字符\n&quot;</span>, n)</span><br><span class="line">  fmt.Println(<span class="type">string</span>(tmp[:n]))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>循环读取</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	file, err := os.Open(<span class="string">&quot;main.go&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line">	<span class="comment">// 循环读取，每次读128</span></span><br><span class="line">	<span class="keyword">var</span> content []<span class="type">byte</span></span><br><span class="line">	<span class="keyword">var</span> tmp = <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">128</span>) <span class="comment">// 开辟一个可以存放128字符的字节数组，存放读取的字符</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		n, err := file.Read(tmp) <span class="comment">// n: 读数据的大小</span></span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;文件读完了&quot;</span>)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(err)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		content = <span class="built_in">append</span>(content, tmp[:n]...)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="type">string</span>(content))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="bufio">bufio</h4>
<blockquote>
<p>按行读取</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	file, err := os.Open(<span class="string">&quot;main.go&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line">	<span class="comment">// bufio读取</span></span><br><span class="line">	reader := bufio.NewReader(file) </span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		line, err := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>) <span class="comment">// 单引号, 返回string类型</span></span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(line) != <span class="number">0</span> &#123;</span><br><span class="line">				fmt.Println(line)</span><br><span class="line">			&#125;</span><br><span class="line">			fmt.Println(<span class="string">&quot;文件读完了&quot;</span>)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(err)</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Print(line)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ioutil.readfile">ioutil.Readfile()</h4>
<blockquote>
<p>直接调用了函数Os.Readfile()</p>
</blockquote>
<p><strong>这个方式最简单粗暴，在不考虑性能的情况下可以直接用这种方式</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	data, err := ioutil.ReadFile(<span class="string">&quot;main.go&quot;</span>) <span class="comment">// 返回[]byte类型</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="type">string</span>(data))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="文件写入">文件写入</h3>
<p><code>os.Openfile()</code>以指定方式打开文件，实现文件写入</p>
<p>函数原型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OpenFile</span><span class="params">(name <span class="type">string</span>, flag <span class="type">int</span>, perm FileMode)</span></span> (*File, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>
<p>打开文件的方式如下</p>
<table>
<thead>
<tr class="header">
<th>方式</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>O_RDONLY</td>
<td>只读方式打开文件</td>
</tr>
<tr class="even">
<td>O_WRONLY</td>
<td>只写方式打开文件</td>
</tr>
<tr class="odd">
<td>O_RDWR</td>
<td>读写方式打开文件</td>
</tr>
<tr class="even">
<td>O_APPEND</td>
<td>追加方式打开文件</td>
</tr>
<tr class="odd">
<td>O_CREATE</td>
<td>创建文件</td>
</tr>
<tr class="even">
<td>O_EXCL</td>
<td>和O_CREATE配合使用，创建文件时文件必须不存在</td>
</tr>
<tr class="odd">
<td>O_SYNC</td>
<td>打开文件用于同步IO</td>
</tr>
<tr class="even">
<td>O_TRUNC</td>
<td>打开文件时清空文件</td>
</tr>
</tbody>
</table>
<h4 id="wirte和wirtestring">Wirte和WirteString</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	file, err := os.OpenFile(<span class="string">&quot;1.txt&quot;</span>, os.O_WRONLY|os.O_CREATE, <span class="number">0644</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line">	str := <span class="string">&quot;HelloWorld&quot;</span></span><br><span class="line">	file.Write([]<span class="type">byte</span>(str)) <span class="comment">// 写[]byte</span></span><br><span class="line">	file.WriteString(str)   <span class="comment">// 写string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="buffo.newwirter">Buffo.NewWirter</h4>
<blockquote>
<p>带缓冲的读写器</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	file, err := os.OpenFile(<span class="string">&quot;1.txt&quot;</span>, os.O_WRONLY|os.O_CREATE, <span class="number">0644</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line">	writer := bufio.NewWriter(file)</span><br><span class="line">	str := <span class="string">&quot;HelloWorld&quot;</span></span><br><span class="line">	writer.WriteString(str) <span class="comment">// 写string到缓存</span></span><br><span class="line">	writer.Flush()          <span class="comment">// 缓存刷入磁盘</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ioutil.writefile">ioutil.WriteFile()</h4>
<blockquote>
<p>直接调用os.WriteFile(filename, data, perm)</p>
</blockquote>
<p>这种方式也是最简单粗暴</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	str := <span class="string">&quot;HelloWorld&quot;</span></span><br><span class="line">	err := ioutil.WriteFile(<span class="string">&quot;1.txt&quot;</span>, []<span class="type">byte</span>(str), <span class="number">0644</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="golang实现cat命令">golang实现cat命令</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cat</span><span class="params">(b *bufio.Reader)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		buf, err := b.ReadString(<span class="string">&#x27;\n&#x27;</span>) <span class="comment">// 注意是字符</span></span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			<span class="comment">// 读完了</span></span><br><span class="line">			fmt.Fprintf(os.Stdout, <span class="string">&quot;%s&quot;</span>, buf)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Fprintln(os.Stdout, buf)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	flag.Parse() <span class="comment">// 解析命令行参数</span></span><br><span class="line">	<span class="keyword">if</span> flag.NArg() == <span class="number">0</span> &#123;</span><br><span class="line">		cat(bufio.NewReader(os.Stdin))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 读取每个文件到终端</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; flag.NArg(); i++ &#123;</span><br><span class="line">		file, err := os.Open(flag.Arg(i))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Fprintf(os.Stdout, <span class="string">&quot;cat: %s: No such file or directory&quot;</span>, flag.Arg(i))</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		cat(bufio.NewReader(file))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>golang中迭代channel和array</title>
    <url>/p/how-to-iterate-channel-and-arrry-in-golang/</url>
    <content><![CDATA[<p>本文主要介绍如何在golang中迭代channel和array。</p>
<span id="more"></span>
<h2 id="range循环切片">range循环切片</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> key, index := <span class="keyword">range</span> []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; &#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;key = %d, index = %d\n&quot;</span>, key, index)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="range循环channel">range循环channel</h2>
<p>当channel关闭时<strong>自动退出循环</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> c := <span class="keyword">range</span> ch1 &#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;c: %v\n&quot;</span>, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通道取值">通道取值</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  data1, ok := &lt;-ch1</span><br><span class="line">  <span class="keyword">if</span> !ok &#123;</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">  data2, ok := &lt;-ch2</span><br><span class="line">  <span class="keyword">if</span> !ok &#123;</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;data1: %v, data2: %v\n&quot;</span>, data1, data2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="select多路复用">select多路复用</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> data := &lt;-ch1:</span><br><span class="line">    &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;data: %v\n&quot;</span>, data)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> &lt;-ch2:</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣链表基础之环形链表 II</title>
    <url>/p/linked-list-cycle-ii/</url>
    <content><![CDATA[<p>给定一个链表的头节点 <code>head</code>
，返回链表开始入环的第一个节点。 <em>如果链表无环，则返回
<code>null</code>。</em></p>
<span id="more"></span>
<p><strong>示例</strong></p>
<p><img data-src="circularlinkedlist.png" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3</span><br><span class="line">输出：Intersected at &#x27;8&#x27;</span><br><span class="line">解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。</span><br><span class="line">从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。</span><br><span class="line">在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br></pre></td></tr></table></figure>
<p><strong>思路</strong></p>
<p>使用快慢指针法，分别定义fast和slow指针，从头节点出发，fast指针每次移动两个节点，slow重镇每次移动一个节点，如果fast指针和slow指针在途中相遇，说明这个链表有环。</p>
<p>随后从头节点出发一个指针，从相遇节点也出发一个指针，这两个指针每次直走一个节点，那么当这两个指针相遇的时候就是环形入口的节点。</p>
<p><strong>代码</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">detectCycle</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">	<span class="keyword">var</span> slow, fast = head, head</span><br><span class="line">	<span class="keyword">for</span> fast != <span class="literal">nil</span> &amp;&amp; fast.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">		slow = slow.Next</span><br><span class="line">		fast = fast.Next.Next</span><br><span class="line">		<span class="keyword">if</span> fast == slow &#123;</span><br><span class="line">            <span class="comment">//  从head出发</span></span><br><span class="line">			<span class="keyword">var</span> index, index1 = fast, head</span><br><span class="line">			<span class="keyword">for</span> index != index1 &#123;</span><br><span class="line">				index = index.Next</span><br><span class="line">				index1 = index1.Next</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> index</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣链表基础之链表相交</title>
    <url>/p/intersection-of-two-linked-lists-lcci/</url>
    <content><![CDATA[<p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code>
，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回
<code>null</code> 。</p>
<span id="more"></span>
<p><strong>示例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3</span><br><span class="line">输出：Intersected at &#x27;8&#x27;</span><br><span class="line">解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。</span><br><span class="line">从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。</span><br><span class="line">在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br></pre></td></tr></table></figure>
<p><strong>思路</strong></p>
<p>设交集链表长c，链表1除交集的长度为a，链表2除交集的长度为b，有</p>
<ul>
<li>a + c + b = b + c + a</li>
<li>若无交集，则a + b = b + a</li>
</ul>
<p><img data-src="image-20220216162953801.png" /></p>
<p>两个cur结点分别指向headA和headB，然后依次向后迭代，当迭代到最后一个结点时，切换到另一个分支。若有交点，迭代a
+ c + b次后会迭代到<strong>交集所在的节点</strong>；若无交点，迭代a +
b次后会<strong>迭代到NULL节点</strong>，此时return
headA和headB任意节点皆可。</p>
<p><strong>代码</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getIntersectionNode</span><span class="params">(headA, headB *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">	curA, curB := headA, headB</span><br><span class="line">	<span class="keyword">for</span> curA != curB &#123;</span><br><span class="line">		<span class="keyword">if</span> curA != <span class="literal">nil</span> &#123;</span><br><span class="line">			curA = curA.Next</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			curA = headB</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> curB != <span class="literal">nil</span> &#123;</span><br><span class="line">			curB = curB.Next</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			curB = headA</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> curA</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣链表基础之删除链表的倒数第N个节点</title>
    <url>/p/remove-nth-node-from-end-of-list/</url>
    <content><![CDATA[<p>给你一个链表，删除链表的倒数第 <code>n</code>
个结点，并且返回链表的头结点。</p>
<span id="more"></span>
<p><strong>示例</strong></p>
<p><img data-src="remove_ex1.jpg" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5], n = 2</span><br><span class="line">输出：[1,2,3,5]</span><br></pre></td></tr></table></figure>
<p><strong>思路</strong></p>
<p>使用<strong>虚拟头节点</strong>。</p>
<p>如果要删除倒数第n个节点，让fast移动n步，然后让fast和slow同时移动，直到fast指向链表末尾。删掉slow所指向的节点就可以了。</p>
<p>实际操作中可以让fast先移动n+1步，然后让fast和slow同时移动，直到fast指向NULL，此时slow恰好指向待删除结点的上一个，此时执行删除结点的操作即可。</p>
<p><img data-src="image-20220215193937378.png" /></p>
<p><strong>代码</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fast先移动n+1步，然后让fast和slow同时移动</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeNthFromEnd</span><span class="params">(head *ListNode, n <span class="type">int</span>)</span></span> *ListNode &#123;</span><br><span class="line">	dummy := <span class="built_in">new</span>(ListNode)</span><br><span class="line">	dummy.Next = head</span><br><span class="line">	fast := dummy</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n+<span class="number">1</span>; i++ &#123;</span><br><span class="line">		fast = fast.Next</span><br><span class="line">	&#125;</span><br><span class="line">	slow := dummy</span><br><span class="line">	<span class="keyword">for</span> fast != <span class="literal">nil</span> &#123;</span><br><span class="line">		fast = fast.Next</span><br><span class="line">		slow = slow.Next</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> slow != <span class="literal">nil</span> &amp;&amp; slow.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">		slow.Next = slow.Next.Next</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dummy.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣链表基础之两两交换链表中的节点</title>
    <url>/p/swap-nodes-in-pairs/</url>
    <content><![CDATA[<p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p>
<span id="more"></span>
<p><strong>示例</strong></p>
<p><img data-src="swap_ex1.jpg" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2,3,4]</span><br><span class="line">输出：[2,1,4,3]</span><br></pre></td></tr></table></figure>
<p><strong>思路</strong></p>
<p>使用<strong>虚拟头节点</strong>。交换两个相邻元素。</p>
<p><img data-src="image-20220214194056147.png" /></p>
<p><strong>代码</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapPairs</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    dummy := <span class="built_in">new</span>(ListNode)</span><br><span class="line">    dummy.Next = head</span><br><span class="line">    cur := dummy</span><br><span class="line">    <span class="keyword">for</span> cur.Next != <span class="literal">nil</span> &amp;&amp; cur.Next.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">        tmp := cur.Next</span><br><span class="line">        tmp1 := cur.Next.Next.Next</span><br><span class="line"></span><br><span class="line">        cur.Next = cur.Next.Next</span><br><span class="line">        cur.Next.Next = tmp</span><br><span class="line">        cur.Next.Next.Next = tmp1</span><br><span class="line"></span><br><span class="line">        cur = cur.Next.Next</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.Next</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣链表基础之反转链表</title>
    <url>/p/everse-linked-list/</url>
    <content><![CDATA[<p>题目：给你单链表的头节点 <code>head</code>
，请你反转链表，并返回反转后的链表。</p>
<span id="more"></span>
<p><strong>示例</strong></p>
<p><img data-src="rev1ex1.jpg" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5]</span><br><span class="line">输出：[5,4,3,2,1]</span><br></pre></td></tr></table></figure>
<p><strong>思路</strong></p>
<p>首先定义一个<code>pre</code>指针指向<code>nil</code>,
然后定义一个<code>cur</code>指向头节点。然后开始翻转：</p>
<p>首先把<code>cur-&gt;next</code>节点用<code>tmp</code>指针保存一下，接下来改变<code>cur-next</code>的指向，将<code>cur-&gt;next</code>指向<code>pre</code>.</p>
<p>随后依次更新pre和cur。</p>
<p><img data-src="008eGmZEly1gnrf1oboupg30gy0c44qp.gif" /></p>
<p><strong>代码</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ListNode <span class="keyword">struct</span> &#123;</span><br><span class="line">	Val  <span class="type">int</span></span><br><span class="line">	Next *ListNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseList</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">	<span class="keyword">var</span> pre *ListNode</span><br><span class="line">	cur := head</span><br><span class="line">	<span class="keyword">for</span> cur != <span class="literal">nil</span> &#123;</span><br><span class="line">		tmp := cur.Next</span><br><span class="line">		cur.Next = pre</span><br><span class="line">		pre = cur</span><br><span class="line">		cur = tmp</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> pre</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣链表基础之移除链表元素</title>
    <url>/p/remove-linked-list-elements/</url>
    <content><![CDATA[<p>题目：给你一个链表的头节点 <code>head</code> 和一个整数
<code>val</code> ，请你删除链表中所有满足 <code>Node.val == val</code>
的节点，并返回 <strong>新的头节点</strong> 。</p>
<p>找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl,
numsl+1, ..., numsr-1, numsr]
，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p>
<span id="more"></span>
<p><strong>示例</strong></p>
<p><img data-src="removelinked-list.jpg" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2,6,3,4,5,6], val = 6</span><br><span class="line">输出：[1,2,3,4,5]</span><br></pre></td></tr></table></figure>
<p><strong>思路</strong></p>
<p>添加一个虚拟头节点，这样原链表的所有节点都可以按照统一的方式进行移除了。</p>
<p><img data-src="image-20220207150257390.png" /></p>
<p><strong>代码</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ListNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val <span class="type">int</span></span><br><span class="line">    Next *ListNode</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeElements</span><span class="params">(head *ListNode, val <span class="type">int</span>)</span></span> *ListNode &#123;</span><br><span class="line">    dummy := &amp;ListNode&#123;&#125;</span><br><span class="line">    dummy.Next = head</span><br><span class="line">    node := dummy</span><br><span class="line">    <span class="keyword">for</span> node.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> node.Next.Val == val&#123;</span><br><span class="line">            node.Next = node.Next.Next</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node = node.Next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣数组基础之双指针长度最小的子数组</title>
    <url>/p/minimum-size-subarray-sum/</url>
    <content><![CDATA[<p>题目：给定一个含有 n 个正整数的数组和一个正整数 target 。</p>
<p>找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl,
numsl+1, ..., numsr-1, numsr]
，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p>
<span id="more"></span>
<p><strong>示例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：target = 7, nums = [2,3,1,2,4,3]</span><br><span class="line">输出：2</span><br><span class="line">解释：子数组 [4,3] 是该条件下的长度最小的子数组</span><br></pre></td></tr></table></figure>
<p><strong>思路</strong></p>
<p><img data-src="双指针02.png" /></p>
<p><strong>代码</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &lt;= b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 双指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minSubArrayLen</span><span class="params">(target <span class="type">int</span>, nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	left, right := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">	<span class="keyword">var</span> sum <span class="type">int</span></span><br><span class="line">	<span class="keyword">var</span> ret <span class="type">int</span> = <span class="built_in">len</span>(nums) + <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> left &lt; <span class="built_in">len</span>(nums) &#123;</span><br><span class="line">		sum += nums[right]</span><br><span class="line">		<span class="comment">// fmt.Printf(&quot;sum: %v\n&quot;, sum)</span></span><br><span class="line">		<span class="keyword">if</span> sum &lt; target &#123;</span><br><span class="line">			right++</span><br><span class="line">			<span class="keyword">if</span> right &gt;= <span class="built_in">len</span>(nums) &#123;</span><br><span class="line">				left++</span><br><span class="line">				right = left</span><br><span class="line">				sum = <span class="number">0</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			ret = min(ret, right-left+<span class="number">1</span>)</span><br><span class="line">			<span class="comment">// fmt.Printf(&quot;ret: %v\n&quot;, ret)</span></span><br><span class="line">			left++</span><br><span class="line">			right = left</span><br><span class="line">			sum = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ret == <span class="built_in">len</span>(nums) + <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣数组基础之模拟螺旋矩阵Ⅱ</title>
    <url>/p/spiral-matrix-ii/</url>
    <content><![CDATA[<p>题目：给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到
<code>n2</code> 所有元素，且元素按顺时针顺序螺旋排列的
<code>n x n</code> 正方形矩阵 <code>matrix</code> 。</p>
<span id="more"></span>
<p><strong>示例</strong></p>
<p><img data-src="spiraln.jpg" /></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：[[1,2,3],[8,9,4],[7,6,5]]</span><br></pre></td></tr></table></figure>
<p><strong>思路</strong></p>
<ul>
<li><p>生成一个 n×n 空矩阵 mat，随后模拟整个向内环绕的填入过程：</p>
<ul>
<li>定义当前左右上下边界 l,r,t,b，初始值 num = 1，迭代终止值 tar = n *
n；</li>
<li>当 num &lt;= tar 时，始终按照 从左到右 从上到下 从右到左 从下到上
填入顺序循环，每次填入后：
<ul>
<li>执行 num += 1：得到下一个需要填入的数字；</li>
<li>更新边界：例如从左到右填完后，上边界 t += 1，相当于上边界向内缩
1。</li>
</ul></li>
</ul></li>
<li><p>使用num &lt;= tar而不是l &lt; r || t &lt;
b作为迭代条件，是为了解决当n为奇数时，矩阵中心数字无法在迭代过程中被填充的问题。</p>
<p><img data-src="ccff416fa39887c938d36fec8e490e1861813d3bba7836eda941426f13420759-Picture1-16439745911263.png" /></p></li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 螺旋矩阵 II</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateMatrix</span><span class="params">(n <span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">	<span class="comment">// 新建矩阵</span></span><br><span class="line">	<span class="keyword">var</span> ret = <span class="built_in">make</span>([][]<span class="type">int</span>, n)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(ret); i++ &#123;</span><br><span class="line">		ret[i] = <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 定义左右上下边界</span></span><br><span class="line">	<span class="keyword">var</span> left, right, top, bottom <span class="type">int</span> = <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span></span><br><span class="line">	<span class="keyword">var</span> begin <span class="type">int</span> = <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> begin &lt; n*n &#123;</span><br><span class="line">		<span class="comment">// 从左到右</span></span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; right; i++ &#123;</span><br><span class="line">			ret[top][i] = begin</span><br><span class="line">			begin++</span><br><span class="line">		&#125;</span><br><span class="line">		top++</span><br><span class="line">		<span class="comment">// 从上到下</span></span><br><span class="line">		<span class="keyword">for</span> i := top; i &lt; bottom; i++ &#123;</span><br><span class="line">			ret[i][right] = begin</span><br><span class="line">			begin++</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 从右到左</span></span><br><span class="line">		right--</span><br><span class="line">		<span class="keyword">for</span> i := right; i &gt;= <span class="number">1</span>; i-- &#123;</span><br><span class="line">			ret[bottom][i] = begin</span><br><span class="line">			begin++</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 从下到上</span></span><br><span class="line">		bottom--</span><br><span class="line">		<span class="keyword">for</span> i := bottom; i &gt;= <span class="number">1</span>; i-- &#123;</span><br><span class="line">			ret[i][left] = begin</span><br><span class="line">			begin++</span><br><span class="line">		&#125;</span><br><span class="line">		left++</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣数组基础之双指针有序数组的平方</title>
    <url>/p/minimum-size-subarray-sum/</url>
    <content><![CDATA[<p>题目：给你一个按 <strong>非递减顺序</strong> 排序的整数数组
<code>nums</code>，返回 <strong>每个数字的平方</strong>
组成的新数组，要求也按 <strong>非递减顺序</strong> 排序。</p>
<span id="more"></span>
<p><strong>示例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：target = 7, nums = [2,3,1,2,4,3]</span><br><span class="line">输出：2</span><br><span class="line">解释：子数组 [4,3] 是该条件下的长度最小的子数组。</span><br></pre></td></tr></table></figure>
<p><strong>思路</strong></p>
<p><img data-src="双指针03.png" /></p>
<p><strong>代码</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &lt;= b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minSubArrayLen</span><span class="params">(target <span class="type">int</span>, nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	left, right := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">	<span class="keyword">var</span> sum <span class="type">int</span></span><br><span class="line">	<span class="keyword">var</span> ret <span class="type">int</span> = <span class="built_in">len</span>(nums) + <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> left &lt; <span class="built_in">len</span>(nums) &#123;</span><br><span class="line">		sum += nums[right]</span><br><span class="line">		<span class="comment">// fmt.Printf(&quot;sum: %v\n&quot;, sum)</span></span><br><span class="line">		<span class="keyword">if</span> sum &lt; target &#123;</span><br><span class="line">			right++</span><br><span class="line">			<span class="keyword">if</span> right &gt;= <span class="built_in">len</span>(nums) &#123;</span><br><span class="line">				left++</span><br><span class="line">				right = left</span><br><span class="line">				sum = <span class="number">0</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			ret = min(ret, right-left+<span class="number">1</span>)</span><br><span class="line">			<span class="comment">// fmt.Printf(&quot;ret: %v\n&quot;, ret)</span></span><br><span class="line">			left++</span><br><span class="line">			right = left</span><br><span class="line">			sum = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ret == <span class="built_in">len</span>(nums) + <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣数组基础之双指针长度最小的子数组</title>
    <url>/p/minimum-size-subarray-sum-2/</url>
    <content><![CDATA[<p>题目：给定一个含有 n 个正整数的数组和一个正整数 target 。</p>
<p>找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl,
numsl+1, ..., numsr-1, numsr]
，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p>
<span id="more"></span>
<p><strong>示例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：target = 7, nums = [2,3,1,2,4,3]</span><br><span class="line">输出：2</span><br><span class="line">解释：子数组 [4,3] 是该条件下的长度最小的子数组</span><br></pre></td></tr></table></figure>
<p><strong>思路</strong></p>
<p>滑动窗口问题主要确定以下三点：</p>
<ul>
<li>窗口内是什么？</li>
<li>如何移动窗口的起始位置？</li>
<li>如何移动窗口的结束位置？</li>
</ul>
<p>本题中，<strong>窗口就是满足与其和≥s的长度最小的连续子数组</strong>。</p>
<p>窗口的起始位置如何移动：如果当前窗口的值大于s了，窗口就要向前移动了（也就是该缩小了）。</p>
<p>窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，窗口的起始位置设置为数组的起始位置就可以了。</p>
<p><img data-src="20210312160441942.png" /></p>
<p>滑动窗口的精髓就是<strong>根据当前子序列和大小的情况，不断调节子序列的起始位置</strong>，从而降低复杂度到O(n).</p>
<p><strong>代码</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &lt;= b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 滑动窗口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minSubArrayLen</span><span class="params">(target <span class="type">int</span>, nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="built_in">len</span>(nums) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span> <span class="comment">// 滑动窗口数值之和</span></span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span> <span class="comment">// 滑动窗口起始位置</span></span><br><span class="line">    <span class="keyword">var</span> subLength = <span class="number">0</span> <span class="comment">// 滑动窗口的长度</span></span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(nums); j++ &#123;</span><br><span class="line">        sum += nums[j]</span><br><span class="line">        <span class="keyword">for</span> target &lt;= sum &#123; <span class="comment">// 直到target大于和</span></span><br><span class="line">            subLength = (j - i + <span class="number">1</span>) <span class="comment">// 子序列长度</span></span><br><span class="line">            result = min(result, subLength) <span class="comment">// 取子序列长度和result最小值</span></span><br><span class="line">            sum -= num[i++] <span class="comment">// 滑动窗口不断收缩</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> result == <span class="built_in">len</span>(nums) + <span class="number">1</span>&#123; <span class="comment">// 此种情况下没有符合条件的子序列</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>golang LogAgent 项目实战（四）</title>
    <url>/p/LogAgent-project-action-in-golang-4/</url>
    <content><![CDATA[<p>本文主要记录了学习golang时做的一个项目：日志收集项目。</p>
<p><strong>关键词：日志收集项目</strong></p>
<span id="more"></span>
<h2 id="日志收集项目">日志收集项目</h2>
<h3 id="上次进度">上次进度</h3>
<ol type="1">
<li>kafka：消息队列</li>
<li>tailf：从文件里读取文件</li>
<li>go-ini：解析配置文件</li>
</ol>
<h3 id="为什么不用elk">为什么不用ELK？</h3>
<p>ELK：部署的时候比较麻烦，每一个filebeat都需要配置一个配置文件</p>
<p>使用etcd来管理被收集的日志项。</p>
<ul>
<li>每次logagent都会主动从etcd中拉取配置，免去了手动写配置项的麻烦；</li>
</ul>
<p><img data-src="image-20211130214306450.png" /></p>
<h2 id="etcd">etcd</h2>
<h3 id="etcd介绍">etcd介绍</h3>
<p>etcd是使用Go语言开发的一个开源的、高可用的分布式key-value存储系统，可以用于<strong>配置共享</strong>和<strong>服务注册发现</strong>。</p>
<p>类似的项目由zookeeper和consul。</p>
<p>etcd具有以下特点：</p>
<ul>
<li>完全复制：集群中的每个节点都可以使用完整的存档</li>
<li>高可用性：etcd可用于避免硬件的单点故障或者网络问题</li>
<li>一致性：每次读取都会返回跨多主机的最新写入</li>
<li>简单：包括了一个定义良好、面向用户的API（gRPC）</li>
<li>安全：实现了带有可选的客户端证书身份验证的自动化TLS</li>
<li>快速：每秒10000次写入的基准速度</li>
<li>可靠：使用Raft算法实现了强一致、高可用的服务存储目录
<ul>
<li><strong>Raft协议</strong>
<ol type="1">
<li>选举</li>
<li>日志复制机制</li>
<li>异常处理（脑裂）</li>
<li>zookeeper的zad协议的区别</li>
</ol></li>
<li><strong>etcd的watch是怎么实现的？</strong>
<ol type="1">
<li>etcd底层如何实现watch给客户端发通知的</li>
</ol></li>
</ul></li>
</ul>
<h3 id="etcd应用场景">etcd应用场景</h3>
<h4 id="服务注册发现">服务注册发现</h4>
<p>服务发现要解决的也是分布式系统常见的问题，即在同一个分布式集群中的进程或服务，要如何才能找到对方建立连接。</p>
<p>本质上说，服务发现就是想要了解集群中<strong>是否有进程在监听tcp或者udp端口，并且通过名字就可以查找和连接</strong>。</p>
<p><img data-src="image-20211203193827699.png" /></p>
<h4 id="配置中心">配置中心</h4>
<p>将一些配置信息放到etcd上进行集中管理。</p>
<p>通常的应用场景：应用在启动的时候主动从etcd获取一次配置消息，同时，在etcd节点上注册一个Watcher并等待，以后每次配置有更新的时候，etcd都会实时通知订阅者，以此达到获取最新配置信息的目的。</p>
<h4 id="分布式锁">分布式锁</h4>
<p>因为etcd使用Raft算法保持了数据的强一致性，某次操作存储到集群中的值必然是全局一致的，所有很容易实现分布式锁。锁服务有两种使用方式：一是保持独占，二是保持时序。</p>
<ul>
<li><strong>保持独占即所有获取锁的用户最终只有一个可以得到</strong>。etcd提供了一套实现分布式锁原子操作CAS(
CompareAndSwap)的API。通过设置<code>prevExist</code>值，可以保证在多个节点同时创建某个目录时，只有一个成功。创建成功的用户就可以认为是获得了锁。</li>
<li>控制时序，即所有获得锁的用户都会被安排执行。但是<strong>获得锁的顺序全局唯一，同时决定了执行顺序</strong>。etcd提供了一套API（自动创建有序键），对一个目录建值时指定为POST动作，这样etcd会自动在目录下生成一个当前最大的值为键，存储这个新的值（客户端编号）。同时还可以使用API按顺序列出当前目录下的键值。此时这些键的值就是客户的时序，而这些键存储的值可以是代表客户端的编号。</li>
</ul>
<p><img data-src="image-20211203195339151.png" /></p>
<h3 id="为什么用etcd而不用zookeeper">为什么用etcd而不用zookeeper？</h3>
<p>etcd实现的这些功能，zookeeper都能实现，那为什么要用etcd而不是直接使用zookeeper呢？</p>
<p>相较之下，zookeeper有以下缺点：</p>
<ol type="1">
<li>复杂。zookeeper的<strong>部署维护复杂</strong>，管理员需要掌握一系列的知识和技能；Paxos强一致性<strong>算法素来以复杂难懂而闻名于世</strong>；zookeeper的使用也比较复杂，需要安装客户端，而且只提供了<strong>Java和C语言</strong>的两种接口。</li>
<li>Java编写。Java本身偏向于<strong>重型应用</strong>，引入大量的依赖。而运维人员则普遍希望保持强一致、高可用的机器集群尽可能简单，维护起来不容易出错。</li>
<li><strong>发展缓慢</strong>。Apache基金会特有的"Apache
Way"在开源界饱受争议，其中一大原因就是由于基金会庞大的结构以及松散的管理导致项目发展缓慢。</li>
</ol>
<p>etcd作为一个后起之秀，其优点也很明显：</p>
<ol type="1">
<li>简单。使用go语言编写<strong>部署简单</strong>；使用HTTP作为<strong>接口使用简单</strong>；<strong>使用Raft算法保证强一致性便于用户理解。</strong></li>
<li><strong>数据持久化</strong>。etcd默认数据已更新就进行持久化。</li>
<li><strong>安全</strong>。etcd支持SSL客户端安全验证。</li>
</ol>
<p>etcd作为一个年轻的项目，既是一个优点也是一个缺点。优点是未来无限可能，缺点是无法的发哦大项目长时间使用的检验。</p>
<p>目前CoreOS、Kubernetes和CloudFoundry等知名项目均在生产环境使用了etcd，etcd值得去尝试。</p>
<h3 id="etcd架构">etcd架构</h3>
<p><img data-src="image-20211203201212153.png" /></p>
<p><img data-src="image-20211203201343566.png" /></p>
<h3 id="etcd集群">etcd集群</h3>
<p>etcd作为一个高可以键值存储系统，天生就是为集群化而设计的。由于Raft算法在做决策时需要多数节点的投票，所有etcd一般部署集群推荐奇数节点，推荐3，5，7个节点构成一个集群。</p>
<h4 id="搭建一个3节点集群实例">搭建一个3节点集群实例</h4>
<p><img data-src="image-20211203201817418.png" /></p>
<p><img data-src="image-20211203201903787.png" /></p>
<p><img data-src="image-20211203202157587.png" /></p>
<p><img data-src="image-20211203202209008.png" /></p>
<h3 id="etcd服务端">etcd服务端</h3>
<h4 id="文档">文档</h4>
<p>https://doczhcn.gitbook.io/etcd/index/index-1/configuration</p>
<h4 id="允许外网访问">允许外网访问</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> ETCD_LISTEN_CLIENT_URLS=<span class="string">&quot;http://0.0.0.0:2379&quot;</span></span><br><span class="line"><span class="built_in">export</span> ETCD_ADVERTISE_CLIENT_URLS=<span class="string">&quot;http://0.0.0.0:2379&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="etcd客户端">etcd客户端</h3>
<p>官方客户端：https://github.com/etcd-io/etcd</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get go.etcd.io/etcd/client/v3</span><br></pre></td></tr></table></figure>
<h4 id="实例">实例</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">	clientv3 <span class="string">&quot;go.etcd.io/etcd/client/v3&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		config clientv3.Config</span><br><span class="line">		client *clientv3.Client</span><br><span class="line">		err    <span class="type">error</span></span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 客户端配置</span></span><br><span class="line">	config = clientv3.Config&#123;</span><br><span class="line">		Endpoints:   []<span class="type">string</span>&#123;<span class="string">&quot;192.168.31.103:2379&quot;</span>&#125;,</span><br><span class="line">		DialTimeout: <span class="number">5</span> * time.Second,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 建立连接</span></span><br><span class="line">	client, err = clientv3.New(config)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;connent to etcd succeed&quot;</span>)</span><br><span class="line">	<span class="keyword">defer</span> client.Close()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 存</span></span><br><span class="line">	ctx, cancel := context.WithTimeout(context.Background(), time.Second)</span><br><span class="line">	_, err = client.Put(ctx, <span class="string">&quot;q1mi&quot;</span>, <span class="string">&quot;dsb&quot;</span>)</span><br><span class="line">	cancel() <span class="comment">// 立即释放资源</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 取</span></span><br><span class="line">	ctx, cancel = context.WithTimeout(context.Background(), time.Second)</span><br><span class="line">	resp, err := client.Get(ctx, <span class="string">&quot;q1mi&quot;</span>)</span><br><span class="line">	cancel() <span class="comment">// 立即释放资源</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, kv := <span class="keyword">range</span> resp.Kvs &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;key:%s value:%s\n&quot;</span>, <span class="type">string</span>(kv.Key), <span class="type">string</span>(kv.Value)) <span class="comment">// 索引键值对</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 哨兵：监视键的变化</span></span><br><span class="line">	rch := client.Watch(context.Background(), <span class="string">&quot;q1mi&quot;</span>) <span class="comment">// &lt;-chan watchResponse</span></span><br><span class="line">	<span class="keyword">for</span> wresp := <span class="keyword">range</span> rch &#123;</span><br><span class="line">		<span class="keyword">for</span> _, kv := <span class="keyword">range</span> wresp.Events &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;Type:%s Key:%s Value:%s\n&quot;</span>, kv.Type, kv.Kv.Key, kv.Kv.Value)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./etcd.exe</span><br><span class="line">connent to etcd succeed</span><br><span class="line">key:q1mi value:dsb</span><br><span class="line">Type:PUT Key:q1mi Value:111 <span class="comment"># 得到了键的变化</span></span><br></pre></td></tr></table></figure>
<h2 id="使用etcd优化项目代码">使用etcd优化项目代码</h2>
<p><img data-src="image-20211205131214769.png" /></p>
<p><img data-src="image-20211205131939536.png" /></p>
<p><img data-src="image-20211205134219893.png" /></p>
<p><img data-src="image-20211205153501064.png" /></p>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣数组基础之双指针移除元素</title>
    <url>/p/remove-element/</url>
    <content><![CDATA[<p>题目：给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于
val 的元素，并返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地
修改输入数组。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<span id="more"></span>
<p><strong>示例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,2,2,3], val = 3</span><br><span class="line">输出：2, nums = [2,2]</span><br><span class="line">解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>思路</strong></p>
<p>双指针法：通过一个快指针和慢指针完成两个for循环</p>
<p>定义两个Index，fastIndex在循环内更新，slowIndex在循环外更新。</p>
<p>当循环内的fastIndex迭代不到val，就更新slowIndex，把nums[fastIndex]赋值给nums[fastIndex]，而后slowIndex++；反之则什么也不做，此时fastIndex+1，slowIndex不动。</p>
<p><strong>示意图</strong></p>
<p><img data-src="双指针.png" /></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeElement</span><span class="params">(nums []<span class="type">int</span>, val <span class="type">int</span>)</span></span> <span class="type">int</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> slowIndex <span class="type">int</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> fastIndex := <span class="number">0</span>; fastIndex &lt; <span class="built_in">len</span>(nums);fastIndex++&#123;</span><br><span class="line">        <span class="keyword">if</span> nums[fastIndex] != val &#123;</span><br><span class="line">            nums[slowIndex] = nums[fastIndex]</span><br><span class="line">            slowIndex += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slowIndex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣数组基础之二分法</title>
    <url>/p/binary-search/</url>
    <content><![CDATA[<p>题目：给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值
target ，写一个函数搜索 nums 中的
target，如果目标值存在返回下标，否则返回 -1。</p>
<span id="more"></span>
<p><strong>示例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [-1, 0, 3, 5, 9, 12], target = 3</span><br><span class="line">输出: 2</span><br><span class="line">解释: 3 出现在 nums 中并且下标为 2</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>思路</strong></p>
<p>二分法区间一般有两种：左闭右闭[left, right]和左闭右开[left,
right)，这里以左闭右闭为例：</p>
<p>定义target在左闭右闭区间[left, right]内：</p>
<ul>
<li>循环要使用left&lt;=right的边界条件，因为left==right是有意义的；</li>
<li>当nums[mid]&gt;target时，此时nums[mid]一定不是target，故把right更新成mid-1;</li>
</ul>
<p><strong>示意图</strong></p>
<p><img data-src="新建位图图像.bmp" /></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    left, right := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> left &lt;= right &#123;</span><br><span class="line">        mid := left + (right-left) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &gt; target &#123;</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &lt; target &#123;</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>golang实现简易的tcp客户端和服务端</title>
    <url>/p/socket-in-golang/</url>
    <content><![CDATA[<p>在计算机通信领域，socket
被翻译为“套接字”，它是计算机之间进行<strong>通信</strong>的<strong>一种约定</strong>或一种方式。通过
socket
这种约定，一台计算机可以接收其他计算机的数据，也可以向其他计算机发送数据。</p>
<p>本文介绍如何使用golang实现socket通信。</p>
<span id="more"></span>
<h2 id="tcp">TCP</h2>
<h3 id="tcp服务端">TCP服务端</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bytes&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	listener, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;127.0.0.1:7890&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> listener.Close()</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		conn, err := listener.Accept()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 启用并发</span></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">			<span class="keyword">var</span> buffer bytes.Buffer</span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				<span class="keyword">var</span> buffarr = <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1</span>)</span><br><span class="line">				_, err := conn.Read(buffarr)</span><br><span class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="built_in">panic</span>(err)</span><br><span class="line">				&#125;</span><br><span class="line">				b := buffarr[<span class="number">0</span>]</span><br><span class="line">				<span class="comment">// 检测到消息终止符</span></span><br><span class="line">				<span class="keyword">if</span> b == <span class="string">&#x27;\t&#x27;</span> &#123;</span><br><span class="line">					<span class="keyword">break</span></span><br><span class="line">				&#125;</span><br><span class="line">				buffer.WriteByte(b)</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">			fmt.Println(<span class="string">&quot;get msg from client:&quot;</span>, buffer.String())</span><br><span class="line"></span><br><span class="line">		&#125;(conn)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="tcp客户端">TCP客户端</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bytes&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	conn, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;127.0.0.1:7890&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> buffer bytes.Buffer</span><br><span class="line">	buffer.WriteString(<span class="string">&quot;Hi, I am a client&quot;</span>)</span><br><span class="line">	<span class="comment">// 终止符</span></span><br><span class="line">	buffer.WriteByte(<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">	_, err = conn.Write(buffer.Bytes())</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="udp">UDP</h2>
<h3 id="udp服务端">UDP服务端</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	conn, err := net.ListenUDP(</span><br><span class="line">		<span class="string">&quot;udp&quot;</span>, &amp;net.UDPAddr&#123;</span><br><span class="line">			IP:   net.ParseIP(<span class="string">&quot;127.0.0.1&quot;</span>),</span><br><span class="line">			Port: <span class="number">7890</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line">	bytearray := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		n, _, err := conn.ReadFrom(bytearray)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(err)</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(<span class="string">&quot;get msg from client:&quot;</span>, <span class="type">string</span>(bytearray[:n]))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="udp客户端">UDP客户端</h3>
<p>```go package main</p>
<p>import ( "bytes" "net" )</p>
<p>func main() { conn, err := net.Dial("udp", "127.0.0.1:7890") if err
!= nil { panic(err) } defer conn.Close() var bytebuffer bytes.Buffer
bytebuffer.WriteString("hello, I am a udp client") _, err =
conn.Write(bytebuffer.Bytes()) if err != nil { panic(err) }<br />
}</p>
]]></content>
      <tags>
        <tag>golang</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker安装MySQL5.7</title>
    <url>/p/install-mysql5.7-in-docker/</url>
    <content><![CDATA[<p>为什么要在docker中安装mysql？</p>
<span id="more"></span>
<p>在docker中安装mysql可以随时启动另外的mysql服务端用于测试或者其他用途，缺点就是比较消耗资源，不过资源随时都能申请得到，毕竟世界加钱可及。</p>
<h3 id="安装docker">安装docker</h3>
<p>可以参考我的这一篇文章：<a
href="https://fly97.cn/p/docker-tutorial-01/">初探docker(一) | 个人随想
(fly97.cn)</a></p>
<h3 id="安装mysql容器">安装MySQL容器</h3>
<p>以官方的MySQL5.7为例：<a href="https://hub.docker.com/_/mysql">Mysql
- Official Image | Docker Hub</a></p>
<p>首先确保docker服务已经正常启动：</p>
<p>linux执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo service docker start</span><br></pre></td></tr></table></figure>
<p>笔者的系统是mac，因此打开<strong>Docker Destop</strong>即可。</p>
<h4 id="拉取镜像">拉取镜像</h4>
<p>拉取镜像前需要使用<code>docker login</code>登陆docker
hub，这里以MySQL5.7为例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull mysql:5.7</span><br></pre></td></tr></table></figure>
<h4 id="运行容器">运行容器</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --name mysql-5.7 \</span><br><span class="line">	-v /Users/wf09/develop/mysql/data:/var/lib/mysql \</span><br><span class="line">	-v /Users/wf09/develop/mysql/conf:/etc/mysql/conf.d \</span><br><span class="line">  -p 3306:3306 \</span><br><span class="line">  -d -e MYSQL_ROOT_PASSWORD=adminadmin \</span><br><span class="line">  mysql:5 \</span><br><span class="line">  --character-set-server=utf8mb4 \</span><br><span class="line">  --character_set_connection=utf8mb4 \</span><br><span class="line">  --character_set_client=utf8mb4 \</span><br><span class="line">  --character_set_results=character_set_results \</span><br><span class="line">  --collation-server=utf8mb4_unicode_ci \</span><br><span class="line">  --collation_connection=utf8mb4_unicode_ci</span><br><span class="line"></span><br><span class="line">  </span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li><code>-v</code>参数是挂载本地文件到容器内部，<code>/var/lib/mysql</code>是mysql默认的数据文件保存路径；<code>/etc/mysql/conf.d</code>是附加配置目录，该目录下的.cnf文件都会被读取并覆盖原有的配置；</li>
<li><code>-e</code>参数是为容器指定环境变量，<code>MYSQL_ROOT_PASSWORD</code>为容器指定密码，容器预设的环境变量可以在这里查看：<a
href="https://hub.docker.com/_/mysql">Docker Hub</a>；</li>
<li>最后的参数是指定字符集为<strong>utf8mb4</strong>，避免遇到mysql无法存放中文字符的问题。
<ul>
<li>查看当前数据库支持的字符集：<code>show variables like '%char%';</code></li>
</ul></li>
</ul>
<h3 id="设置mysql容器">设置MySQL容器</h3>
<h4 id="配置文件">配置文件</h4>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[client]</span></span><br><span class="line"><span class="attr">default-character-set</span>=utf8mb4</span><br><span class="line"></span><br><span class="line"><span class="section">[mysql]</span></span><br><span class="line"><span class="attr">default-character-set</span>=utf8mb4</span><br><span class="line"></span><br><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">character-set-server</span>=utf8mb4</span><br></pre></td></tr></table></figure>
<h4 id="允许外网访问">允许外网访问</h4>
<p>先进入容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -ti mysql-5.7 /bin/bash</span><br></pre></td></tr></table></figure>
<p>输入密码，连接mysql</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p</span><br></pre></td></tr></table></figure>
<p>修改表项</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update mysql.user set host=&#x27;%&#x27; where user=&#x27;root&#x27;;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>
<p>查看修改后的结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT USER,HOST FROM mysql.user;</span><br></pre></td></tr></table></figure>
<p>结果如下所示，说明修改成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT USER,HOST FROM mysql.user;</span><br><span class="line">+---------------+-----------+</span><br><span class="line">| USER          | HOST      |</span><br><span class="line">+---------------+-----------+</span><br><span class="line">| root          | %         |</span><br><span class="line">| mysql.session | localhost |</span><br><span class="line">| mysql.sys     | localhost |</span><br><span class="line">| root          | localhost |</span><br><span class="line">+---------------+-----------+</span><br><span class="line">4 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure>
<h4 id="导出表结构和表数据">导出表结构和表数据</h4>
<ol type="1">
<li><p>导出整个数据库结构和数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqldump -h localhost -uroot -p123456 database &gt; dump.sql</span><br></pre></td></tr></table></figure></li>
<li><p>导出单个数据表结构和数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqldump -h localhost -uroot -p123456  database table &gt; dump.sql</span><br></pre></td></tr></table></figure></li>
<li><p>导出整个数据库结构（不包含数据）</p></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqldump -h localhost -uroot -p123456  -d database &gt; dump.sql</span><br></pre></td></tr></table></figure>
<ol start="4" type="1">
<li>导出单个数据表结构（不包含数据）</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqldump -h localhost -uroot -p123456  -d database table &gt; dump.sql</span><br></pre></td></tr></table></figure>
<ol start="5" type="1">
<li>导入sql文件</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p123456 &lt; dump.sql</span><br></pre></td></tr></table></figure>
<h4 id="设置日志路径">设置日志路径</h4>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="comment"># 错误日志</span></span><br><span class="line"><span class="attr">log_error</span> = /var/log/mysql/error.log</span><br><span class="line"><span class="comment"># 查询日志</span></span><br><span class="line"><span class="attr">general_log</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">general_log_file</span> = /var/log/mysql/general.log</span><br><span class="line"><span class="comment"># 慢查询日志</span></span><br><span class="line"><span class="attr">slow_query_log</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">slow_query_log_file</span> = /var/log/mysql/slow.log</span><br><span class="line"><span class="comment"># 同步写binlog</span></span><br><span class="line"><span class="attr">log_bin_index</span> = /var/log/mysql/bin</span><br><span class="line"><span class="attr">max_binlog_size</span> = <span class="number">4</span>M</span><br><span class="line"><span class="attr">sync_binlog</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="使用docker-compose.yml">使用docker-compose.yml</h3>
<p>废话不多说直接上干货</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;1&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:5</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_ROOT_PASSWORD=ff143253-f1dd-266f-2a4b-cdb747c31150</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./mysql/conf:/etc/mysql/conf.d</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./mysql/data:/var/lib/mysql</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./mysql/sql:/root/sql</span></span><br></pre></td></tr></table></figure>
<h3 id="后记">后记</h3>
<h4 id="权限问题">权限问题</h4>
<p>由于一些原因需要把mysql容器中的日志映射出来，但是在操作的时候遇到了以下问题：</p>
<p><img data-src="image-20220315193804894.png" /></p>
<p>根据一些“高人博客”的指点，在Dockerfile做了以下修改：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> mysql:<span class="number">5</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">chown</span> -R mysql:mysql /var/log/mysql</span></span><br></pre></td></tr></table></figure>
<p>上述指令的含义是将容器中的 <code>/var/log/mysql</code>
目录的所有者的用户和用户组修改为容器的内置用户<code>mysql:mysql</code></p>
<p>仍旧失败，经过一翻查找，发现了原因，这里就不贴原文了，大致意思是：</p>
<p><strong>容器中的<code>/var/log/mysql</code>这个目录一旦被映射到宿主机，Dockerfile中的命令就对它失去了作用</strong></p>
<p>问题的根本原因在于，容器中的mysql用户没有写<code>/var/log/mysql</code>目录的权限，所有才会出现<strong><code>Permission denied</code></strong>.</p>
<p>换一个思路，既然容器中的mysql用户没有写<code>/var/log/mysql</code>目录的权限，那么找一个有权限的文件写不就好了吗？</p>
<p>于是将日志文件夹设置为<code>/tmp/mysqlog</code>不就可以正常读写了吗？<code>/tmp</code>目录下应该所有用户都有相关权限吧。</p>
<p>一顿操作以后，又发现了问题：</p>
<p><strong>映射出来的文件，我本地用户竟然无法读写！！竟然需要root用户才可以读写！</strong></p>
<p>经过查找，发现了问题所在：</p>
<p><strong>mysql容器运行的用户是mysql，uid是999，而本地创建的默认用户uid是1000。换句话说，映射出来的文件的所有者不是你，是容器中的uid为999的用户！！</strong></p>
<h4 id="解决方案">解决方案</h4>
<p>将映射文件夹的所有者修改为999（uid），所在用户组修改为1000（uid），用户组也可以更改为当前目录下的用户名。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">chown</span> -R 999:1000 *</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>docker</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>golang LogAgent 项目实战（三）</title>
    <url>/p/LogAgent-project-action-in-golang-3/</url>
    <content><![CDATA[<p>本文主要记录了学习golang时做的一个项目：日志收集项目。</p>
<p><strong>关键词：日志收集项目</strong></p>
<span id="more"></span>
<h2 id="架构图">架构图</h2>
<p><img data-src="image-20211130214306450.png" /></p>
<h3 id="logagent工作流程">LogAgent工作流程</h3>
<h4 id="读日志tailf第三方库">读日志（<code>tailf</code>第三方库）</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fileName := <span class="string">&quot;./my.log&quot;</span></span><br><span class="line">	config := tail.Config&#123;</span><br><span class="line">		ReOpen:    <span class="literal">true</span>,                                 <span class="comment">// 重新打开重新创建的文件(失败了会尝试重新读取)</span></span><br><span class="line">		Follow:    <span class="literal">true</span>,                                 <span class="comment">// 继续寻找新行 (tail -f)</span></span><br><span class="line">		Location:  &amp;tail.SeekInfo&#123;Offset: <span class="number">0</span>, Whence: <span class="number">2</span>&#125;, <span class="comment">// 从哪个地方开始读取</span></span><br><span class="line">		MustExist: <span class="literal">false</span>,                                <span class="comment">// 日志文件是否必须存在</span></span><br><span class="line">		Poll:      <span class="literal">true</span>,                                 <span class="comment">// 轮询文件更改而不是使用inotify</span></span><br><span class="line">	&#125;</span><br><span class="line">	tails, err := tail.TailFile(fileName, config)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;tail file failed, err: %v&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		line *tail.Line</span><br><span class="line">		ok   <span class="type">bool</span></span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		line, ok = &lt;-tails.Lines</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;tail file close reopen, finename :%s\n&quot;</span>, tails.Filename)</span><br><span class="line">			time.Sleep(time.Second)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(<span class="string">&quot;line: &quot;</span>, line.Text)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="往kafka里写日志">往Kafka里写日志</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基于sarama第三方库开发kafka client</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	config := sarama.NewConfig()</span><br><span class="line">	<span class="comment">// tailf包使用</span></span><br><span class="line">	config.Producer.RequiredAcks = sarama.WaitForAll          <span class="comment">//发送完数据需要等待follow回复ack</span></span><br><span class="line">	config.Producer.Partitioner = sarama.NewRandomPartitioner <span class="comment">// 先选出一个partition</span></span><br><span class="line">	config.Producer.Return.Successes = <span class="literal">true</span>                   <span class="comment">// 成功交付的消息将在success channel中返回</span></span><br><span class="line">	<span class="comment">// 构造一个消息</span></span><br><span class="line">	msg := &amp;sarama.ProducerMessage&#123;&#125;</span><br><span class="line">	msg.Topic = <span class="string">&quot;web_log&quot;</span></span><br><span class="line">	msg.Value = sarama.StringEncoder(<span class="string">&quot;this is a test log&quot;</span>)</span><br><span class="line">	<span class="comment">// 链接kafka</span></span><br><span class="line">	client, err := sarama.NewSyncProducer([]<span class="type">string</span>&#123;<span class="string">&quot;192.168.31.103:9092&quot;</span>&#125;, config)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;producer closed, err :&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> client.Close()</span><br><span class="line">	<span class="comment">// 发送消息</span></span><br><span class="line">	pid, offset, err := client.SendMessage(msg)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;send msg failed, err:&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;pid: %v, offset:     %v\n&quot;</span>, pid, offset)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="kafka和zookeeper">Kafka和zookeeper</h4>
<h4 id="tail介绍">tail介绍</h4>
<h3 id="第一版程序">第一版程序</h3>
<p><a
href="https://github.com/flyzstu/logAgent/commit/4bd7e5ba6ba138958ae8dd2b030a7d96810709f9">第一版代码</a></p>
<p><img data-src="image-20211201205643407.png" /></p>
<p>设计包的入口函数时，要考虑上面的设计模式。</p>
<h3 id="第二版程序">第二版程序</h3>
<p><a
href="https://github.com/flyzstu/logAgent/commit/a70343ffd668c059b4aabdecbaf518a64b9e22fa">第二版代码</a></p>
<p>读取配置文件版本的logAgent</p>
<h4 id="go-ini库的使用">go-ini库的使用</h4>
<p><a href="https://github.com/go-ini/ini">go-ini</a></p>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣每日一题之完美数</title>
    <url>/p/perfect-number/</url>
    <content><![CDATA[<p>对于一个正整数，如果除了它和它自身以外的所有<strong>正因子</strong>相等，我们称他为完美数。</p>
<p>给定一个整数，如果是完美数，返回<code>true</code>，否则返回<code>false</code></p>
<span id="more"></span>
<p>示例 1：</p>
<p>输入：num = 28 输出：true 解释：28 = 1 + 2 + 4 + 7 + 14 1, 2, 4, 7,
和 14 是 28 的所有正因子。</p>
<p>示例 2：</p>
<p>输入：num = 6 输出：true</p>
<p>示例 3：</p>
<p>输入：num = 496 输出：true</p>
<h2 id="方法一枚举">方法一：枚举</h2>
<p>枚举<code>num</code>
的所有真因子，累加所有真因子之和，记作<code>sum</code>。若<code>sum=num</code>则返回<code>true</code>，否则返回<code>false</code>.</p>
<p>在枚举时，只需要枚举不超过$ <span
class="math inline">\(的数。这是因为如果\)</span>num<span
class="math inline">\(有一个大于\)</span> <span
class="math inline">\(的因数\)</span>d<span
class="math inline">\(，那么它一定有一个小于\)</span> $的因数 <span
class="math inline">\(frac{num}{d}\)</span>.</p>
<p>在枚举时，若能找到一个因数<span
class="math inline">\(d\)</span>，那么就找到了因数<span
class="math inline">\(frac{num}{d}\)</span>.</p>
<p>当<span class="math inline">\(d \\times
d=num\)</span>时，这两个因数相同，此时不能重复计算。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkPerfectNumber</span><span class="params">(num <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> num == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> sum <span class="type">int</span> = <span class="number">1</span> <span class="comment">// 和从1开始</span></span><br><span class="line">    <span class="keyword">for</span> d := <span class="number">2</span>; d * d &lt;= num; d ++ &#123;</span><br><span class="line">        <span class="keyword">if</span> num % d == <span class="number">0</span>&#123;</span><br><span class="line">            sum += d</span><br><span class="line">            <span class="keyword">if</span> d * d &lt; num &#123;</span><br><span class="line">                sum += num /d</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum == num</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>golang LogAgent 项目实战（二）</title>
    <url>/p/LogAgent-project-action-in-golang-2/</url>
    <content><![CDATA[<p>本文主要记录了学习golang时做的一个项目：日志收集项目。</p>
<p><strong>关键词：日志收集项目</strong></p>
<span id="more"></span>
<h2 id="消息队列的通信模型">消息队列的通信模型</h2>
<h3 id="点对点模式">点对点模式</h3>
<p>消息生产者生产消息发送到queue里，然后消息消费者从queue中取出并且消费消息。一条消息被消费以后，queue中就没有了，不存在重复消费。</p>
<h3 id="发布订阅模式">发布订阅模式</h3>
<p>消息发布者（发布）将消息发布到topic中，同时有多个消费消息者（订阅）消费该消息。</p>
<p>和点对点方式不同，发布到topic的消息被所有订阅者消费（类似于关注了微信公众号的人都能收到推送的文章）。</p>
<p>补充：发布订阅模式下，放发布者消息量很大时，显然单个订阅者的处理能力是不足的，实际上现实场景中是<strong>多个订阅者节点组成一个订阅组</strong>负载均衡消费topic消息即<strong>分组订阅</strong>，这样订阅者很容易实现消费能力线性扩展。</p>
<p>对于不同的消息订阅者，可以看作是一个topic下有多个Queue，每个Queue是点对点的方式，Queue之间是发布订阅方式。</p>
<h2 id="kafka">kafka</h2>
<p>Apache Kafka由著名社交公司LinkdIn开发，
最初是被设计用来解决Linkedin公司内部海量日志传输等问题。</p>
<p>kafka实验Scala语言编写，于2011年开源并进入Apache孵化器，于2012年10月正式毕业，现为Apach顶级项目。</p>
<h3 id="介绍">介绍</h3>
<p>Kafka是一个分布式数据流平台，可以运行在单个服务器上，也可以在多台服务器上部署行程集群。它提供了发布和订阅功能，使用者可以发送数据到Kafka，也可以从Kafka中读取数据（以便进行后续的处理）。</p>
<p>Kafka 具有高吞吐、低延迟、高容错等特点。</p>
<p><img data-src="image-20211201141121142.png" /></p>
<ul>
<li><strong>Producer</strong>：Producer即生产者，消息的生产者，是消息的入口。</li>
<li><strong>kafka cluster</strong>：kafka集群，一台或者多台服务器组成
<ul>
<li><strong>Broker</strong>：Broker是指部署了Kafka实例的服务器节点。每个服务器上由一个或者多个Kafka的实例。姑且将每个broker对应一台服务器，每个Kafka集群里的broker都有一个不重复的编号，如图中的broker-0、broker-1等。</li>
<li><strong>Topic</strong>：消息的主题，可以理解为消息的分类，kafka的数据就保存在topic。每个broker上都可以创建多个topic。实际应用中通常是一个业务线创建一个topic。</li>
<li><strong>Partition</strong>：Topic的分区，每个topic可以由多个分区，分区的作用是做负载，提高kafka的吞吐量。同一个topic在不同的分区的数据是不重复的，partition的表现形式就是一个个的文件夹。</li>
<li><strong>Replication</strong>：每一个分区在不同的Broker上都有副本，副本的作用是做备胎。当主分区（Leader）宕机时会重新选择一个备胎（Follower）上位，成为Leader。在Kafka中绝对副本的最大数量是10个，且副本的数量不能大于Broker的数量，follower和leader<strong>绝对是在不同的机器</strong>，<strong>同一机器对同一个分区也只能存放一个副本</strong>（包括自己）。</li>
</ul></li>
</ul>
<h3 id="工作流程">工作流程</h3>
<p>Producer是生产者，是数据的入口，Producer在写入数据的时候会把数据写入到<strong>leader</strong>中，不会将数据直接写入follower！</p>
<p><img data-src="image-20211201144116325.png" /></p>
<ol type="1">
<li>生产者从Kafka集群中获取分区leader信息</li>
<li>生产者将消息发送给leader</li>
<li>leader将消息写入本地磁盘</li>
<li>follower从leader拉取数据
：<strong>生产者把数据写入Leader之后，Leader其他的副本主动从Leader中拉取数据</strong></li>
<li>follower将消息写入本地磁盘以后向leader发送ACK（回复确认）</li>
<li>leader收到所有的follower的ACK后向生产者发送ACK（回复确认）</li>
</ol>
<h3 id="选择partition的原则">选择Partition的原则</h3>
<p>如果某个topic有多个partition，producer怎么知道应该将数据发给那个partition呢？</p>
<p>Kafka中有以下几个原则：</p>
<ul>
<li>partition在写入的时候可以指定写入的partition，如果有指定，则写入对应的partition；</li>
<li>如果在写入的时候没有指定partition，但是又设置了数据的key，则会根据key的值hash出一个partition；</li>
<li>如果既没有指定partition，有没有设置key，则会采用轮询方式，即每次取一小段时间的数据写入某个partition，下一小段的时间写入下一个partition。</li>
</ul>
<h3 id="ack应答机制">ACK应答机制</h3>
<p>producer在Kafka写入消息的时候，可以设置参数来确定是否确认kafka接收到数据，这个参数可设置为<strong>0、1、all</strong>。</p>
<ul>
<li>0代表producer往集群发送数据不需要等到集群返回，不确保消息发送成功，安全性最低但是效率最高；</li>
<li>1代表producer往集群发送数据只要leader应答就可以发送下一条，只确保leader发送成功。</li>
<li>all代表producer往集群发送数据需要所有的follower都完成从leader的同步才会发送下一条，确保leader发送成功和所有的副本都完成备份。安全性最高，但是效率最低。</li>
</ul>
<p><strong>注意：若往不存在的topic写数据，kafka会自动创建topic，partition和replication的数量的默认配置都是1。</strong></p>
<h3 id="topic和数据日志">Topic和数据日志</h3>
<p><code>topic</code>是统一类别的消息记录（record）的集合。
在Kafka中，一个主题通常有多个订阅者，对于每个主题，kafka集群维护了一个分区数据日志文件结构如下：</p>
<p><img data-src="image-20211201152943721.png" style="zoom: 33%;" /></p>
<p>每个partition都是一个有序而且不可变的消息记录集合，当新的数据写入时，就被追加到partition的末尾。在每个partition中，每条消息都会被分配一个顺序的唯一标识，这个表示被称为offset，<strong>即偏移量</strong>
。</p>
<ul>
<li><strong>Kafka只保证在同一个partition内部消息是有序的，在不同partition之间，不能保证消息有序。</strong></li>
</ul>
<p>顺序读取，所以读取更快。</p>
<p>Kafka可以配置一个保留期限，用来标识日志会在Kafka集群中保留多长时间，Kafka集群回保留在保留期限内所以被发布的消息，不管这些消息是否被消费过。比如保留期限设置为两天，那么数据被发布到Kafka两天以内，所有的数据都可以被消费。当超过两天，这些数据都会被清空，一边为后续的数据腾出空间。由于kafka会将数据进行持久化存储（即写入到硬盘上），所以保留的数据大小可以设置为一个比较大的值。</p>
<h3 id="partition结构">Partition结构</h3>
<p>Partition在服务器上的表现形式就是一个一个的文件夹，每个partition的文件夹下会有多组segment文件，每组segment文件又包含<code>.index</code>文件，<code>.log</code>文件和<code>.timeindex</code>文件三个文件，其中<code>.log</code>文件是实际存储message的地方，而<code>.index</code>和<code>.timeindex</code>文件为索引文件，用于检索消息。</p>
<h3 id="消费数据">消费数据</h3>
<p>多个消费者实例可以组成一个消费者组，并用一个便签来标识这个消费者组。一个消费者组的不同消费者实例可以运行在不同的进程甚至不同的个服务器上。</p>
<ul>
<li>如果所有的消费者实例都在同一个消费者组中，那么消息记录会被很好的均衡发送到每个消费者实例。</li>
<li>如果所有的消费者实例都在不同的消费者组，那么每一条纤细记录会被广播到每一个消费者实例。</li>
</ul>
<p><img data-src="image-20211201154851552.png" /></p>
<ul>
<li>同一消费者组中，每个消费者实例可以消费多个分区；</li>
<li>每个分区最多只能被消费者组中的一个实例消费；</li>
</ul>
<h3 id="总结关键点">总结关键点</h3>
<ol type="1">
<li>Kafka集群的架构
<ol type="1">
<li>broker</li>
<li>topic</li>
<li>partition：分区，把同一个topic分成不同的分区，提高负载
<ol type="1">
<li>leader：分区的主节点</li>
<li>follower：分区的从节点</li>
</ol></li>
<li>Consumer Group：消费组</li>
</ol></li>
<li>生产者往Kafka发送数据的流程（6步）</li>
<li>选择分区的模式（三种）
<ol type="1">
<li>指定分区写</li>
<li>指定key，kafka根据key做hash决定写分区</li>
<li>轮询方式</li>
</ol></li>
<li>生产者往kafka发送数据的模式
<ol type="1">
<li>0：把数据发哦是那个给leader就成功，效率最高，安全性最低</li>
<li>1：把数据发送给leader，等待leader回ack</li>
<li>all：把数据发送给leader，follow从leader拉取数据成功后b回复ack给leader，leader收到所有的follower都回复ack给leader以后，生产者才会发送下一条数据</li>
</ol></li>
<li>分区存储文件的原理</li>
<li>为什么Kafka快</li>
<li>消费者组消费数据的原理<strong>（参考官方文档）</strong></li>
</ol>
<h2 id="zookeeper">Zookeeper</h2>
<p>zookeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby的一个开源实现，是集群的管理者，监视着集群中各个系欸但的状态，并根据节点提交的反馈进行下一步合理操作。最终将简单易用的接口和性能高效、功能稳定的系统提供给用户。</p>
<p><img data-src="image-20211201190723113.png" /></p>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣每日一题之适龄的朋友</title>
    <url>/p/friends-of-appropriate-ages/</url>
    <content><![CDATA[<p>在社交媒体网站上有 n 个用户。给你一个整数数组 ages ，其中 ages[i]
是第 i 个用户的年龄。</p>
<p>如果下述任意一个条件为真，那么用户 x 将不会向用户 y（x !=
y）发送好友请求：</p>
<ul>
<li>age[y] &lt;= 0.5 * age[x] + 7</li>
<li>age[y] &gt; age[x]</li>
<li>age[y] &gt; 100 &amp;&amp; age[x] &lt; 100 否则，x 将会向 y
发送一条好友请求。</li>
</ul>
<p>注意，如果 x 向 y 发送一条好友请求，y 不必也向 x
发送一条好友请求。另外，用户不会向自己发送好友请求。</p>
<p>返回在该社交媒体网站上产生的好友请求总数。</p>
<span id="more"></span>
<p>示例 1：</p>
<p>输入：ages = [16,16] 输出：2 解释：2 人互发好友请求。</p>
<p>示例 2：</p>
<p>输入：ages = [16,17,18] 输出：2 解释：产生的好友请求为 17 -&gt; 16
，18 -&gt; 17</p>
<p>示例 3：</p>
<p>输入：ages = [20,30,100,110,120] 输出：3 解释：产生的好友请求为 110
-&gt; 100 ，120 -&gt; 110 ，120 -&gt; 100</p>
<h2 id="方法一排序双指针">方法一：排序+双指针</h2>
<p>观察题目中给出的三个条件：</p>
<p><img data-src="image-20211228131642378.png" /></p>
<p>可知条件3是蕴含条件2中的，即如果满足条件3那么也就满足条件2。因此当条件12均不满足时，用户x就会向用户y发送好友请求。</p>
<p>用户y需要满足： <span class="math display">\[
0.5 \times ages[x]+7 &lt; ages[y] \leq age[x]
\]</span> 当<span class="math inline">\(age[x] \leq
14\)</span>时，不存在满足要求的ages[y]，因此我们只需要考虑<span
class="math inline">\(ages[y] \geq
15\)</span>的情况，此时满足要求的<span
class="math inline">\(ages[y]\)</span>的范围：<span
class="math inline">\((0.5 \times ages[x]+7, age[x]]\)</span>。</p>
<p>当<span
class="math inline">\(age[x]\)</span>增加时，上述区间的左右边界均<strong>单调递增</strong>，因此如果我们将数组的<span
class="math inline">\(ages\)</span>进行升序排序，那么就可以在遍历<span
class="math inline">\(ages[x]\)</span>的同时，使用两个指针left和right维护满足要求的左右边界。当x向后移动一个位置时：</p>
<ul>
<li>如果左边界指针left指向的元素<strong>不满足</strong><span
class="math inline">\(ages[left] &gt; 0.5 \ times ages[x] +
7\)</span>，那么就将左边界向右移动一个位置；</li>
<li>如果右边界指针right指向的下一个元素<strong>满足</strong><span
class="math inline">\(ages[right+1] \geq
ages[x]\)</span>，那么就将右边界向右移动一个位置；</li>
</ul>
<p>这样一来，<span class="math inline">\([left,
right]\)</span>就是满足要求的y的下标。需要注意的是，<span
class="math inline">\(x\)</span>本身一定在<span
class="math inline">\([left, right]\)</span>区间内，因此<span
class="math inline">\(x\)</span>发送的好友请求数，即为<span
class="math inline">\([left, right]\)</span>区间的长度-1.</p>
<p>我们将每一个x对应的<span class="math inline">\([left,
right]\)</span>区间的长度减去1进行累加，就可以得到最后的答案。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numFriendRequests</span><span class="params">(ages []<span class="type">int</span>)</span></span> (ans <span class="type">int</span>) &#123;</span><br><span class="line">        sort.Ints(ages)</span><br><span class="line">        left, right := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> _, age := <span class="keyword">range</span> ages &#123;</span><br><span class="line">            <span class="keyword">if</span> age &lt; <span class="number">15</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> ages[left]*<span class="number">2</span> &lt;= age+<span class="number">14</span> &#123;</span><br><span class="line">                left ++</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> right+<span class="number">1</span> &lt; <span class="built_in">len</span>(ages) &amp;&amp; ages[right+<span class="number">1</span>] &lt;= age &#123;</span><br><span class="line">                right ++</span><br><span class="line">            &#125;</span><br><span class="line">            ans += right - left</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣每日一题之课程表Ⅲ</title>
    <url>/p/course-schedule-iii/</url>
    <content><![CDATA[<p>这里有<code>n</code>门不同的在线课程，按<code>1</code>到<code>n</code>编号。给你一个数组<code>courses</code>，其中<code>courses[i] = [durationi, lastDayi]</code>表示第<code>i</code>门课将会持续上<code>durationi</code>天课，并且必须不晚于<code>lastDayi</code>的时候完成。</p>
<p>你的学期从第一天开始，且不能同时修读两门及两门以上的课程。</p>
<p>返回你最多可以修读的课程数目。</p>
<span id="more"></span>
<p><strong>示例1：</strong></p>
<p>输入：<code>courses = [[100, 200], [200, 1300], [1000, 1250], [2000, 3200]]</code>
输出：<code>3</code> 解释： 这里一共有 4 门课程，但是你最多可以修 3 门：
首先，修第 1 门课，耗费 100 天，在第 100 天完成，在第 101 天开始下门课。
第二，修第 3 门课，耗费 1000 天，在第 1100 天完成，在第 1101
天开始下门课程。 第三，修第 2 门课，耗时 200 天，在第 1300 天完成。 第 4
门课现在不能修，因为将会在第 3300 天完成它，这已经超出了关闭日期。</p>
<p><strong>示例2：</strong></p>
<p>输入：<code>courses = [[1, 2]]</code> 输出：<code>1</code></p>
<p><strong>示例3：</strong></p>
<p>输入：<code>courses = [[3, 2],[4,3]]</code> 输出：<code>0</code></p>
<h2 id="方法一优先队列贪心">方法一：优先队列+贪心</h2>
<p><strong>思路</strong></p>
<p>对于两门课<span class="math inline">\((t1, d1)\)</span>和<span
class="math inline">\((t2, d2)\)</span>，如果后者关闭的时间较晚，即<span
class="math inline">\(d1 \le
d2\)</span>，那先学习前者，再学习后者，总是最优的。这是因为：</p>
<ul>
<li><p>假设最开始学习的时间点为<span
class="math inline">\(x\)</span>，如果先学习前者，再学习后者，那么需要满足：
<span class="math display">\[
\begin{cases}
x+t_1 \le d_1 \\
x+t_1+t_2\le d_2 \\
\end{cases}
\]</span></p></li>
<li><p>如果先学习后者，再学习前者，那么需要满足：</p></li>
</ul>
<p><span class="math display">\[
\begin{cases}
x+t_2 \le d_2 \\
x+t_1+t_2\le d_1 \\
\end{cases}
\]</span></p>
<p>如果 <span class="math inline">\(x+t_1+t_2 \le
d_1\)</span>成立，由于<span class="math inline">\(d_1 \le
d_2\)</span>，那么<span class="math inline">\(x+t_1+t_2 \le
d_2\)</span>同时成立。这说明，如果能【先学习后者，再学习前者】那么一定能【先学习前者，再学习后者】。如果<span
class="math inline">\(x+t_1+t_2 \le d_2\)</span>成立，则不能推出<span
class="math inline">\(x+t_2+t_1 \le
d_1\)</span>成立。<strong>虽然能【先学习前者，再学习后者】，但不能【先学习后者，再学习前者】。</strong></p>
<p>因此，我们可以将所有的课程按照关闭时间<span
class="math inline">\(d\)</span>进行升序排序，再依次挑选课程并按照顺序进行学习。</p>
<p>在遍历的过程中，假设我们当前遍历到了第<span
class="math inline">\(i\)</span>门课<span class="math inline">\((t_i,
d_i)\)</span>，而在前<span
class="math inline">\(i-1\)</span>门课程中我们选择了<span
class="math inline">\(k\)</span>门课<span class="math inline">\((t_{x1},
d_{x1}),(t_{x2}, d_{x2}), ... ,(t_{xk}, d_{xk})\)</span>，满足<span
class="math inline">\(x_1&lt;x_2&lt; \cdots x_k\)</span>，那么有： <span
class="math display">\[
\begin{cases}
t_{x1} \le d_{x1} \\
t_{x1}+t_{x2} \le d_{x2} \\
\cdots \\
t_{x1}+t_{x2}+ \cdots +\le t_{x2} d_{xk}\\
\end{cases}
\]</span> 如果上述选择方案是前<span
class="math inline">\(i-1\)</span>门课程的【最优方案】：即不存在能选择<span
class="math inline">\(k+1\)</span>门课程的方法，也不存在能选择<span
class="math inline">\(k\)</span>门课程，且总时长更短的方案，那么我们可以基于该方案与第<span
class="math inline">\(i\)</span>门课程<span class="math inline">\((t_i,
d_i)\)</span>，构造出前<span
class="math inline">\(i\)</span>门课程的最优方案：</p>
<p><img data-src="image-20211214221952979.png" /></p>
<p>这样一来，当我们遍历完所有的<span
class="math inline">\(n\)</span>门课程后，就可以得到最终答案。</p>
<p><strong>算法</strong></p>
<p>我们需要一个数据结构支持【取出<span
class="math inline">\(t\)</span>值最大的那门课程】，因此我们可以使用优先队列。</p>
<p>依次遍历每一门课程，当遍历到<span class="math inline">\((t_i,
d_i)\)</span>时：</p>
<ul>
<li>如果当前优先队列中所有课程的总时间与<span
class="math inline">\(t_i\)</span>之和小于等于<span
class="math inline">\(d_i\)</span>，那么我们就把<span
class="math inline">\(t_i\)</span>加入优先队列中；</li>
<li>如果当前优先队列中所有课程的总时间与<span
class="math inline">\(t_i\)</span>之和大于<span
class="math inline">\(d_i\)</span>，那么我们找到优先队列的最大元素<span
class="math inline">\(t_{xj}\)</span>。如果<span
class="math inline">\(t_{xj} &gt;
t_{i}\)</span>，则将它移出优先队列，并把<span
class="math inline">\(t_i\)</span>加入优先队列中。</li>
</ul>
<p>在遍历完成之后，优先队列中包含的元素个数即为答案。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">scheduleCourse</span><span class="params">(courses [][]<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    sort.Slice(courses, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> courses[i][<span class="number">1</span>] &lt; courses[j][<span class="number">1</span>]</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    h := &amp;Heap&#123;&#125;</span><br><span class="line">    total := <span class="number">0</span> <span class="comment">// 优先队列中所有课程的总时间</span></span><br><span class="line">    <span class="keyword">for</span> _, course := <span class="keyword">range</span> courses &#123;</span><br><span class="line">        <span class="keyword">if</span> t := course[<span class="number">0</span>]; total+t &lt;= course[<span class="number">1</span>] &#123;</span><br><span class="line">            total += t</span><br><span class="line">            heap.Push(h, t)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> h.Len() &gt; <span class="number">0</span> &amp;&amp; t &lt; h.IntSlice[<span class="number">0</span>] &#123;</span><br><span class="line">            total += t - h.IntSlice[<span class="number">0</span>]</span><br><span class="line">            h.IntSlice[<span class="number">0</span>] = t</span><br><span class="line">            heap.Fix(h, <span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h.Len()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Heap <span class="keyword">struct</span> &#123;</span><br><span class="line">    sort.IntSlice</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Heap)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> h.IntSlice[i] &gt; h.IntSlice[j]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Heap)</span></span> Push(x <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">    h.IntSlice = <span class="built_in">append</span>(h.IntSlice, x.(<span class="type">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Heap)</span></span> Pop() <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">    a := h.IntSlice</span><br><span class="line">    x := a[<span class="built_in">len</span>(a)<span class="number">-1</span>]</span><br><span class="line">    h.IntSlice = a[:<span class="built_in">len</span>(a)<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣题目类型之回溯法（一）</title>
    <url>/p/back-tracking-one/</url>
    <content><![CDATA[<p>回溯法也可以叫做回溯搜索法，它是一种搜索的方式。</p>
<p>回溯是递归的副产品，只要有递归就会有回溯。</p>
<span id="more"></span>
<h2 id="回溯法的效率">回溯法的效率</h2>
<p>回溯的本质是穷举，穷举所有可能。如果还想让回溯法高效一些，可以加一些剪枝的操作，但其本质仍是穷举。</p>
<h2 id="回溯法可以解决的问题">回溯法可以解决的问题</h2>
<p>回溯法，一般用于解决以下问题：</p>
<ul>
<li>组合问题：N个数里面按一定规则找出k个数的集合；</li>
<li>切割问题：一个字符串按一定规则有几种切割方式；</li>
<li>子集问题：一个N个数的集合里有多少符合条件的子集；</li>
<li>排列问题：N个数按一定规则全排列，有几种排列方式；</li>
<li>棋盘问题：N皇后，解数独等。</li>
</ul>
<h2 id="如何理解回溯法">如何理解回溯法</h2>
<p>回溯法解决的问题都可以抽象成树形结构，因为回溯法解决的都是在集合中递归查找子集：</p>
<ul>
<li>集合的大小是树的宽度</li>
<li>递归的深度是树的深度</li>
</ul>
<p>递归要有终止条件，因此必然是一颗高度有限的树（N叉树）</p>
<h2 id="回溯法模板">回溯法模板</h2>
<p>回溯三部曲</p>
<ul>
<li><strong>返回值以及参数</strong>：一般是先写逻辑，然后需要什么参数填写什么参数。</li>
<li><strong>终止条件</strong>：什么时候达到了终止条件，树中就可以看出，一般来说搜到叶子节点了，也就找到了满足条件的一条答案，然后把整个答案存起来，并结束本层递归。</li>
<li><strong>遍历过程</strong>：回溯法是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成了树的深度。</li>
</ul>
<p><img data-src="20210130173631174.png" /></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(参数)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (选择; 本层集合中元素(树中节点孩子的大小就是集合的大小)) &#123; <span class="comment">// for循环是横向遍历</span></span><br><span class="line">        处理节点;</span><br><span class="line">        func(路径, 选择列表); <span class="comment">// 递归是纵向遍历</span></span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣每日一题之保持城市天际线</title>
    <url>/p/max-increase-to-keep-city-skyline/</url>
    <content><![CDATA[<p>给你一座<code>nxn</code>个街区组成的城市，每个截取都包含一座立方体建筑。给你一个坐标从0开始的<code>nxn</code>整数矩阵<code>grid</code>，其中<code>grid[r][c]</code>表示坐落于<code>r</code>行c列的建筑物的高度。</p>
<p>城市的天际线是从远处观察城市时，所有建筑物形成的外部轮廓。从东、南、西、北四个方向观测到的天际线可能不同。</p>
<p>我们被允许为任意数量的建筑物的高度增加任意增量（不同的建筑物的增量可能不同）。高度为0的建筑物的高度也可以增加。然而，增加的建筑物高度不能影响从任何主要方向观察城市的得到的天际线。</p>
<p>在 <strong>不改变</strong>
从任何主要方向观测到的城市的天际线的前提下，返回建筑物可以增加的最大高度增量总和。</p>
<span id="more"></span>
<p><strong>示例1</strong></p>
<p><strong>输入</strong>：<code>grid = [[3,0,8,4],[2,4,5,7],[9,2,6,3],[0,3,1,0]]</code>
<strong>输出</strong>：<code>35</code>
<strong>解释</strong>：建筑物的高度如上图中心所示。
用红色绘制从不同方向观看得到的天际线。
在不影响天际线的情况下，增加建筑物的高度：
<code>gridNew = [ [8, 4, 8, 7],             [7, 4, 7, 7],             [9, 4, 8, 7],             [3, 3, 3, 3] ]</code></p>
<p><strong>示例2</strong></p>
<p><strong>输入</strong>：<code>grid=[[0,0,0],[0,0,0],[0,0,0]]</code>
<strong>输出</strong>：0
<strong>解释</strong>：增加任何建筑物的高度都会导致天际线的变化。</p>
<h3 id="方法一贪心算法">方法一：贪心算法</h3>
<p>从左侧和右侧看，城市天际线等于<strong>矩阵grid每一行的建筑物的最大值</strong>；从顶部和底部看，城市天际线等于<strong>矩阵grid的每一列的建筑物的最大值</strong>。只要<strong>不改变每一行和每一列的建筑物的高度的最大值</strong>，就能保持城市天际线，因此可以使用贪心的思想计算高度建筑可以增加的最大高度。</p>
<p>由于矩阵grid的行数和列数都是n，因此创建一个两个长度为n的数组rowMax和colMax分别记录建筑物grid的每一行的最大值和每一列的最大值。遍历矩阵grid填入两个数组之后，再次遍历矩阵，计算每个建筑物可以增加的最大值。</p>
<p>对于<code>0&lt;=i, j&lt;n</code>时，对于第i行和第j列的建筑物，其所在行的建筑物高度的最大值是<code>rowMax[i]</code>，其所在列的建筑物的高度的最大值是<code>colMax[j]</code>。为了保持城市天际线，该建筑物增加后的高度不能超过其所在行和所在列的建筑物高度最大值，即该建筑物增加后的最大高度是<code>min(rowMax[i], colMax[j])</code>。由于该建筑物的原始高度是<code>grid[j][j]</code>，因此该建筑物增加后的最大高度是<code>min(rowMax[i], colMax[j]) - grid[i, j]</code>.</p>
<p>对于矩阵grid中每个元素可以增加的最大值，即可得到建筑物高度可以增加的最大总和。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxIncreaseKeepingSkyline</span><span class="params">(grid [][]<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="comment">//计算每一行的最大值和每一列的最大值</span></span><br><span class="line">	m, n := <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">	rowMax := <span class="built_in">make</span>([]<span class="type">int</span>, m)</span><br><span class="line">	colMax := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> rowMax[i] &lt; grid[i][j] &#123;</span><br><span class="line">				rowMax[i] = grid[i][j]</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> colMax[j] &lt; grid[i][j] &#123;</span><br><span class="line">				colMax[j] = grid[i][j]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 每一个栅格上的建筑物不能超过所在行最大值、所在列最大值两者的最小值</span></span><br><span class="line">    <span class="comment">// 能增加的最大值是这两者的差</span></span><br><span class="line">	<span class="keyword">var</span> ret <span class="type">int</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ &#123;</span><br><span class="line">			ret += min(rowMax[i], colMax[j]) - grid[i][j]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣每日一题之位运算的应用</title>
    <url>/p/to-lower-case/</url>
    <content><![CDATA[<p>给你一个字符串 <code>s</code>
，将该字符串中的大写字母转换成相同的小写字母，返回新的字符串。</p>
<p>当然我们可以用库函数解决这个问题，但是如果这个问题出现在面试里，那肯定是不能用库函数的。</p>
<p>这里我们使用<strong>位运算</strong>解决这个大小写转换问题。</p>
<span id="more"></span>
<p>我们知道</p>
<ol type="1">
<li><p>大写字母A-Z的ASCII码是65到90，小写字母的ASCII码是97到112，大小写字母的ASCII码相差32；</p></li>
<li><p>大写A(65)的二进制编码为<em>1000001</em>，小写a(97)的二进制编码位<em>1100001</em>。</p></li>
</ol>
<p>从上面我们可以发现一个规律：</p>
<ul>
<li>大小写是由<strong>第五位是1还是0</strong>来区分的。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&#x27;a&#x27;</span>) <span class="comment">// 97, 1100001</span></span><br><span class="line">	fmt.Println(<span class="string">&#x27;z&#x27;</span>) <span class="comment">// 122, 1111010</span></span><br><span class="line">	fmt.Println(<span class="string">&#x27;A&#x27;</span>) <span class="comment">// 65, 1000001</span></span><br><span class="line">	fmt.Println(<span class="string">&#x27;Z&#x27;</span>) <span class="comment">// 90, 1011010</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题转化为：如何让一个二进制的某一位的值发生改变？</p>
<ul>
<li>如果需要从0变成1，只需要和这个二进制数进行<strong>按位或运算</strong>，其中需要变化的位是1，其他位是0；</li>
<li>如果需要从1变成0，只需要和这个二进制数进行<strong>按位与运算</strong>，其中需要变化的位是0，其他位是1；</li>
</ul>
<h3 id="大写转小写">大写转小写</h3>
<p>在本题中，将二进制数的第5位从0变成1，那么只需要将该二进制数和二进制数<code>0100000</code><strong>按位或</strong>即可：</p>
<p><img data-src="image-20211212174229278.png" /></p>
<p>而当该字母本身就是小写字母时，则二进制数不发生改变，即<strong>小写字母还是原来的小写字母</strong></p>
<p>而二进制数00100000转换后得到十进制数32，因此如果需要将<strong>大写字母转换成小写字母，同时小写字母不变</strong>，只需要把这个字符按位或32即可：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">b := <span class="string">&#x27;A&#x27;</span></span><br><span class="line">b |= <span class="number">32</span> <span class="comment">// &#x27;a&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="小写转大写">小写转大写</h3>
<p>如果需要将小写转换成大写字母，需要将小写字母的二进制编码的第五位从1变成0，则需要将二进制数和二进制数<code>11011111</code><strong>按位与</strong>即可。</p>
<p><img data-src="image-20211212174546766.png" /></p>
<p>而当该字母本身就是大写字母时，则二进制数不发生改变，即<strong>大写字母还是原来的大写字母</strong></p>
<p>如何将<code>110111111</code>转换成十进制数呢？</p>
<p>二进制中最高位表示符号位，最高位是1时是负数，0是负数。</p>
<p>负数的计算方式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-64+16+8+4+2+1 = -33</span><br></pre></td></tr></table></figure>
<p>如果需要将<strong>小写字母转换成大写字母，同时大写字母不变</strong>，只需要把这个字符按位与-33即可：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">b := <span class="string">&#x27;A&#x27;</span></span><br><span class="line">b &amp;= <span class="number">-33</span></span><br></pre></td></tr></table></figure>
<h3 id="大写转小写小写转大写">大写转小写，小写转大写</h3>
<p>也就是二进制的<strong>第5位1变为0，同时0变为1</strong>.</p>
<p>小写转大写：</p>
<p><img data-src="image-20211212184452762.png" /></p>
<p>大写转小写：</p>
<p><img data-src="image-20211212184320992.png" /></p>
<p>将00100000转换成十进制是32.</p>
<p>如果需要将<strong>小写字母转换成大写字母，同时大写字母转换成小写字母</strong>，只需要把这个字符按位异或32即可：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">b := <span class="string">&#x27;A&#x27;</span></span><br><span class="line">b ~= <span class="number">32</span></span><br></pre></td></tr></table></figure>
<h3 id="总结">总结</h3>
<ul>
<li>大写转小写、小写转大写：字符^=32；</li>
<li>大写转小写、小写转小写：字符|=32；</li>
<li>小写转大写、大写转小写：字符&amp;=-33；</li>
</ul>
<p>完。</p>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣每日一题之在线选举</title>
    <url>/p/online-election/</url>
    <content><![CDATA[<p>给你两个证书数组<code>persons</code>和<code>times</code>。在选举中，第<code>i</code>张选票是在时刻为<code>times[i]</code>时投给选举人<code>persons[i]</code>的。</p>
<p>对于发生在时刻<code>t</code>的每个查询，需要找出在<code>t</code>时刻中领先的候选人的编号。</p>
<p>在<code>t</code>时刻投出的选票也被我们计入在我们的查询之中。在平局的情况下，最近获得选票的候选人将会获胜。</p>
<p>你的任务：实现<code>ToVotedCandidate</code>类：</p>
<ul>
<li><code>TopVotedCandidate(int[] persons, int[] times)</code>使用<code>persons</code>和<code>times</code>数组初始化对象。</li>
<li><code>int q(int t)</code>根据前面描述的规则，返回在时刻<code>t</code>在选举中领先的候选人的编号。</li>
</ul>
<span id="more"></span>
<p>输入：
<code>["TopVotedCandidate", "q", "q", "q", "q", "q", "q"]</code>
<code>[[[0, 1, 1, 0, 0, 1, 0], [0, 5, 10, 15, 20, 25, 30]], [3], [12], [25], [15], [24], [8]]</code>
输出： <code>[null, 0, 1, 1, 0, 0, 1]</code></p>
<p>解释：</p>
<ul>
<li>时刻为0时第0张票投给了0号；
<ul>
<li>时刻为3时此时都没有票，所以返回0；</li>
</ul></li>
<li>时刻为5时第1张票投给了1号；
<ul>
<li>时刻为8时此时票数分布是[0,
1]，因为1是最近获得选票的候选人，因此返回1；</li>
</ul></li>
<li>时刻为10时第2张票投给了1号；
<ul>
<li>时刻为12时此时票数分布是[0, 1, 1]，此时返回1；</li>
</ul></li>
<li>时刻为15时第3张票投给了0号；</li>
<li>时刻为20时第4张票投给了0号；</li>
<li>时刻为25时第4张票投给了1号；
<ul>
<li>时刻为25时此时票数分布为[0, 1, 1, 0, 0,
1]，又因为1是最近获得票的候选人，因此返回1；</li>
</ul></li>
<li>时刻为30时第5张票投给了0号。</li>
</ul>
<h2 id="方法一预计算二分查找">方法一：预计算+二分查找</h2>
<p>记<code>persons</code>的长度为<em>N</em>。我们对输入进行预计算，用一个长度为<em>N</em>的数组<code>tops</code>记录各时间段得票数领先的候选人。具体来说，<code>tops[i]</code>表示
<span class="math display">\[
\begin{cases}
times[i]≤t&lt;times[i+1],&amp; 0≤i&lt;N−1 \\
t≥times[i],&amp; i=N-1
\end{cases}
\]</span>
的时间段的领先的候选人，这样的预计算可以通过对<em>persons</em>在<em>time</em>上的计数完成。</p>
<p>具体实现方法是：</p>
<ul>
<li>用一个哈希表<code>voteCounts</code>记录不同的候选人的得票数，用一个变量<code>top</code>表示当前领先的候选人。按时间从小到大遍历<code>persons</code>和<code>times</code>，并更新<code>voteCounts</code>和<code>top</code>，把<code>top</code>放入<code>tops</code>。遍历结束后，我们可以得到一个长度为N的tops，表示各个时间段的票领先的候选人。</li>
<li>每次查询时，我们在times中找出不大于t且离t最近的元素的下标，这部操作可以通过二分查找完成。到tops索引相同的下标即可返回结果。</li>
</ul>
<h3 id="顺序查找">顺序查找</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TopVotedCandidate <span class="keyword">struct</span> &#123;</span><br><span class="line">	tops        []<span class="type">int</span></span><br><span class="line">	times       []<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(persons, times []<span class="type">int</span>)</span></span> TopVotedCandidate &#123;</span><br><span class="line">	tops := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">	top := <span class="number">-1</span></span><br><span class="line">	voteCounts := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;<span class="number">-1</span>: <span class="number">-1</span>&#125;</span><br><span class="line">	<span class="keyword">for</span> _, p := <span class="keyword">range</span> persons &#123;</span><br><span class="line">		voteCounts[p]++</span><br><span class="line">		<span class="keyword">if</span> voteCounts[p] &gt;= voteCounts[top] &#123;</span><br><span class="line">			top = p <span class="comment">// 记录上一个p</span></span><br><span class="line">		&#125;</span><br><span class="line">		tops = <span class="built_in">append</span>(tops, top)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> TopVotedCandidate&#123;tops, times&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *TopVotedCandidate)</span></span> Q(i <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">	<span class="comment">// 顺序查找</span></span><br><span class="line">	gap := <span class="number">10000000</span></span><br><span class="line">	ret := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> index, value := <span class="keyword">range</span> t.times &#123;</span><br><span class="line">		<span class="keyword">if</span> i-value &lt; gap &amp;&amp; i &gt;= value &#123;</span><br><span class="line">			gap = i - value</span><br><span class="line">			ret = index</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(t.tops[ret])</span><br><span class="line">	<span class="keyword">return</span> t.tops[ret]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="手写二分查找">手写二分查找</h3>
<ul>
<li>区间<code>[left,right]</code>, <strong>left &lt;= right</strong>，i
&gt; mid(left=mid+1)，i&lt;mid(right=mid-1)</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *TopVotedCandidate)</span></span> Q(i <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">	<span class="comment">// 二分查找</span></span><br><span class="line">	mid := <span class="number">0</span></span><br><span class="line">	left := <span class="number">0</span></span><br><span class="line">	right := <span class="built_in">len</span>(t.times) - <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> left &lt;= right &#123;</span><br><span class="line">		mid = left + (right-left)/<span class="number">2</span></span><br><span class="line">		<span class="keyword">if</span> i &gt; t.times[mid] &#123;</span><br><span class="line">			left = mid + <span class="number">1</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> i &lt; t.times[mid] &#123;</span><br><span class="line">			right = mid - <span class="number">1</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> t.tops[mid]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> t.tops[right]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="库函数二分查找">库函数二分查找</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *TopVotedCandidate)</span></span> Q(t <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> c.tops[sort.SearchInts(c.times, t+<span class="number">1</span>)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣每日一题之最短补全词</title>
    <url>/p/shortest-completing-word/</url>
    <content><![CDATA[<p>给你一个字符串<code>licensePlate</code>和一个字符串数组<code>words</code>，请你找出并返回<code>words</code>中最短补全词。</p>
<p>补全词是一个包含<code>licensePlate</code>中所有字母的单词，在所有补全词中，最短的那个就是最短补全词。</p>
<ul>
<li>在匹配<code>licensePlate</code>中的数字或空格。</li>
<li>不区分大小写</li>
<li>如果某个字母在<code>licensePlace</code>中出现不止一次，那么该字母在补全词中的出现的次数也应当一致或者更多。</li>
</ul>
<p>例如：<code>licensePlate</code>=<code>aBc 12c</code>,
那么他的补全词应当包含字母<code>a</code>、<code>b</code>忽略大小写和两个<code>c</code>，可能的补全词有<code>abccdef</code>、<code>caaacab</code>以及<code>cbca</code>。</p>
<p>请你找出并返回<code>words</code>中的最短补全词。题目数据中保证一定存在一个最短补全词。当有多个单词都符合最短补全词的匹配条件时区<code>words</code>中<strong>最靠前</strong>的那个。</p>
<span id="more"></span>
<h2 id="方法一统计字符出现次数">方法一：统计字符出现次数</h2>
<p>根据题意，先统计<code>licesePlate</code>中每个字母的出现次数（忽略大小写），然后遍历<code>words</code>中的每个单词，若26个英文字母在该单词中初选次数均小于<code>licesePlate</code>中才出现的次数，则该单词是一个补全词。返回最短且最靠前的补全词。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;unicode&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shortestCompletingWord</span><span class="params">(licensePlate <span class="type">string</span>, words []<span class="type">string</span>)</span></span> (ans <span class="type">string</span>) &#123;</span><br><span class="line">	cnt := [<span class="number">26</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> _, ch := <span class="keyword">range</span> licensePlate &#123;</span><br><span class="line">		<span class="keyword">if</span> unicode.IsLetter(ch) &#123; <span class="comment">// 如果是字母</span></span><br><span class="line">			cnt[unicode.ToLower(ch)-<span class="string">&#x27;a&#x27;</span>] += <span class="number">1</span> <span class="comment">// 就让他变成小写</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">next:</span><br><span class="line">	<span class="keyword">for</span> _, word := <span class="keyword">range</span> words &#123;</span><br><span class="line">		c := [<span class="number">26</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">		<span class="keyword">for</span> _, ch := <span class="keyword">range</span> word &#123;</span><br><span class="line">			c[ch-<span class="string">&#x27;a&#x27;</span>] += <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">26</span>; i++ &#123;</span><br><span class="line">			<span class="keyword">if</span> c[i] &lt; cnt[i] &#123;</span><br><span class="line">				<span class="keyword">continue</span> next</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> ans == <span class="string">&quot;&quot;</span> || <span class="built_in">len</span>(word) &lt; <span class="built_in">len</span>(ans) &#123;</span><br><span class="line">			ans = word</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu2004安装最新版本MySQL并设置外网访问</title>
    <url>/p/install-newest-mysql-in-ubuntu2004/</url>
    <content><![CDATA[<p><strong>本文主要介绍了如何在Ubuntu2004上安装最新版本的MySQL以及如何设置MySQL外网访问。</strong></p>
<p><strong>关键词：MySQL，Linux</strong></p>
<span id="more"></span>
<h3 id="更新仓库">更新仓库</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure>
<h3 id="用官方仓库安装-mysql">用官方仓库安装 MySQL</h3>
<h4 id="下载mysql仓库工具包">下载mysql仓库工具包</h4>
<p><a
href="https%3A//dev.mysql.com/downloads/repo/apt/">下载页面</a></p>
<p><img data-src="image-20211203152648123.png" /></p>
<p>点击Download，选择<strong>No thanks, just start my
download.</strong></p>
<p><img data-src="image-20211203152704181.png" /></p>
<h4 id="安装">安装</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo dpkg -i mysql-apt-config*</span><br></pre></td></tr></table></figure>
<h4 id="更新仓库-1">更新仓库</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure>
<h4 id="安装mysql-server">安装mysql-server</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install mysql-server -y</span><br></pre></td></tr></table></figure>
<p>这样做会在你的终端中打开包配置的提示。使用向下箭头选择“Ok”选项。</p>
<p><img data-src="v2-b09d5038434b3b540638c382677300bb_1440w.jpg" /></p>
<p>点击回车。这应该会提示你输入密码：这是在为 MySQL 设置 root 密码。</p>
<p><img data-src="v2-b22e27255b02ea03066a398e2b90acb8_1440w.jpg" /></p>
<p>输入密码然后点击 Tab 键去选择“Ok“。点击回车键，你将重新输入密码。</p>
<p><img data-src="v2-191abdf08ed88a03f4842b715f229649_1440w.jpg" /></p>
<p>将会展示一些关于 MySQL Server 的配置信息。再次按下 Tab 去选择 “Ok”
和按下回车键：</p>
<p><img data-src="/v2-c950f3613406d1b62dfa22904be045bb_1440w.jpg" /></p>
<p>第一种是最新的密码加密方法，第二种是sql5版本之前的密码加密方法，这里选择第二个。</p>
<h3 id="验证安装">验证安装</h3>
<p>要验证 MySQL 已经正确安装，使用下列命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl status mysql.service</span><br></pre></td></tr></table></figure>
<p><img data-src="v2-f506966fb17a1b8a145c84a8f5add612_1440w.jpg" /></p>
<p>检查到显示running即安装成功</p>
<h3 id="设置自动启动">设置自动启动</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> mysql.service</span><br></pre></td></tr></table></figure>
<h3 id="设置外网访问">设置外网访问</h3>
<p>链接mysql以后，在mysql命令行输入以下命令就可以允许外网访问：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update mysql.user set host=`%` where user=&#x27;root&#x27;;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>
<h4 id="原理">原理</h4>
<p>mysql默认是不允许外网访问的，只允许<code>localhost</code>或者<code>127.0.0.1</code>访问。</p>
<p>查询默认的mysql.user表，如下表示不允许外网访问，只允许本机访问：</p>
<p><img data-src="image-20211203153346215.png" /></p>
<p>更新访问权限</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">update mysql.user <span class="built_in">set</span> host=`%` <span class="built_in">where</span> user=<span class="string">&#x27;root&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img data-src="image-20211203153437479.png" /></p>
<p>更新权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>mysql</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu2004安装最新版本Redis并设置开机启动</title>
    <url>/p/install-newest-redis-in-ubuntu2004/</url>
    <content><![CDATA[<p><strong>本文主要介绍了如何在Ubuntu2004上安装最新版本的Redis以及如何设置Redis开机自动启动。</strong></p>
<p><strong>关键词：Redis，Linux</strong></p>
<span id="more"></span>
<h3 id="官方网站">官方网站</h3>
<p><a href="https://redis.io/download">Redis</a></p>
<p><img data-src="image-20211024202247242.png" /></p>
<h3 id="中文网">中文网</h3>
<p><a href="http://www.redis.cn/">redis中文官方网站</a></p>
<blockquote>
<p>注意，中文网的版本要比官方的版本要低</p>
</blockquote>
<p><img data-src="image-20211024202614937.png" /></p>
<h3 id="下载并安装">下载并安装</h3>
<p>这里选择的官网下载的版本。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://download.redis.io/releases/redis-6.2.6.tar.gz</span><br></pre></td></tr></table></figure>
<h3 id="直接安装编译好的版本">直接安装编译好的版本</h3>
<p><a
href="https://fly97.coding.net/s/ab90cc76-374d-49d4-a79f-edf6ec5e7d79">jemalloc_5.2.1-1_amd64.deb</a></p>
<p><a
href="https://fly97.coding.net/s/b45f9603-dc1d-4c13-9e32-b94a7e236fa4">redis_6.2.6-1_amd64.deb</a></p>
<h4 id="解压">解压</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -zxvf redis-6.2.6.tar.gz</span><br></pre></td></tr></table></figure>
<h4 id="编译安装">编译安装</h4>
<h5 id="首先查看gcc版本">首先查看gcc版本</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -v</span><br></pre></td></tr></table></figure>
<p><img data-src="image-20211024202923989.png" /></p>
<p>太旧的版本可能需要升级才能安装。这里用的是<strong>ubuntu20 04
LTS</strong>。</p>
<h5 id="尝试编译">尝试编译</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make </span><br></pre></td></tr></table></figure>
<h6 id="有可能出现的问题">有可能出现的问题</h6>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">zmalloc.h:50:10: fatal error: jemalloc/jemalloc.h:</span><br></pre></td></tr></table></figure>
<h6 id="解决方法">解决方法</h6>
<ol type="1">
<li>使用以下命令进行编译</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make MALLOC=libc</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li><p>安装jemalloc</p>
<p><a
href="https://blog.csdn.net/SweeNeil/article/details/94648313">jemalloc安装与使用</a></p></li>
</ol>
<h4 id="打包成deb包">打包成deb包</h4>
<p>为什么要打包成deb包呢？可以方便后续卸载等其他操作。</p>
<h5 id="首先安装checkinstall">首先安装checkinstall</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install checkinstall -y</span><br></pre></td></tr></table></figure>
<h5 id="执行打包命令">执行打包命令</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo checkinstall -y</span><br></pre></td></tr></table></figure>
<h5 id="打包完成">打包完成</h5>
<p><img data-src="image-20211024204914879.png" /></p>
<p>如果想卸载就执行执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo dpkg -r redis</span><br></pre></td></tr></table></figure>
<h4 id="检测是否安装完毕">检测是否安装完毕</h4>
<p>运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-server</span><br></pre></td></tr></table></figure>
<p><img data-src="image-20211024211634295.png" /></p>
<p>如有上图显示则说明运行成功</p>
<h3 id="后续的配置">后续的配置</h3>
<h4 id="配置文件">配置文件</h4>
<p>将配置文件移动到系统目录下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /etc/redis </span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> redis.conf /etc/redis/</span><br></pre></td></tr></table></figure>
<h5 id="修改监听ip">修改监听IP</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim redis.conf</span><br></pre></td></tr></table></figure>
<p><img data-src="image-20211203163721863.png" /></p>
<h5 id="修改端口">修改端口</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim redis.conf</span><br></pre></td></tr></table></figure>
<p><img data-src="image-20211203163751891.png" /></p>
<h4 id="设置开机自启动">设置开机自启动</h4>
<p>将redis使用service进行管理</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">touch</span> redis.service</span><br></pre></td></tr></table></figure>
<p><code>redis.service</code>文件的格式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Redis data structure server</span><br><span class="line">Documentation=https://redis.io</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">User=root</span><br><span class="line">Type=simple</span><br><span class="line">ExecStart=/usr/local/bin/redis-server /etc/redis/redis.conf</span><br><span class="line">ExecStop=/usr/local/bin/redis-cli -p 6379 shutdown</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>
<p>将redis.service移动到系统目录下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> redis.service /etc/systemd/system/redis.service</span><br></pre></td></tr></table></figure>
<p>设置自启动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> redis.service</span><br></pre></td></tr></table></figure>
<p>查看是否启动成功</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl status redis.service</span><br></pre></td></tr></table></figure></p>
<p><img data-src="image-20211024220501733.png" /></p>
<p>完。</p>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言设计与实现之反射</title>
    <url>/p/Reflections-in-go-language-base/</url>
    <content><![CDATA[<p>写日志收集项目的时候遇到了一个关于<code>reflect</code>的问题，于是有了这一篇文章。</p>
<p><strong>本文主要介绍go语言中reflect的基本用法，以及在使用反射特性时遇到的一些坑。</strong></p>
<p><strong>关键词：反射</strong></p>
<span id="more"></span>
<h2 id="问题引入">问题引入</h2>
<p>使用<a
href="https://ini.unknwon.io/">go-ini</a>时遇到了一个问题：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cfg *conf.AppConf</span><br><span class="line">err := ini.MapTo(cfg, <span class="string">&quot;./conf/config.ini&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>此时会报错：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">panic: reflect: call of reflect.Value.Type on zero Value</span><br></pre></td></tr></table></figure>
<p>修改成以下内容错误就会消失了</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cfg = <span class="built_in">new</span>(conf.AppConf) <span class="comment">// 要为cfg创建一个地址</span></span><br><span class="line"><span class="keyword">var</span> cfg *conf.AppConf</span><br><span class="line">	err := ini.MapTo(cfg, <span class="string">&quot;./conf/config.ini&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>以下是两种声明方式的区别：</p>
<ul>
<li>使用<code>var</code>声明一个变量的指针，默认值是<code>nil</code>，此时gc并没有为<code>cfg</code>分配内存；</li>
<li>使用<code>new()</code>创建一个<code>conf.AppConf</code>的对象（此时gc已经为<code>cfg</code>开辟了内存），同时获得这个对象的指针；</li>
</ul>
<p>这让我对<strong>反射</strong>的用法产生了疑问。下面引出本文的核心：<strong>反射是什么？</strong></p>
<h2 id="反射是什么">反射是什么</h2>
<p>反射是指程序运行期对程序本身进行访问和修改的能力，程序在编译时，变量被转换为内存地址，变量名不会被编译器写入到可执行部分。在运行程序时，程序无法获取自身的信息。</p>
<p>支持反射的语言可以在程序编译期将变量的反射信息如<strong>字段名称、类型信息、结构体信息</strong>等整合到可执行文件中，并给程序提供<strong>接口</strong>访问反射信息，这样就可以在程序运行期间获取类型的反射信息，并且有能力修改他们。</p>
<p>Go程序在运行期间使用<strong>reflect包</strong>访问程序的反射信息。</p>
<p>Go语言中的空接口可以存储任意类型的变量，反射可以在程序运行时动态的获取一个变量的<strong>类型信息和值信息</strong>。</p>
<h3 id="reflect包">reflect包</h3>
<p>Go语言的反射机制中，任何接口值都是<code>一个具体类型</code>和<code>一个具体类型的值</code>
两部分组成。</p>
<p>Go语言中反射的相关功能是由内置的reflect包提供，任意接口值在反射中都可以理解为<code>reflect.Type</code>和<code>reflect.Value</code>两部分组成，并且reflect包里提供了以下两个函数来获取任意对象的Value和Type：</p>
<ul>
<li>reflect.TypeOf：能获取类型信息</li>
<li>reflect.ValueOf：能获取数据的运行时表示</li>
</ul>
<p>两个类型是<code>reflect.Type</code>和<code>reflect.Value</code>，他们和函数是一一对应的关系：</p>
<p><img data-src="golang-reflection.png" /></p>
<h4 id="reflect.type">reflect.Type</h4>
<p>类型<code>reflect.Type</code>是反射包定义的一个<strong>接口</strong>，可以使用<code>reflect.TypeOf</code>函数获取任意变量的类型，
<code>reflect.Type</code>接口中定义了一些有趣的方法：<code>MethodByName</code>可以获取当前类型对应方法的引用、<code>Implements</code>可以判断当前类型是否实现了某个接口：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Type <span class="keyword">interface</span> &#123;</span><br><span class="line">        Align() <span class="type">int</span></span><br><span class="line">        FieldAlign() <span class="type">int</span></span><br><span class="line">        Method(<span class="type">int</span>) Method</span><br><span class="line">        MethodByName(<span class="type">string</span>) (Method, <span class="type">bool</span>)</span><br><span class="line">        NumMethod() <span class="type">int</span></span><br><span class="line">        ...</span><br><span class="line">        Implements(u Type) <span class="type">bool</span></span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="reflect.value">reflect.Value</h4>
<p>反射包中<code>reflect.Value</code>的类型与<code>reflect.Type</code>不同，他被声明成了<strong>结构体</strong>。这个结构体没有对外暴露的字段，但是提供了获取或者写入数据的方法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Value <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="comment">// 包含过滤的或者未导出的字段</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span></span> Addr() Value</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span></span> Bool() <span class="type">bool</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span></span> Bytes() []<span class="type">byte</span></span><br><span class="line">... </span><br></pre></td></tr></table></figure>
<p>反射包中所有方法都是围绕<code>reflect.Type</code>和<code>reflect.Value</code>两个类型设计的。</p>
<p>通过<code>reflect.TypeOf</code>、<code>reflect.ValueOf</code>可以将一个普通变量转换成<code>reflect.Type</code>和<code>reflect.Value</code>，随后就可以使用反射包中的方法对他们进行复杂的操作。</p>
<h3 id="三大法则">三大法则</h3>
<p>运行时反射时程序在运行期间检查自身结构的一种方式，反射带来的灵活性是一把双刃剑，<strong>反射作为一种元编程方式可以减少重复代码</strong>，但是过量的使用反射会使我们的程序逻辑难以理解并且运行缓慢。使用反射，一般要遵守<strong>反射三原则</strong>：</p>
<ol type="1">
<li><p>从<code>interface&#123;&#125;</code>变量可以反射出反射对象；</p></li>
<li><p>从反射对象可以获取<code>interface&#123;&#125;</code>变量；</p></li>
<li><p>要修改反射对象，其值必须可设置；</p></li>
</ol>
<h4 id="第一法则">第一法则</h4>
<p>为什么是从<code>interface&#123;&#125;</code>变量到反射对象？当执行<code>reflect.ValueOf(1)</code>是，虽然看起来是获取了基本类型<code>int</code>对应的反射类型，但是由于<code>reflect.TypeOf</code>、<code>reflect.ValueOf</code>的两个方法的入参都是<code>interface&#123;&#125;</code>类型，所以在方法执行的过程中发生了类型转换。</p>
<p>由于Go语言的<strong>函数调用都是值传递</strong>的，那么变量在函数调用时会进行类型转换，基本类型会转换成<code>interface&#123;&#125;</code>类型，这就是为什么第一条原则是<strong>从接口到反射对象</strong>。</p>
<p>上面提到的<code>reflect.TypeOf</code>和<code>reflect.ValueOf</code>就能完成这里的<strong>转换</strong>。Go语言的类型和反射类型处于两个不同的世界，这两个函数是链接这两个函数的桥梁。</p>
<p><img data-src="golang-interface-to-reflection.png" /></p>
<p>通过以下例子介绍他们的作用，<code>reflect.TypeOf</code>获取了变量author的类型，<code>reflect.ValueOf</code>获取了变量的值draven。如果我们知道了一个变量的<strong>值和类型</strong>，那么就意味着我们知道了这个变量的<strong>全部信息</strong>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    author := <span class="string">&quot;draven&quot;</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;TypeOf author:&quot;</span>, reflect.TypeOf(author))</span><br><span class="line">    fmt.Println(<span class="string">&quot;ValueOf author:&quot;</span>, reflect.ValueOf(author))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go run main.go</span><br><span class="line">TypeOf author: string</span><br><span class="line">ValueOf author: draven</span><br></pre></td></tr></table></figure>
<p>拿到变量的类型以后，可以通过Method方法获得类型实现的方法，通过Field获取类型包含的全部字段，对于不同的类型，
可以通过调用不同的方法来获取相关信息：</p>
<ul>
<li>结构体：获取字段的数量并通过下标和字段名获取字段名StructField；</li>
<li>哈希表：获取哈希表的Key类型；</li>
<li>函数或方法：获取入参和返回值的类型；</li>
<li>...</li>
</ul>
<p>总而言之，使用<code>reflect.TypeOf</code>和<code>reflect.ValueOf</code>能够获取</p>
<p>Go语言中的<strong>变量对应的反射对象</strong>，我们就能获得当前的数据类型和操作，并可以使用这些<strong>运行时</strong>获取结构执行方法。</p>
<h4 id="第二法则">第二法则</h4>
<p>反射的第二法则是可以从反射对象获取<code>interface&#123;&#125;</code>变量，reflect中的<code>reflect.Value.Interface()</code>可以将反射对象还原成接口类型的变量：</p>
<p><img data-src="golang-reflection-to-interface.png" /></p>
<p>调用<code>reflect.Value.Interface</code>方法只能获得<code>interface&#123;&#125;</code>类型的变量，如果还想将其还原成最原始的状态还需要对其进行显式类型转换：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">v := reflect.ValueOf(<span class="number">1</span>)</span><br><span class="line">v.Interface().(<span class="type">int</span>)</span><br></pre></td></tr></table></figure>
<p>从反射对象到接口值的过程是从接口值到反射对象的镜面过程，两个过程都需要经历两次转换：</p>
<ul>
<li>从接口值到反射对象：
<ul>
<li>从基本类型到接口类型的类型转换；</li>
<li>从接口类型到反射对象的转换；</li>
</ul></li>
<li>从反射对象到接口值：
<ul>
<li>从反射对象转换成接口类型；</li>
<li>通过<strong>显式类型转换</strong>成原始类型；</li>
</ul></li>
</ul>
<p><img data-src="golang-bidirectional-reflection.png" /></p>
<p>不是所有的变量都需要类型转换这一过程。如果变量本身就是<code>interface&#123;&#125;</code>类型的，那么它不需要类型转换。只由<strong>将反射对象转换成基本类型</strong>时才需要显式的转换操作。</p>
<h4 id="第三法则">第三法则</h4>
<p>Go语言反射的最后一条法则是与值是否可以被更改有关，如果我们想要更新一个<code>reflect.Value</code>，那么它持有的值一定是可以被更新的，假设由以下代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    i := <span class="number">1</span></span><br><span class="line">    v := reflect.ValueOf(i)</span><br><span class="line">    v.SetInt(<span class="number">10</span>)</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$go</span> run main.go</span><br><span class="line">panic: reflect: reflect.flag.mustBeAssignable using unaddressable value</span><br></pre></td></tr></table></figure>
<p>上述代码出错的原因是：由于<strong>Go语言的函数调用都是传值的</strong>，所以我们得到的反射跟最开始的变量没有任何关系，那么<strong>直接修改反射对象无法改变原始变量</strong>，程序就会报错。</p>
<p>想要修改原变量只能使用如下的方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    i := <span class="number">1</span></span><br><span class="line">    v := reflect.ValueOf(&amp;i)</span><br><span class="line">    v.Elem().SetInt(<span class="number">10</span>)</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$go</span> run main.go</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<ol type="1">
<li>调用<code>reflect.ValueOf</code>获取变量指针（传指针）；</li>
<li>调用<code>reflect.Value.Elem</code>获取指针指向的变量；</li>
<li>调用<code>reflect.Value.SetInt</code>更新变量的值；</li>
</ol>
<p>由于Go语言的函数调用都是值传递的，所以我们只能用迂回的方式改变原变量：先获取指针对应的<code>reflect.Value</code>，再通过<code>reflect.Value.Elem</code>方法得到可以被设置的变量，通过以下代码理解这个过程：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    i := <span class="number">1</span></span><br><span class="line">    v := &amp;<span class="number">1</span></span><br><span class="line">    &amp;v = <span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不能直接操作<code>i</code>变量修改其持有的值，就只能获取<code>i</code>变量所在的地址并使用<code>*v</code>修改所在的地址中存储的整数。</p>
<h3 id="类型和值">类型和值</h3>
<p>Go语言的<code>interface&#123;&#125;</code>类型在语言内部是通过<code>reflect.emptyInterface</code>结构体表示的，其中的<code>typ</code>字段用于表示变量的类型，另一个<code>word</code>字段表示指向内部封装的数据：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> emptyInterface <span class="keyword">struct</span> &#123;</span><br><span class="line">	typ  *rtype</span><br><span class="line">	word unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="reflect.typeof实现">reflect.TypeOf实现</h4>
<p>用于获取变量类型的<code>reflect.TypeOf</code>函数将传入的变量隐式转换成<code>reflect.emptyInterface</code>类型并<strong>返回</strong>其中存储的类型信息<code>reflect.rtype</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TypeOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> Type &#123;</span><br><span class="line">    eface := *(*emptyInterface)(unsafe.Pointer(&amp;i))</span><br><span class="line">    <span class="keyword">return</span> toType(eface.typ)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">toType</span><span class="params">(t *rtype)</span></span> Type&#123;</span><br><span class="line">    <span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>reflect.rtype</code>是一个实现了<code>reflect.Type</code>接口的结构体，该结构体实现的<code>reflect.rtype.String</code>方法可以帮助我们获取当前类型的名称：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *rtype)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">    s := t.nameOff(t.str).name()</span><br><span class="line">    <span class="keyword">if</span> t.tflag&amp;tflagExtraStar != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s[<span class="number">1</span>:]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>reflect.TypeOf的实现原理并不复杂，它只是将一个<code>interface&#123;&#125;</code>变量转换成了内部的<code>reflect.emptyInterface</code>
表示，然后从中获取相应的类型信息。</p>
<h4 id="reflect.valueof实现">reflect.ValueOf实现</h4>
<p>用于接口值的<code>reflect.Value</code>的函数实现<code>reflect.ValuesOf</code>实现也非常简单，在该函数中先调用<code>reflect.escapes</code>保证当前值逃逸到堆上，然后通过<code>reflect.unpackEface</code>从接口中获取<code>reflect.Value</code>结构体：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ValueOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> Value &#123;</span><br><span class="line">    <span class="keyword">if</span> i == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Value&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    escapes(i)</span><br><span class="line">    <span class="keyword">return</span> unpackEface(is)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unpackEface</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> Value &#123;</span><br><span class="line">    e := *(emptyInterface)(unsafe.Pointer(&amp;i))</span><br><span class="line">    t := e.typ</span><br><span class="line">    <span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Value&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    f := flag(t.Kind())</span><br><span class="line">    <span class="keyword">if</span> ifaceIndir(t) &#123;</span><br><span class="line">        f |= flagIndir</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Value&#123;t, e.Word, f&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>reflect.unpackEface</code>会将传入的接口转换成<code>reflect.emptyInterface</code>，然后将具体类型和指针包装成<code>reflect.Value</code>结构体后返回。</p>
<h4 id="编译调用">编译调用</h4>
<p><code>reflect.TypeOf</code>和<code>reflect.ValueOf</code>的实现都很简单，我们已经分析了这两个函数的实现，现在需要了解编译器在调用函数之前做了哪些工作：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    i := <span class="number">20</span></span><br><span class="line">    _ = reflect.TypeOf(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$go</span> build -gcflags=<span class="string">&quot;-S -N&quot;</span> main.go</span><br><span class="line">...</span><br><span class="line">MOVQ	<span class="variable">$20</span>, <span class="string">&quot;&quot;</span>..autotmp_20+56(SP) // autotmp = 20</span><br><span class="line">LEAQ	type.int(SB), AX           // AX = type.int(SB)</span><br><span class="line">MOVQ	AX, <span class="string">&quot;&quot;</span>..autotmp_19+280(SP) // autotmp_19+280(SP) = type.int(SB)</span><br><span class="line">LEAQ	<span class="string">&quot;&quot;</span>..autotmp_20+56(SP), CX  // CX = 20</span><br><span class="line">MOVQ	CX, <span class="string">&quot;&quot;</span>..autotmp_19+288(SP) // autotmp_19+288(SP) = 20</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>从上面这段截取的汇编语言，我们可以发现在函数调用之前就已经发生了类型转换，上述指令将int类型的变量转换成了占用16字节的<code>autotmp_19+280(SP) ~ autotmp_19+288(SP)</code>
接口，两个<code>LEAQ</code>指令分别获取了类型的指针<code>type.int(SB)</code>以及变量i所在的地址。</p>
<p>当我们想要将一个变量转换成反射对象时，Go语言会在<strong>编译期间</strong>完成类型转换，将变量的类型和值转换成了<code>interface&#123;&#125;</code>并等待<strong>运行期间使用</strong><code>reflect</code>包获取接口中存储的信息。</p>
<h3 id="更新变量">更新变量</h3>
<p>当我们想要更新<code>reflect.Value</code>时，就需要调用<code>reflect.Value.Set</code>更新反射对象，该方法会调用</p>
<ul>
<li><strong>reflect.flag.mustBeAssignable</strong>：用于检查当前反射对象是否可以被设置</li>
<li><strong>reflect.flag.mustBeExported</strong>：用于检查字段是否对外公开</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span></span> Set(x Value) &#123;</span><br><span class="line">    v.mustBeAssignable()</span><br><span class="line">    v.mustBeExported()</span><br><span class="line">    <span class="keyword">var</span> target unsafe.Pointer</span><br><span class="line">    <span class="keyword">if</span> v.Kind() == Interface&#123;</span><br><span class="line">        target = v.ptr</span><br><span class="line">    &#125;</span><br><span class="line">    x = x.assignTo(<span class="string">&quot;reflect.Set&quot;</span>, v.typ, target)</span><br><span class="line">    typedmemmove(v.typ, v.ptr, x.ptr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>reflect.Value.Set</code>会调用<code>reflect.Value.assignTo</code>并返回一个新的反射对象，这个反射对象指针会直接覆盖原反射变量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span></span> assignTo(context <span class="type">string</span>, dst *rtype, target unsafe.Pointer) Value &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> directlyAssignable(dst, v.typ):</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> Value&#123;dst, v.ptr. f1&#125;</span><br><span class="line">    <span class="keyword">case</span> implements(dst, v.typ):</span><br><span class="line">        <span class="keyword">if</span> v.kind() == Interface &amp;&amp; v.IsNil() &#123;</span><br><span class="line">            <span class="keyword">return</span> Value&#123;dst, <span class="literal">nil</span>, flag(Interface)&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        x := valueInterface(v, <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">if</span> dst.NumMethod() == <span class="number">0</span> &#123;</span><br><span class="line">            *(*<span class="keyword">interface</span>&#123;&#125;)(target) = x</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            ifaceE2I(dst, x, target)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Value&#123;dst, target, flagIndir | flag(Interface)&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">panic</span>(context+ <span class="string">&quot;:value of type &quot;</span> + v.typ.String() + <span class="string">&quot; is not assignable to type &quot;</span>+ dst.String())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>reflect.Value.assignTo</code>
会根据当前和被设置的反射对象类型创建一个新的<code>reflect.Value</code>结构体：</p>
<ul>
<li>如果反射对象的类型是可以被替换的，就会直接返回目标对象；</li>
<li>如果当前接口对象是接口并且目标对象实现了接口，就会把目标对象简单包装成接口值；</li>
</ul>
<p>在变量更新的过程中，<code>reflect.Value.assignTo</code>返回的
<code>reflect.Value</code>中的指针会覆盖当前反射对象中的指针实现变量的更新。</p>
<h3 id="实现协议">实现协议</h3>
<p><code>reflect</code>包提供了<code>reflect.rtype.Implements</code>方法可以用于判断某些类型是否遵循<strong>特定的接口</strong>。在Go语言中获取结构体的反射类型<code>reflect.Type</code>还是比较容易的，但是想要获得接口类型就需要通过以下方式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">reflect.TypeOf((*&lt;<span class="keyword">interface</span>&gt;)(<span class="literal">nil</span>)).Elem()</span><br></pre></td></tr></table></figure>
<p>通过一个例子来介绍如何判断一个类型是否实现了某个接口。</p>
<p>我们通过一个例子来介绍如何判断一个类型是否实现了某个接口。假设我们需要判断如下代码中的<code>CustomError</code>是否实现了Go语言标准库中的<code>error</code>接口：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> CustomError <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*CustomError)</span></span> Error() <span class="type">string</span> &#123; <span class="comment">// 实现了error接口</span></span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	typeOfError := reflect.TypeOf(((*<span class="type">error</span>)(<span class="literal">nil</span>))).Elem() <span class="comment">// 把nil强制转换成error接口类型</span></span><br><span class="line">	customErrorPtr := reflect.TypeOf(&amp;CustomError&#123;&#125;)</span><br><span class="line">	customError := reflect.TypeOf(CustomError&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	fmt.Println(customErrorPtr.Implements(typeOfError)) <span class="comment">// true</span></span><br><span class="line">	fmt.Println(customError.Implements(typeOfError))  <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码的运行结果说明了：</p>
<ul>
<li><code>CustomError</code>类型<strong>没有实现</strong><code>error</code>接口；</li>
<li><code>*CustomError</code>类型<strong>实现了</strong><code>error</code>接口；</li>
</ul>
<p>分析一下<code>reflect.rtype.Implements</code>方法的工作原理：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *rtype)</span></span> Implements(u Type) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> u == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;reflect: nil type passed to Type.Implements&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> u.Kind() != Interface &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;reflect: non-interface type passed to Type.Implements&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> implements(u.(*rtype), t)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>reflect.rtype.Implements</code>会检查传入的类型是不是接口，如果不是接口或者是空值就会直接<strong>panic</strong>。</p>
<p>在参数没有问题的情况下，上述方法会调用私有函数<code>reflect.implements</code>判断类型之间<strong>是否有实现关系</strong>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">implements</span><span class="params">(T, V *rtype)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	t := (*interfaceType)(unsafe.Pointer(T))</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(t.methods) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	v := V.uncommon()</span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">	vmethods := v.methods()</span><br><span class="line">	<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="type">int</span>(v.mcount); j++ &#123;</span><br><span class="line">		tm := &amp;t.methods[i]</span><br><span class="line">		tmName := t.nameOff(tm.name)</span><br><span class="line">		vm := vmethods[j]</span><br><span class="line">		vmName := V.nameOff(vm.name)</span><br><span class="line">		<span class="keyword">if</span> vmName.name() == tmName.name() &amp;&amp; V.typeOff(vm.mtyp) == t.typeOff(tm.typ) &#123;</span><br><span class="line">			<span class="keyword">if</span> i++; i &gt;= <span class="built_in">len</span>(t.methods) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果接口中不包含任何方法，就意味着这是一个空的接口，任意类型都自动实现该接口，此时会直接返回<code>true</code>。</p>
<p><img data-src="golang-type-implements-interface.png" /></p>
<p>在其他情况下，由于方法都是按照<strong>字母序</strong>存储的，<code>reflect.implements</code>会维护两个用于遍历接口和类型方法的索引<code>i</code>和
<code>j</code>判断类型是否实现了接口，因为最多只会进行<code>n</code>次比较（类型的方法数量），所以整个过程的时间复杂度是O(n)。</p>
<h3 id="方法调用">方法调用</h3>
<p>作为一门静态语言，如果想要通过<code>reflect</code>包利用反射在运行期间执行方法不是一件容易的事情，下面的代码使用反射来执行<code>Add(0, 1)</code>函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;<span class="keyword">return</span> a + b&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v := reflect.ValueOf(Add) <span class="comment">// 1. 获取函数反射对象</span></span><br><span class="line">    <span class="keyword">if</span> v.Kind() != reflect.Func &#123;</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    &#125;</span><br><span class="line">    t := v.Type()</span><br><span class="line">    argv := <span class="built_in">make</span>([]reflect.Value, t.NumIn()) <span class="comment">// 2. 获取函数入参个数，并根据数目创建[]reflect.Value切片</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> argv &#123;</span><br><span class="line">        <span class="keyword">if</span> t.In(i).Kind() != reflect.Int &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        argv[i] = reflect.ValueOf(i) <span class="comment">// 3. 设置入参数组的各个参数</span></span><br><span class="line">    &#125;</span><br><span class="line">    result := v.Call(argv) <span class="comment">// 4. 调用方法并传入参数列表</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(result) != <span class="number">1</span> || result[<span class="number">0</span>].Kind() != reflect.Int&#123; <span class="comment">// 5.获取返回值数组，验证数组的长度以及类型；</span></span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(result[<span class="number">0</span>].Int())  <span class="comment">// 1 // 5. 打印返回值数组中的数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以概括为以下几个步骤：</p>
<ol type="1">
<li>通过调用<code>reflect.ValueOf</code>获取函数<code>Add</code>对应的反射对象；</li>
<li>通过调用<code>reflect.rtype.NumIn</code>获取函数的入参个数；</li>
<li>多次调用<code>reflect.ValueOf</code>函数逐一设置<code>argv数组</code>的各个参数；</li>
<li>调用反射对象<code>Add</code>的<code>reflect.Value.Call</code>方法并传入参数列表；</li>
<li>获取返回值数组、验证数组的长度以及类型并打印其中的数据；</li>
</ol>
<p>使用反射来调用方法非常复杂，原本只需要一行代码就能完成的工作，现在需要十几行代码才能完成，但这也是在静态语言中使用动态特性所需要付出的成本。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span></span> Call(in []Value) []Value &#123;</span><br><span class="line">    v.mustBe(Func)</span><br><span class="line">    v.mustBeExported()</span><br><span class="line">    <span class="keyword">return</span> v.call(<span class="string">&quot;Call&quot;</span>, in)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>reflect.Value.Call是运行时调用方法的入口，它通过两个<strong>mustBe</strong>开头的方法确定了当前反射对象的类型是函数以及可见性，随后调用reflect.Value.call完成方法调用，这个私有方法的执行过程会分成以下的几个部分：</p>
<ol type="1">
<li>检查输入参数以及类型的合法性；</li>
<li>将传入的 <code>reflect.Value</code>参数数组设置到栈上；</li>
<li>通过函数指针和输入参数调用函数；</li>
<li>从栈上获取函数的返回值；</li>
</ol>
<p>下面将按照以上的顺序分析<code>reflect</code>进行函数调用的过程。</p>
<h4 id="参数检查">参数检查</h4>
<p>参数检查是通过反射调用方法的第一步，在参数检查期间会从反射对象取出当前的函数指针<code>unsafe.Pointer</code>，如果该函数指针是方法，那么会通过<code>reflect.methodReceiver</code>获取方法的接收者和函数指针。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span></span> call(op <span class="type">string</span>, in []Value) []Value &#123;</span><br><span class="line">	t := (*funcType)(unsafe.Pointer(v.typ)) <span class="comment">// 强制转换成函数指针</span></span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> v.flag&amp;flagMethod != <span class="number">0</span> &#123;  <span class="comment">// 如果该函数指针是方法</span></span><br><span class="line">		rcvr = v</span><br><span class="line">		rcvrtype, t, fn = methodReceiver(op, v, <span class="type">int</span>(v.flag)&gt;&gt;flagMethodShift) <span class="comment">// 获取方法指针的接收者和函数指针</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">	n := t.NumIn()</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(in) &lt; n &#123; <span class="comment">// 检查入参个数是否匹配</span></span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;reflect: Call with too few input arguments&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(in) &gt; n &#123; <span class="comment">// 检查入参个数是否匹配</span></span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;reflect: Call with too many input arguments&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> xt, targ := in[i].Type(), t.In(i); !xt.AssignableTo(targ) &#123;  <span class="comment">// 检查函数入参类型是否和函数签名匹配</span></span><br><span class="line">			<span class="built_in">panic</span>(<span class="string">&quot;reflect: &quot;</span> + op + <span class="string">&quot; using &quot;</span> + xt.String() + <span class="string">&quot; as type &quot;</span> + targ.String())</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述方法会检查入参个数的个数以及参数的类型与签名中的类型是否可以匹配，任何参数的不匹配都导致整个程序的崩溃中止。</p>
<h4 id="准备参数">准备参数</h4>
<p>当我们已经对当前方法的参数完成验证后，就会进入函数调用的下一个阶段，为函数调用准备参数。<strong>Go语言的函数调用惯例是函数或者方法在调用时，所有的参数都会被以依次放到栈上。</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">nout := t.NumOut()</span><br><span class="line">frametype, _, retOffset, _, framePool := funcLayout(t, rcvrtype) <span class="comment">// 计算当前函数需要的参数和返回值的栈布局，也就是每一个参数和返回值所占的空间大小</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> args unsafe.Pointer</span><br><span class="line"><span class="keyword">if</span> nout == <span class="number">0</span> &#123; <span class="comment">// 若当前函数有返回值</span></span><br><span class="line">	args = framePool.Get().(unsafe.Pointer) <span class="comment">// 那么就为当前函数的参数和返回值分配内存空间</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">	args = unsafe_New(frametype)  <span class="comment">// 否则就全新开辟一块内存空间</span></span><br><span class="line">&#125;</span><br><span class="line">off := <span class="type">uintptr</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> rcvrtype != <span class="literal">nil</span> &#123; <span class="comment">// 如果当前函数是方法</span></span><br><span class="line">	storeRcvr(rcvr, args) <span class="comment">// 将方法的接收者拷贝到内存中</span></span><br><span class="line">	off = ptrSize</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> in &#123; <span class="comment">// 将所有函数入参按照顺序依次拷贝到args内存中</span></span><br><span class="line">	targ := t.In(i).(*rtype)</span><br><span class="line">	a := <span class="type">uintptr</span>(targ.align)</span><br><span class="line">	off = (off + a - <span class="number">1</span>) &amp;^ (a - <span class="number">1</span>)</span><br><span class="line">	n := targ.size</span><br><span class="line">	...</span><br><span class="line">	addr := add(args, off, <span class="string">&quot;n &gt; 0&quot;</span>)</span><br><span class="line">	v = v.assignTo(<span class="string">&quot;reflect.Value.Call&quot;</span>, targ, addr)</span><br><span class="line">	*(*unsafe.Pointer)(addr) = v.ptr</span><br><span class="line">	off += n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol type="1">
<li><p>通过 <a
href="https://draveness.me/golang/tree/reflect.funcLayout"><code>reflect.funcLayout</code></a>
计算当前函数需要的参数和返回值的栈布局，也就是每一个参数和返回值所占的空间大小；</p></li>
<li><p>如果当前函数有返回值，需要为当前函数的参数和返回值分配一片内存空间
<code>args</code>；</p></li>
<li><p>如果当前函数是方法，需要向将方法的接收接收者者拷贝到
<code>args</code> 内存中；</p></li>
<li><p>将所有函数的参数按照顺序依次拷贝到对应<code>args</code>内存中</p>
<ol type="1">
<li><p>使用<strong><code>reflect.funLayout</code>返回的参数</strong>计算参数在内存中的位置；</p>
<blockquote>
<p>这个返回的参数是什么意思鸭？</p>
</blockquote></li>
<li><p>将参数拷贝到内存空间中；</p></li>
</ol></li>
</ol>
<h4 id="调用函数">调用函数</h4>
<p>准备好调用函数需要的全部参数后，就会通过下面的代码执行函数指针了。函数入参是<strong>栈类型、函数指针、参数、和返回值的内存空间、栈的大小，以及返回值的偏移量：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">call(frametype, fn, args, <span class="type">uint32</span>(frametype.size), <span class="type">uint32</span>(retOffset))</span><br></pre></td></tr></table></figure>
<p>上述函数实际上并不存在，他会在编译期间链接到<code>reflect.reflectcall</code>这个用汇编语言实现的函数上。</p>
<h4 id="处理返回值">处理返回值</h4>
<p>当函数调用结束以后，就会开始处理函数的返回值：</p>
<ul>
<li>如果函数没有任何返回值，会直接清空args中的全部内容来释放内存空间；</li>
<li>如果当前函数有返回值：
<ol type="1">
<li>将<code>args</code>中于输入参数有关的内存空间清空；</li>
<li>创建一个<code>nout</code>长度的切片用于保存由反射对象构成的返回值数组；</li>
<li>从函数对象中获取返回值的类型和内存大小，将<code>args</code>内存中的数据转换成<code>reflect.Value</code>类型并存储到切片中；</li>
</ol></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">	<span class="keyword">var</span> ret []Value</span><br><span class="line">	<span class="keyword">if</span> nout == <span class="number">0</span> &#123; <span class="comment">//  如果函数没有返回值</span></span><br><span class="line">		typedmemclr(frametype, args)   <span class="comment">// 清空args释放空间</span></span><br><span class="line">		framePool.Put(args)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果函数有返回值</span></span><br><span class="line">		typedmemclrpartial(frametype, args, <span class="number">0</span>, retOffset) <span class="comment">// 将args中输入参数有关的内存空间清空</span></span><br><span class="line">		ret = <span class="built_in">make</span>([]Value, nout)   <span class="comment">// 新建一个切片来保存返回值数组</span></span><br><span class="line">		off = retOffset</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; nout; i++ &#123; </span><br><span class="line">			tv := t.Out(i)</span><br><span class="line">			a := <span class="type">uintptr</span>(tv.Align())</span><br><span class="line">			off = (off + a - <span class="number">1</span>) &amp;^ (a - <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">if</span> tv.Size() != <span class="number">0</span> &#123;</span><br><span class="line">				fl := flagIndir | flag(tv.Kind())</span><br><span class="line">				ret[i] = Value&#123;tv.common(), add(args, off, <span class="string">&quot;tv.Size() != 0&quot;</span>), fl&#125; <span class="comment">// 从函数对象中获取返回值的类型和内存大小，将 args 内存中的数据转换成 reflect.Value 类型并存储到切片中</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				ret[i] = Zero(tv)</span><br><span class="line">			&#125;</span><br><span class="line">			off += tv.Size()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由<code>reflect.Value</code>构成的ret数组会被返回到调用方，到此使用反射实现函数调用的过程就结束了，</p>
<h2 id="小结">小结</h2>
<p>Go 语言的 <a
href="https://golang.org/pkg/reflect/"><code>reflect</code></a>
包为我们提供了多种能力，包括如何使用反射来动态修改变量、判断类型是否实现了某些接口以及动态调用方法等功能，通过分析反射包中方法的原理能帮助我们理解之前看起来比较怪异、令人困惑的现象。</p>
<h2 id="鸣谢">鸣谢</h2>
<p>https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-reflect</p>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>golang LogAgent 项目实战（一）</title>
    <url>/p/LogAgent-project-action-in-golang-1/</url>
    <content><![CDATA[<p>本文主要记录了学习golang时做的一个项目：日志收集项目。</p>
<p><strong>关键词：日志收集项目</strong></p>
<span id="more"></span>
<h2 id="项目背景">项目背景</h2>
<p>每个业务系统都有日志，当系统出现问题时，
需要通过日志信息来定位和解决问题。当系统机器比较少时，登录到服务器上查看即可满足；当系统机器规模巨大，登录到服务器上查看几乎不现实（分布式系统，一个系统部署在是十几台服务器上）</p>
<h2 id="解决方案">解决方案</h2>
<p>把机器上的日志<strong>实时收集</strong>，<strong>统一存储</strong>到中心系统。再对这些日志<strong>建立索引</strong>，通过搜索即可<strong>快速找到</strong>对应的日志记录。</p>
<p>通过提供一个<strong>界面友好</strong>的web页面实现日志的展示和检索。</p>
<h2 id="面临的问题">面临的问题</h2>
<p>实时日志量非常大，每条处理几十亿条，日志准实时收集，延迟控制在分钟级别。</p>
<p>系统的架构设计能够支持<strong>水平扩展</strong>。</p>
<h2 id="业界方案">业界方案</h2>
<h3 id="elk">ELK</h3>
<p><img data-src="image-20211130213650745.png" /></p>
<p><img data-src="image-20211130213933474.png" /></p>
<h3 id="elk方案的问题">ELK方案的问题</h3>
<ul>
<li>运维成本高，每增加一个日志收集项，都需要手动配置；</li>
<li>监控（Beats，现在有了）缺失，无法准确获取<strong>logstash</strong>的状态；</li>
<li>无法做到定制化开发和维护。</li>
</ul>
<h2 id="日志收集系统架构设计">日志收集系统架构设计</h2>
<p><img data-src="image-20211130214306450.png" /></p>
<h3 id="优势">优势</h3>
<ul>
<li>基于etcd实现了配置的自动发现</li>
</ul>
<h3 id="组件介绍">组件介绍</h3>
<ul>
<li>LogAgent：日志收集客户端，用来收集服务器上的日志</li>
<li>Kafka：高吞吐量的分布式队列（Linkin开源，Apache顶级开源项目）</li>
<li>ElasticSearch：开源的搜索引擎，提供基于HTTP RESTful的web接口</li>
<li>Kibaa：开源的ES数据引起分析和可视化工具</li>
<li>Hadoop：分布式计算框架，能够对大量数据进行分布式处理的平台</li>
<li>Storm：一个免费并开源的分布式实时计算系统</li>
</ul>
<h3 id="将学到的技能">将学到的技能</h3>
<ul>
<li>服务端Agent开发</li>
<li>后端服务组件开发</li>
<li>ES和Kibana的使用</li>
<li>Kafka和zookeeper的使用</li>
<li>etcd的使用</li>
</ul>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu配置jdk-12环境</title>
    <url>/p/install-jdk12-on-ubuntu2004/</url>
    <content><![CDATA[<p>本文介绍如何在Ubuntu 20.04 LTS系统上配置jdk开发环境。</p>
<p><strong>关键词：jdk，ubuntu，linux</strong></p>
<span id="more"></span>
<h3 id="下载jdk">下载jdk</h3>
<p>下载相应版本的jdk，这里以jdk-12为例：</p>
<p>https://www.oracle.com/java/technologies/javase/jdk12-archive-downloads.html</p>
<p><img data-src="image-20211130153041694.png" /></p>
<p>此处需要登录Oracle账号。</p>
<p>根据自己的系统类型选择即可，这里选择打包好的<strong>二进制文件.tar.gz</strong>。</p>
<p>下载完上传到服务器即可。</p>
<h3 id="安装jdk">安装jdk</h3>
<h4 id="解压文件">解压文件</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar xvfz jdk-12.0.2_linux-x64_bin.tar.gz</span><br></pre></td></tr></table></figure>
<p>移动到目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">mv</span> jdk-12.0.2 /usr/local/</span><br></pre></td></tr></table></figure>
<h4 id="设置环境变量">设置环境变量</h4>
<p>设置环境变量一般有三种：</p>
<ul>
<li><code>/etc/profile</code>：对全部用户生效，对所有shell解释器生效；</li>
<li><code>/etc/bash.bashrc</code>：对全部用户生效，对bash解释器生效；</li>
<li><code>/home/&lt;user_name&gt;/.bashrc</code>：仅对当前用户名生效，对bash解释器生效。</li>
</ul>
<p>这里选择第二种。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/local/jdk-12.0.2</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="comment"># export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span></span><br></pre></td></tr></table></figure>
<h3 id="检查jdk是否安装成功">检查jdk是否安装成功</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure>
<p><img data-src="image-20211130155722694.png" /></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">javac -version</span><br></pre></td></tr></table></figure>
<p><img data-src="image-20211130155802514.png" /></p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu安装kafka和zookeeper并设置开机自动启动</title>
    <url>/p/install-kafka-on-ubuntu2004/</url>
    <content><![CDATA[<p>kafka是一个分布式消息队列。具有高性能、持久化、多副本备份、横向扩展能力。生产者往队列里写消息，消费者从队列里取消息进行业务逻辑。一般在架构设计中起到解耦、削峰、异步处理的作用。kafka对外使用topic的概念，生产者往topic里写消息，消费者从读消息。为了做到水平扩展，一个topic实际是由多个partition组成的，遇到瓶颈时，可以通过增加partition的数量来进行横向扩容。单个parition内是保证消息有序。每新写一条消息，kafka就是在对应的文件append写，所以性能非常高。</p>
<p>本文介绍如何在ubuntu上安装kafka并设置开机自动启动。</p>
<p><strong>关键词：kafka，ubuntu，linux</strong></p>
<span id="more"></span>
<h3 id="安装kafka">安装kafka</h3>
<h4 id="下载">下载</h4>
<p>下载地址：https://kafka.apache.org/downloads</p>
<p>这里以 <strong><a
href="https://www.apache.org/dyn/closer.cgi?path=/kafka/3.0.0/kafka_2.12-3.0.0.tgz">kafka_2.12-3.0.0.tgz</a>
</strong>为例。</p>
<h4 id="解压">解压</h4>
<p>下载完毕以后上传到服务器并将其解压：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -xvzf kafka_2.12-3.0.0.tgz</span><br></pre></td></tr></table></figure>
<h4 id="修改配置">修改配置</h4>
<p>默认配置
<code>advertised.listeners=PLAINTEXT://your.host.name:9092</code>修改为</p>
<p><code>advertised.listeners=PLAINTEXT://&lt;ip&gt;:9092</code></p>
<p>其中ip是服务器ip，hostname和端口是用来建议给生产者和消费者使用的，如果没有设置，将会使用<strong>listener</strong>的设置；</p>
<p>如果<strong>listener</strong>也没有设置，将使用<code>java.net.InetAddress.getCanonicalHostName()</code>来获取hostname和port，通常这个获取的值就是<code>localhost</code>.</p>
<p>"PLAINTEXT"表示协议，可选的值有PLAINTEXT和SSL，hostname可以指定IP地址，<strong>不可以用"0.0.0.0"</strong>，一般用<strong>公网ip</strong>或者<strong>局域网内的ip</strong>。</p>
<p>如果hostname为空表示只对默认的网络接口(localhost)有效；如果没有配置advertised.listeners，就使用listeners的配置通告给消息的生产者和消费者，这个过程是在生产者和消费者获取源数据(metadata)。</p>
<h4 id="其他配置">其他配置</h4>
<p>见文末。</p>
<h3 id="运行kafka">运行kafka</h3>
<h4 id="安装jdk">安装JDK</h4>
<p>运行kafka之前还需要安装JDK，具体可参考笔者的这篇文章：</p>
<p><a
href="https://fly97.cn/p/install-jdk12-on-ubuntu2004/">Ubuntu配置jdk-12环境</a></p>
<h4 id="运行zookeeper">运行zookeeper</h4>
<p>运行kafka之前需要先打开zookeeper，否则会报错。</p>
<p><img data-src="image-20211130195707407.png" /></p>
<p>可以在zookeeper.properties修改存放数据的文件地址，默认是<code>/tmp/zookeeper</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> kafka_2.12-3.0.0</span><br><span class="line">./bin/zookeeper-server-start.sh config/zookeeper.properties</span><br></pre></td></tr></table></figure>
<p>运行成功：</p>
<p><img data-src="image-20211130195517170.png" /></p>
<h4 id="运行kafka-1">运行kafka</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> kafka_2.12-3.0.0</span><br><span class="line">./bin/kafka-server-start.sh config/server.properties</span><br></pre></td></tr></table></figure>
<p>运行成功：</p>
<p><img data-src="image-20211130195908228.png" /></p>
<h5 id="kafka终端读取消费数据">kafka终端读取（消费）数据</h5>
<p>Windows:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bin\windows\kafka-console-consumer.bat --bootstrap-server=127.0.0.1:9092 --topic=web_log --from-beginning</span><br></pre></td></tr></table></figure>
<h3 id="设置自动启动">设置自动启动</h3>
<h4 id="编写启动脚本">编写启动脚本</h4>
<p>将上述两个命令封装成bash脚本：</p>
<ul>
<li>init-zookeeper.sh：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">trap</span> <span class="string">&quot;echo &#x27;Zookeeper Stopped.&#x27;; exit 0;&quot;</span> INT TERM</span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/local/jdk-12.0.2</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Init Zookeeper Service&quot;</span></span><br><span class="line"><span class="built_in">cd</span> /home/wf09/kafka</span><br><span class="line">./bin/zookeeper-server-start.sh config/zookeeper.properties</span><br><span class="line"><span class="built_in">exit</span> 255</span><br></pre></td></tr></table></figure>
<ul>
<li>init-kafka.sh</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">trap</span> <span class="string">&quot;echo &#x27;Kafka Stopped.&#x27;; exit 0;&quot;</span> INT TERM</span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/local/jdk-12.0.2</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Init Kafka Service&quot;</span></span><br><span class="line"><span class="built_in">cd</span> /home/wf09/kafka</span><br><span class="line">./bin/kafka-server-start.sh config/server.properties</span><br><span class="line"><span class="built_in">exit</span> 255</span><br></pre></td></tr></table></figure>
<h4 id="编写服务文件">编写服务文件</h4>
<ul>
<li>zerokeeper.service</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=zerokeeper-service</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line"><span class="comment">#KillMode=mixed</span></span><br><span class="line">User=wf09</span><br><span class="line">Type=simple</span><br><span class="line">ExecStart=/bin/bash /home/wf09/init-zookeeper.sh</span><br><span class="line">ExecStop=/bin/kill -s SIGTERM <span class="variable">$MAINPID</span></span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>
<ul>
<li>kafka.service</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Kafka-service</span><br><span class="line">After=network.target</span><br><span class="line">Requires=zookeeper.service</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line"><span class="comment">#KillMode=mixed</span></span><br><span class="line">User=wf09</span><br><span class="line">Type=simple</span><br><span class="line">ExecStart=/bin/bash /home/wf09/init-kafka.sh</span><br><span class="line">ExecStop=/bin/kill -s SIGTERM <span class="variable">$MAINPID</span></span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>
<h4 id="设置自动启动-1">设置自动启动</h4>
<p>设置自动启动可以参考笔者的这一篇文章</p>
<p><a
href="https://fly97.cn/p/How-to-manage-services-on-ubuntu/">Ubuntu服务管理</a></p>
<h3 id="kafka其他配置">kafka其他配置</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Licensed to the Apache Software Foundation (ASF) under one or more</span></span><br><span class="line"><span class="comment"># contributor license agreements.  See the NOTICE file distributed with</span></span><br><span class="line"><span class="comment"># this work for additional information regarding copyright ownership.</span></span><br><span class="line"><span class="comment"># The ASF licenses this file to You under the Apache License, Version 2.0</span></span><br><span class="line"><span class="comment"># (the &quot;License&quot;); you may not use this file except in compliance with</span></span><br><span class="line"><span class="comment"># the License.  You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line"><span class="comment"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"># See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"># limitations under the License.</span></span><br><span class="line"><span class="comment"># see kafka.server.KafkaConfig for additional details and defaults</span></span><br><span class="line"></span><br><span class="line"><span class="comment">############################# Server Basics #############################</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##################################################################################</span></span><br><span class="line"><span class="comment">#  broker就是一个kafka的部署实例，在一个kafka集群中，每一台kafka都要有一个broker.id</span></span><br><span class="line"><span class="comment">#  并且，该id唯一，且必须为整数</span></span><br><span class="line"><span class="comment">##################################################################################</span></span><br><span class="line">broker.id=10</span><br><span class="line"></span><br><span class="line"><span class="comment">############################# Socket Server Settings #############################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The address the socket server listens on. It will get the value returned from </span></span><br><span class="line"><span class="comment"># java.net.InetAddress.getCanonicalHostName() if not configured.</span></span><br><span class="line"><span class="comment">#   FORMAT:</span></span><br><span class="line"><span class="comment">#     listeners = security_protocol://host_name:port</span></span><br><span class="line"><span class="comment">#   EXAMPLE:</span></span><br><span class="line"><span class="comment">#     listeners = PLAINTEXT://your.host.name:9092</span></span><br><span class="line"><span class="comment">#listeners=PLAINTEXT://:9092</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Hostname and port the broker will advertise to producers and consumers. If not set, </span></span><br><span class="line"><span class="comment"># it uses the value for &quot;listeners&quot; if configured.  Otherwise, it will use the value</span></span><br><span class="line"><span class="comment"># returned from java.net.InetAddress.getCanonicalHostName().</span></span><br><span class="line"><span class="comment">#advertised.listeners=PLAINTEXT://your.host.name:9092</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##################################################################################</span></span><br><span class="line"><span class="comment">#The number of threads handling network requests</span></span><br><span class="line"><span class="comment"># 默认处理网络请求的线程个数 3个</span></span><br><span class="line"><span class="comment">##################################################################################</span></span><br><span class="line">num.network.threads=3</span><br><span class="line"><span class="comment">##################################################################################</span></span><br><span class="line"><span class="comment"># The number of threads doing disk I/O</span></span><br><span class="line"><span class="comment"># 执行磁盘IO操作的默认线程个数 8</span></span><br><span class="line"><span class="comment">##################################################################################</span></span><br><span class="line">num.io.threads=8</span><br><span class="line"></span><br><span class="line"><span class="comment">##################################################################################</span></span><br><span class="line"><span class="comment"># The send buffer (SO_SNDBUF) used by the socket server</span></span><br><span class="line"><span class="comment"># socket服务使用的进行发送数据的缓冲区大小，默认100kb</span></span><br><span class="line"><span class="comment">##################################################################################</span></span><br><span class="line">socket.send.buffer.bytes=102400</span><br><span class="line"></span><br><span class="line"><span class="comment">##################################################################################</span></span><br><span class="line"><span class="comment"># The receive buffer (SO_SNDBUF) used by the socket server</span></span><br><span class="line"><span class="comment"># socket服务使用的进行接受数据的缓冲区大小，默认100kb</span></span><br><span class="line"><span class="comment">##################################################################################</span></span><br><span class="line">socket.receive.buffer.bytes=102400</span><br><span class="line"></span><br><span class="line"><span class="comment">##################################################################################</span></span><br><span class="line"><span class="comment"># The maximum size of a request that the socket server will accept (protection against OOM)</span></span><br><span class="line"><span class="comment"># socket服务所能够接受的最大的请求量，防止出现OOM(Out of memory)内存溢出，默认值为：100m</span></span><br><span class="line"><span class="comment"># （应该是socker server所能接受的一个请求的最大大小，默认为100M）</span></span><br><span class="line"><span class="comment">##################################################################################</span></span><br><span class="line">socket.request.max.bytes=104857600</span><br><span class="line"></span><br><span class="line"><span class="comment">############################# Log Basics （数据相关部分，kafka的数据称为log）#############################</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##################################################################################</span></span><br><span class="line"><span class="comment"># A comma seperated list of directories under which to store log files</span></span><br><span class="line"><span class="comment"># 一个用逗号分隔的目录列表，用于存储kafka接受到的数据</span></span><br><span class="line"><span class="comment">##################################################################################</span></span><br><span class="line">log.dirs=/home/uplooking/data/kafka</span><br><span class="line"></span><br><span class="line"><span class="comment">##################################################################################</span></span><br><span class="line"><span class="comment"># The default number of log partitions per topic. More partitions allow greater</span></span><br><span class="line"><span class="comment"># parallelism for consumption, but this will also result in more files across</span></span><br><span class="line"><span class="comment"># the brokers.</span></span><br><span class="line"><span class="comment"># 每一个topic所对应的log的partition分区数目，默认1个。更多的partition数目会提高消费</span></span><br><span class="line"><span class="comment"># 并行度，但是也会导致在kafka集群中有更多的文件进行传输</span></span><br><span class="line"><span class="comment"># （partition就是分布式存储，相当于是把一份数据分开几份来进行存储，即划分块、划分分区的意思）</span></span><br><span class="line"><span class="comment">##################################################################################</span></span><br><span class="line">num.partitions=1</span><br><span class="line"></span><br><span class="line"><span class="comment">##################################################################################</span></span><br><span class="line"><span class="comment"># The number of threads per data directory to be used for log recovery at startup and flushing at shutdown.</span></span><br><span class="line"><span class="comment"># This value is recommended to be increased for installations with data dirs located in RAID array.</span></span><br><span class="line"><span class="comment"># 每一个数据目录用于在启动kafka时恢复数据和在关闭时刷新数据的线程个数。如果kafka数据存储在磁盘阵列中</span></span><br><span class="line"><span class="comment"># 建议此值可以调整更大。</span></span><br><span class="line"><span class="comment">##################################################################################</span></span><br><span class="line">num.recovery.threads.per.data.dir=1</span><br><span class="line"></span><br><span class="line"><span class="comment">############################# Log Flush Policy （数据刷新策略）#############################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Messages are immediately written to the filesystem but by default we only fsync() to sync</span></span><br><span class="line"><span class="comment"># the OS cache lazily. The following configurations control the flush of data to disk.</span></span><br><span class="line"><span class="comment"># There are a few important trade-offs（平衡） here:</span></span><br><span class="line"><span class="comment">#    1. Durability 持久性: Unflushed data may be lost if you are not using replication.</span></span><br><span class="line"><span class="comment">#    2. Latency 延时性: Very large flush intervals may lead to latency spikes when the flush does occur as there will be a lot of data to flush.</span></span><br><span class="line"><span class="comment">#    3. Throughput 吞吐量: The flush is generally the most expensive operation, and a small flush interval may lead to exceessive seeks.</span></span><br><span class="line"><span class="comment"># The settings below allow one to configure the flush policy to flush data after a period of time or</span></span><br><span class="line"><span class="comment"># every N messages (or both). This can be done globally and overridden on a per-topic basis.</span></span><br><span class="line"><span class="comment"># kafka中只有基于消息条数和时间间隔数来制定数据刷新策略，而没有大小的选项，这两个选项可以选择配置一个</span></span><br><span class="line"><span class="comment"># 当然也可以两个都配置，默认情况下两个都配置，配置如下。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The number of messages to accept before forcing a flush of data to disk</span></span><br><span class="line"><span class="comment"># 消息刷新到磁盘中的消息条数阈值</span></span><br><span class="line"><span class="comment">#log.flush.interval.messages=10000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The maximum amount of time a message can sit in a log before we force a flush</span></span><br><span class="line"><span class="comment"># 消息刷新到磁盘生成一个log数据文件的时间间隔</span></span><br><span class="line"><span class="comment">#log.flush.interval.ms=1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">############################# Log Retention Policy（数据保留策略） #############################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The following configurations control the disposal（清理） of log segments（分片）. The policy can</span></span><br><span class="line"><span class="comment"># be set to delete segments after a period of time, or after a given size has accumulated（累积）.</span></span><br><span class="line"><span class="comment"># A segment will be deleted whenever（无论什么时间） *either* of these criteria（标准） are met. Deletion always happens</span></span><br><span class="line"><span class="comment"># from the end of the log.</span></span><br><span class="line"><span class="comment"># 下面的配置用于控制数据片段的清理，只要满足其中一个策略（基于时间或基于大小），分片就会被删除</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The minimum age of a log file to be eligible for deletion</span></span><br><span class="line"><span class="comment"># 基于时间的策略，删除日志数据的时间，默认保存7天</span></span><br><span class="line">log.retention.hours=168</span><br><span class="line"></span><br><span class="line"><span class="comment"># A size-based retention policy for logs. Segments are pruned from the log as long as the remaining</span></span><br><span class="line"><span class="comment"># segments don&#x27;t drop below log.retention.bytes. 1G</span></span><br><span class="line"><span class="comment"># 基于大小的策略，1G</span></span><br><span class="line"><span class="comment">#log.retention.bytes=1073741824</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The maximum size of a log segment file. When this size is reached a new log segment will be created.</span></span><br><span class="line"><span class="comment"># 数据分片策略</span></span><br><span class="line">log.segment.bytes=1073741824</span><br><span class="line"></span><br><span class="line"><span class="comment"># The interval at which log segments are checked to see if they can be deleted according</span></span><br><span class="line"><span class="comment"># to the retention policies 5分钟</span></span><br><span class="line"><span class="comment"># 每隔多长时间检测数据是否达到删除条件</span></span><br><span class="line">log.retention.check.interval.ms=300000</span><br><span class="line"></span><br><span class="line"><span class="comment">############################# Zookeeper #############################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Zookeeper connection string (see zookeeper docs for details).</span></span><br><span class="line"><span class="comment"># This is a comma separated host:port pairs, each corresponding to a zk</span></span><br><span class="line"><span class="comment"># server. e.g. &quot;127.0.0.1:3000,127.0.0.1:3001,127.0.0.1:3002&quot;.</span></span><br><span class="line"><span class="comment"># You can also append an optional chroot string to the urls to specify the</span></span><br><span class="line"><span class="comment"># root directory for all kafka znodes.</span></span><br><span class="line">zookeeper.connect=uplooking01:2181,uplooking02:2181,uplooking03:2181</span><br><span class="line"></span><br><span class="line"><span class="comment"># Timeout in ms for connecting to zookeeper</span></span><br><span class="line">zookeeper.connection.timeout.ms=6000</span><br></pre></td></tr></table></figure>
<h3 id="参考链接">参考链接</h3>
<ul>
<li>https://www.cnblogs.com/toutou/p/linux_install_kafka.html</li>
</ul>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言进阶（一）并发同步实现的四种方法</title>
    <url>/p/producer-consumer-model-in-golang/</url>
    <content><![CDATA[<p>本文主要介绍golang源代码实现了四种并发同步的方法。</p>
<p><strong>关键词</strong>：golang，并发实现</p>
<span id="more"></span>
<p>大家都知道Golang天生支持并发，任何一个函数前面使用go关键字都能实现并发。go给我们提供了详细的并发原语，总体来说有四种实现并发同步的方法。</p>
<h2 id="waitbysleep">waitBySleep</h2>
<p>主线程显式调用sleep函数等待子线程完成</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">waitBySleep</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> fmt.Println(<span class="string">&quot;this is&quot;</span>, i)</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	waitBySleep()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>sleep的时间根据任务的复杂程度<strong>难以估算</strong>，不是最佳实践</p>
<h2 id="waitbychannel">waitByChannel</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">waitByChannel</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">10</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;this is&quot;</span>, i)</span><br><span class="line">			c &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		&lt;-c</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	waitByChannel()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过channl可以并发读写的机制，并发的子线程将执行完毕的标志位送到channel里，主线程将channel内的标志位消费完，说明子线程已经执行完毕。</p>
<p>适合明确<strong>子线程的任务有多少个情况下</strong>，也不是最佳实践。</p>
<h3
id="使用channel实现的生产消费者模型">使用Channel实现的生产消费者模型</h3>
<p>一个简易的<strong>生产者消费者模型</strong>代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(id <span class="type">int</span>, jobs &lt;-<span class="keyword">chan</span> <span class="type">int</span>, results <span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span></span> &#123; <span class="comment">// jobs:只读通道，result:只写通道</span></span><br><span class="line">    <span class="keyword">for</span> j := <span class="keyword">range</span> jobs &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;worker:%d start jobs:%d\n&quot;</span>, id, j)</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">        fmt.Printf(<span class="string">&quot;worker:%d end jobs:%d\n&quot;</span>, id, j)</span><br><span class="line">        results &lt;- j * <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    jobs := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">100</span>)</span><br><span class="line">    results := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">100</span>)</span><br><span class="line">    <span class="comment">// 开启3个goroutine</span></span><br><span class="line">    <span class="keyword">for</span> w := <span class="number">1</span>; w &lt; <span class="number">3</span>; w++ &#123;</span><br><span class="line">        <span class="keyword">go</span> worker(w, jobs, results)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 分配5个任务</span></span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= <span class="number">5</span>; j++ &#123;</span><br><span class="line">        jobs &lt;- j</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(jobs) <span class="comment">// 关闭通道</span></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="keyword">for</span> a := <span class="number">1</span>; a &lt;= <span class="number">5</span>; a++ &#123;</span><br><span class="line">        &lt;-results <span class="comment">// 取出的过程是阻塞的，要等待每一个worker执行完</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="waitbywaitgroup">waitByWaitGroup</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">waitByWaitGroup</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	wg.Add(<span class="number">10</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;this is&quot;</span>, i)</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    waitByWaitGroup()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本质上还是等待，只是等待的时刻缩短到子线程结束调用的那一时刻。</p>
<p>依靠sync.WaitGroup不能实现生产者消费者模型，需要配合channel完成</p>
<h2 id="waitbycond">waitByCond</h2>
<p><code>sync.Cond</code>是go语言原生提供的生产者消费者模型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Queue <span class="keyword">struct</span> &#123;</span><br><span class="line">	queue []<span class="type">int</span></span><br><span class="line">	cond  *sync.Cond</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span></span> Producer(in <span class="type">int</span>) &#123;</span><br><span class="line">	q.cond.L.Lock()</span><br><span class="line">	<span class="keyword">defer</span> q.cond.L.Unlock()</span><br><span class="line">	q.queue = <span class="built_in">append</span>(q.queue, in)</span><br><span class="line">	q.cond.Broadcast()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span></span> Consumer() (result <span class="type">int</span>) &#123;</span><br><span class="line">	q.cond.L.Lock()</span><br><span class="line">	<span class="keyword">defer</span> q.cond.L.Unlock()</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(q.queue) == <span class="number">0</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;no data available, waiting&quot;</span>)</span><br><span class="line">		q.cond.Wait()</span><br><span class="line">	&#125;</span><br><span class="line">	result, q.queue = q.queue[<span class="number">0</span>], q.queue[<span class="number">1</span>:]</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">waitByCond</span><span class="params">()</span></span> &#123;</span><br><span class="line">	q := Queue&#123;</span><br><span class="line">		queue: []<span class="type">int</span>&#123;&#125;,</span><br><span class="line">		cond:  sync.NewCond(&amp;sync.Mutex&#123;&#125;),</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= <span class="number">5</span>; j++ &#123;</span><br><span class="line">		<span class="keyword">go</span> q.Producer(j)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> a := <span class="number">1</span>; a &lt;= <span class="number">5</span>; a++ &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;this is&quot;</span>, q.Consumer())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	waitByCond()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>在debian中使用Coturn创建和配置自己的STUN/TURN服务器</title>
    <url>/p/install-and-configure-coturn-in-debian/</url>
    <content><![CDATA[<p>在debian中使用Coturn创建和配置自己的STUN/TURN服务器</p>
<p><strong>关键词</strong>：coturn，stun，turn</p>
<span id="more"></span>
<p>安装Coturn一般分为两步。</p>
<p>第一步要查看安装的openssl版本，然后安装<a
href="https://github.com/libevent/libevent">libevent</a>。</p>
<p>第二步是安装Coturn。</p>
<h2 id="安装libevent">安装libevent</h2>
<p>相关地址：</p>
<ul>
<li>https://github.com/libevent/libevent</li>
<li>https://codechina.csdn.net/mirrors/libevent/libevent</li>
</ul>
<p><strong>注意</strong></p>
<p>libevent与openssl的版本对应关系如下：</p>
<table>
<thead>
<tr class="header">
<th>libevent</th>
<th>openssl</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>2.1.x</td>
<td>1.1</td>
</tr>
<tr class="even">
<td>2.0.x</td>
<td>1.0</td>
</tr>
</tbody>
</table>
<p>如果你的openssl是1.1版本及以上，请安装2.1.x版本的libevent；</p>
<p>如果你的openssl是1.0版本及以上，请安装2.0.x版本的libevent。</p>
<h3 id="查看openssl版本">查看openssl版本</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl version</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@iZuf68ohfhdne8i8wsvd1tZ:~<span class="comment"># openssl version</span></span><br><span class="line">OpenSSL 1.1.1f  31 Mar 2020</span><br></pre></td></tr></table></figure>
<p>这里使用2.1.12的版本进行安装。</p>
<h3 id="下载2.1.12版本libevent">下载2.1.12版本libevent</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://codechina.csdn.net/mirrors/libevent/libevent/-/archive/release-2.1.12-stable/libevent-release-2.1.12-stable.tar.gz</span><br></pre></td></tr></table></figure>
<h3 id="安装openssl依赖">安装openssl依赖</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt update &amp;&amp; sudo apt install libssl-dev -y</span><br></pre></td></tr></table></figure>
<h3 id="编译">编译</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar xvf libevent-release-2.1.12-stable.tar.gz</span><br><span class="line"><span class="built_in">cd</span> libevent-release-2.1.12-stable</span><br><span class="line">./autogen.sh</span><br><span class="line">./configure</span><br><span class="line">make</span><br></pre></td></tr></table></figure>
<h3 id="打包">打包</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install checkinstall -y</span><br><span class="line">sudo checkinstall</span><br></pre></td></tr></table></figure>
<p><img data-src="image-20211212133649851.png" /></p>
<p>这里需要把3 - Version: [ stable ]
修改成版本号，否则后面安装不成功。</p>
<p><img data-src="image-20211212133609907.png" /></p>
<h3 id="安装成功">安装成功</h3>
<p><img data-src="image-20211212133729426.png" /></p>
<h2 id="安装coturn">安装Coturn</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install coturn -y</span><br></pre></td></tr></table></figure>
<p>可参考：https://www.webrtc-experiment.com/docs/TURN-server-installation-guide.html#coturn</p>
<h3 id="turn数据库配置">TURN数据库配置</h3>
<p><strong>增加用户：</strong>增加普通long-term
TURN用户，用于WebRTC的登陆。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo turnadmin -a -u &lt;username&gt; -r &lt;realm&gt; -p &lt;password&gt;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>如果不用默认db也可以通过命令行配置需要使用的db文件路径</li>
<li>需要sudo否则无法写入db文件，查询为空，或者给db文件改权限。</li>
<li>如果没有安装sqlite并不会报错，只是查询为空。</li>
</ul>
<p><strong>安装sqlite</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install sqlite3 libsqlite3-dev</span><br></pre></td></tr></table></figure>
<p>如果报错：<code>turnadmin: error while loading shared libraries: libmysqlclient.so.21</code></p>
<p>需要安装libmysqlclient-dev：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libmysqlclient-dev</span><br></pre></td></tr></table></figure>
<p><strong>查看当前的普通用户</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">turnadmin -l</span><br></pre></td></tr></table></figure>
<p><strong>删除普通用户</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">turnadmin -d -u &lt;username&gt; -r &lt;realm&gt;</span><br></pre></td></tr></table></figure>
<h3 id="修改turn服务配置文件">修改TURN服务配置文件</h3>
<p>配置文件路径为<code>/etc/turnserver.conf</code></p>
<p>先将原来的默认配置复制一份，然后在添加新的配置文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">mv</span> /etc/turnserver.conf /etc/turnserver.conf.bak</span><br><span class="line">sudo vim /etc/turnserver.conf</span><br></pre></td></tr></table></figure>
<p>一些常用的配置：</p>
<p>其中cert和pkey的文件地址请根据下一步<strong>使用openssl生成证书和密钥</strong>的文件路径来修改你的配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 本地监听外网的网卡设备，默认eth0</span><br><span class="line">listening-ip=172.17.62.224</span><br><span class="line">listening-device=eth0</span><br><span class="line"># TURN服务器UDP/TCP监听端口，默认：3478，同时根据协议会自动开启3479</span><br><span class="line"># 应该需要防火墙开放端口</span><br><span class="line">listening-port=3478</span><br><span class="line"># TURN服务器TLS监听端口，默认5349，自动开启5350</span><br><span class="line">tls-listening-port=5349</span><br><span class="line">#本地用于转发的网卡设备，默认eth0</span><br><span class="line">relay-device=eth0</span><br><span class="line"># UDP中继端口范围，用于UDP转发，注意安全组放通</span><br><span class="line"># (default values are 49152 and 65535)</span><br><span class="line">min-port=49152</span><br><span class="line">max-port=65535</span><br><span class="line"></span><br><span class="line"># 日志输出级别，turnserver 启动时加上 -v,可以得到更清晰的日志输出，默认关闭</span><br><span class="line">Verbose</span><br><span class="line"># 消息验证，WebRTC 的消息里会用到，默认关闭</span><br><span class="line">fingerprint</span><br><span class="line"></span><br><span class="line"># long-term验证机制，webrtc 通过 TURN中继使用的验证方式，默认关闭即不需要认证机制。</span><br><span class="line">lt-cred-mech</span><br><span class="line"></span><br><span class="line"># 默认域Realm</span><br><span class="line"># 当在数据库中没有显示的域关系定义时，或没有使用任何db时使用。</span><br><span class="line"># 配合long-term认证机制或者TURN REST API使用，需要设置。</span><br><span class="line">realm=deepsoft</span><br><span class="line"></span><br><span class="line"># TURN REST API 认证标记。</span><br><span class="line"># 但无法同时使用lt-cred-mech和use-auth-secret两种方式，保持注释</span><br><span class="line"># use-auth-secret</span><br><span class="line"># REST API 加密所需的&#x27;静态&#x27; KEY，同保持注释</span><br><span class="line"># static-auth-secret</span><br><span class="line"></span><br><span class="line"># 启用DH密钥交换算法</span><br><span class="line">dh2066</span><br><span class="line"># 认证文件和私钥，用户TLS加密传输。</span><br><span class="line">cert=/root/ssl/cert.pem </span><br><span class="line">pkey=/root/ssl/certs/key.pem</span><br><span class="line"></span><br><span class="line">#屏蔽multicast IP地址（224.0.0.0 and above）的 转发</span><br><span class="line">no-multicast-peers</span><br></pre></td></tr></table></figure>
<h3 id="使用openssl生成证书和密钥">使用openssl生成证书和密钥</h3>
<p>tls加密通信需要密钥，可以用openssl工具生成：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> ssl &amp;&amp; <span class="built_in">cd</span> ssl</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl req -x509 -days 1000 -newkey rsa:2048 -keyout ./key.pem -out ./cert.pem -nodes </span><br><span class="line"><span class="comment"># 得到两个文件，拷贝到/cert/目录下备用</span></span><br><span class="line"><span class="comment"># The `req` command primarily creates and processes certificate requests in PKCS#10 format</span></span><br><span class="line"><span class="comment"># -x509 请求签名，输出一个自签名证书，自己充当CA认证</span></span><br><span class="line"><span class="comment"># -days 1000 默认30天，用于-x509天数设置</span></span><br><span class="line"><span class="comment"># -newkey rsa:2048 生成新的认证和私钥</span></span><br><span class="line"><span class="comment"># -nodes 对生成的私钥不加密</span></span><br></pre></td></tr></table></figure>
<h3 id="重启服务">重启服务</h3>
<p>配置文件修改完毕以后需要重启一下服务以便使配置文件生效。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo service coturn restart</span><br></pre></td></tr></table></figure>
<h2 id="配置docker">配置docker</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it --user $(<span class="built_in">id</span> -u):$(<span class="built_in">id</span> -g) \</span><br><span class="line">            --restart=always --name=my-turnserver \</span><br><span class="line">           --network=host \</span><br><span class="line">           -v $(<span class="built_in">pwd</span>)/my.cnf:/etc/coturn/turnserver.conf \</span><br><span class="line">           -v $(<span class="built_in">pwd</span>)/cert.pem:/cert.pem \</span><br><span class="line">           -v $(<span class="built_in">pwd</span>)/key.pem:/key.pem \</span><br><span class="line">        coturn/coturn:alpine</span><br></pre></td></tr></table></figure>
<h2 id="测试是否成功搭建">测试是否成功搭建</h2>
<p>https://webrtc.github.io/samples/src/content/peerconnection/trickle-ice/</p>
<p><img data-src="image-20211127213711931.png" style="zoom:33%;" /></p>
<p><img data-src="image-20211127213631207.png" /></p>
<p><img data-src="image-20211127214043008.png" /></p>
]]></content>
      <tags>
        <tag>coturn</tag>
        <tag>STUN</tag>
        <tag>TURN</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言中的切片、Map和Channel</title>
    <url>/p/slice-map-and-channel-in-golang/</url>
    <content><![CDATA[<p>虽然go语言中函数传参方式都是<strong>值传递</strong>，但以下几种类型可以认为是"引用传递"。</p>
<p><strong>关键词</strong>：golang</p>
<span id="more"></span>
<h2 id="切片">切片</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(testArray []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(testArray); i++ &#123;</span><br><span class="line">		testArray[i] += <span class="number">1</span> <span class="comment">// 函数内部修改切片</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	nums := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;nums: %v\n&quot;</span>, nums)</span><br><span class="line">	test(nums)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;nums: %v\n&quot;</span>, nums)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在函数内部修改了切片，函数外部访问修改也会生效。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go run <span class="string">&quot;testSlice.go&quot;</span></span><br><span class="line">nums: [1 2 3]</span><br><span class="line">nums: [2 3 4]</span><br></pre></td></tr></table></figure>
<h2 id="map">Map</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(testMap <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> k, _ := <span class="keyword">range</span> testMap &#123;</span><br><span class="line">		testMap[k] = <span class="string">&quot;change it&quot;</span> <span class="comment">//函数内部修改map</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	nums := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>&#123;</span><br><span class="line">		<span class="number">1</span>: <span class="string">&quot;one&quot;</span>,</span><br><span class="line">		<span class="number">2</span>: <span class="string">&quot;two&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;nums: %v\n&quot;</span>, nums)</span><br><span class="line">	test(nums)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;nums: %v\n&quot;</span>, nums)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数内部修改了map，外部访问修改也生效。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go run <span class="string">&quot;testMap.go&quot;</span></span><br><span class="line">nums: map[1:one 2:two]</span><br><span class="line">nums: map[1:change it 2:change it]</span><br></pre></td></tr></table></figure>
<h2 id="通道">通道</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testChannel</span><span class="params">(cint <span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		cint &lt;- i</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(cint)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> cint = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1</span>)</span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> testChannel(cint)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> cint &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;i: %v\n&quot;</span>, i)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数<code>testChannel</code>修改<code>channel</code>，主函数访问修改也生效。</p>
<p>其中wg是一个计数器（同步等待组）：</p>
<ol type="1">
<li>主函数在执行协程之前，向计数器传入协程的数量：<code>wg.Add(1)</code>；</li>
<li>子函数（协程）在执行完毕以后，执行<code>wg.Done()</code>来给计数器<code>-1</code>；</li>
<li>主函数最后要执行<code>wg.Wait()</code>，阻塞直到子协程</li>
</ol>
<p>退出。</p>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>使用密钥登陆linux服务器</title>
    <url>/p/login-linux-with-ssh-key/</url>
    <content><![CDATA[<p>为什么使用ssh-key登录服务器？因为这种方法更安全，可以确保我们的服务器不被hack。</p>
<p><strong>关键词</strong>：服务器安全</p>
<span id="more"></span>
<h3 id="安全问题">安全问题</h3>
<p>在登录服务器时，发现了一行提示：</p>
<p><img data-src="image-20211117223431763.png" /></p>
<p>心中一惊，赶紧查看<strong>失败登录记录</strong>，果然发现了有很多<strong>被爆破</strong>的记录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lastb </span><br></pre></td></tr></table></figure>
<p><img data-src="image-20211117223543481.png" /></p>
<p>这让我意识到<strong>使用密码登陆服务器</strong>非常危险，于是乎便有了<strong>此文</strong>。</p>
<h3 id="使用密钥登录ssh服务器">使用密钥登录ssh服务器</h3>
<h4 id="生成公钥和私钥">生成公钥和私钥</h4>
<p>任意路径下打开git bash，输入以下命令，邮箱请根据自己的需要填写：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;your_email@youremail.com&quot;</span></span><br></pre></td></tr></table></figure>
<p><img data-src="image-20211117224126494.png" /></p>
<p>默认情况下会在自己的用户名下的<code>.ssh</code>文件夹生成<strong>公钥</strong>和<strong>私钥</strong>，其中<code>.pub</code>结尾的是公钥</p>
<p><img data-src="image-20211117224251406.png" /></p>
<h4 id="将公钥拷贝到服务器">将公钥拷贝到服务器</h4>
<p>一般情况下，当前目录都会有.ssh文件夹，并且文件夹下有<code>authorized_keys</code>文件，此时只需要将<strong>公钥</strong>文件的内容复制到该文件即可：</p>
<p><img data-src="image-20211117225910505.png" /></p>
<p>若没有则需要新建</p>
<h5 id="新建.ssh文件夹">新建.ssh文件夹</h5>
<p>使用当前用户并在当前用户名下新建<code>.ssh</code>文件夹</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> .ssh</span><br></pre></td></tr></table></figure>
<h5 id="使用xftp等软件拷贝">使用xftp等软件拷贝</h5>
<p>将<strong>id_rsa.pub</strong>文件拷贝到当前用户的<strong>.ssh文件夹</strong>下：</p>
<p><img data-src="image-20211117230405573.png" /></p>
<h5 id="使用scp命令">使用scp命令</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp id_rsa.pub &lt;用户名&gt;@&lt;ip&gt;:&lt;用户名&gt;.ssh/</span><br></pre></td></tr></table></figure>
<p><img data-src="image-20211117231239950.png" /></p>
<h5 id="设置公钥权限">设置公钥权限</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 600 id_rsa.pub</span><br></pre></td></tr></table></figure>
<h4 id="修改ssh配置">修改ssh配置</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure>
<p>找到对应的片段，修改后面的内容即可。</p>
<h5 id="修改端口">修改端口</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Port 65535</span><br></pre></td></tr></table></figure>
<h5 id="修改公钥文件地址">修改公钥文件地址</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">AuthorizedKeysFile .ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>
<h5 id="允许公钥登录">允许公钥登录</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PubkeyAuthentication <span class="built_in">yes</span></span><br></pre></td></tr></table></figure>
<h5 id="禁止密码登录">禁止密码登录</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PasswordAuthentication no</span><br></pre></td></tr></table></figure>
<h4 id="重启ssh服务">重启SSH服务</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service sshd restart</span><br></pre></td></tr></table></figure>
<h3 id="注意">注意</h3>
<p>到此以后就可以用密钥登陆了，不过现在还不能<strong>关闭当前的终端窗口</strong>，万一你刚才修改的有问题或者修改错了，那么就无法登陆服务器了！！！</p>
<p>这时候可以打开一个新的ssh窗口，检验以下刚才的设置有没有问题。</p>
<p>登陆时私钥选择之前生成的<strong>id_rsa</strong>即可。</p>
]]></content>
      <tags>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang时间处理</title>
    <url>/p/time-processing-in-golang/</url>
    <content><![CDATA[<p>本文主要介绍了Golang时间处理的函数。</p>
<span id="more"></span>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析时间相关</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">showTime</span><span class="params">()</span></span> &#123;</span><br><span class="line">	nowTime := time.Now()</span><br><span class="line">	nowYear := nowTime.Year()</span><br><span class="line">	nowMonth := nowTime.Month()</span><br><span class="line">	nowDay := nowTime.Day()</span><br><span class="line">	nowHour := nowTime.Hour()</span><br><span class="line">	nowMinute := nowTime.Minute()</span><br><span class="line">	nowSecond := nowTime.Second()</span><br><span class="line">	fmt.Println(nowTime)</span><br><span class="line">	fmt.Println(nowYear)</span><br><span class="line">	fmt.Println(nowMonth)</span><br><span class="line">	fmt.Println(nowDay)</span><br><span class="line">	fmt.Println(nowHour)</span><br><span class="line">	fmt.Println(nowMinute)</span><br><span class="line">	fmt.Println(nowSecond)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getTimeGap</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 获得当地时区时间</span></span><br><span class="line">	nowTime := time.Now()</span><br><span class="line">	<span class="comment">// 根据相应的格式解析时间</span></span><br><span class="line">	newTime, err := time.Parse(<span class="string">&quot;2006-01-02T15:04:05Z07:00&quot;</span>, <span class="string">&quot;2021-08-26T12:52:05+08:00&quot;</span>) <span class="comment">// 如果第二个参数不包含时区信息的话，返回的是UTC时间</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;解析时间错误，错误：&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回时区信息</span></span><br><span class="line">	loc, err := time.LoadLocation(<span class="string">&quot;Asia/Shanghai&quot;</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;时区信息：&quot;</span>, loc)</span><br><span class="line">	<span class="comment">// 返回时区</span></span><br><span class="line">	nowTimeZone := nowTime.Location()</span><br><span class="line">	<span class="comment">// 根据相应的格式解析时间</span></span><br><span class="line">	newTime, err = time.ParseInLocation(<span class="string">&quot;2006/01/02 15:04:05&quot;</span>, <span class="string">&quot;2021/08/26 13:08:00&quot;</span>, nowTimeZone)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;解析时区信息错误，错误：&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	timeGap := newTime.Sub(nowTime)</span><br><span class="line">	fmt.Println(<span class="string">&quot;时间间隔是：&quot;</span>, timeGap)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// showTime()</span></span><br><span class="line">	getTimeGap()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>time</tag>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>如何为ipv4-only的服务器添加ipv6地址</title>
    <url>/p/use-warp-unlock-ipv6/</url>
    <content><![CDATA[<p>本文主要介绍如何为ipv4-only的服务器添加ipv6地址。</p>
<p>更新：由于大范围滥用，近期warp已经基本处于处于不可用状态。RIP.</p>
<p><strong>关键词</strong>：cloudflare</p>
<span id="more"></span>
<h3 id="准备工作">准备工作</h3>
<ul>
<li>一台Deian 系的服务器</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install curl sudo lsb-release -y</span><br></pre></td></tr></table></figure>
<h4 id="debian安装">debian安装</h4>
<ol type="1">
<li>安装版本高于 5.6 的内核</li>
<li>安装 wireguard 内核模块</li>
<li>安装 wireguard-go</li>
</ol>
<h5 id="添加backports源">添加backports源</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb http://deb.debian.org/debian <span class="subst">$(lsb_release -sc)</span>-backports main&quot;</span> | sudo <span class="built_in">tee</span> /etc/apt/sources.list.d/backports.list</span><br><span class="line">sudo apt update</span><br></pre></td></tr></table></figure>
<p>先执行 <code>uname -r</code> 命令查看内核版本。如果是 5.6
以上内核则已经集成了 Wire­Guard ，就不需要安装了。</p>
<h5 id="安装网络工具包">安装网络工具包</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install net-tools iproute2 openresolv dnsutils -y</span><br></pre></td></tr></table></figure>
<p>安装 <strong><a
href="https://p3terx.com/go/aHR0cHM6Ly9naXRodWIuY29tL1dpcmVHdWFyZC93aXJlZ3VhcmQtdG9vbHM">wireguard-tools</a></strong>
(Wire­Guard 配置工具：<code>wg</code>、<code>wg-quick</code>)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install wireguard-tools --no-install-recommends</span><br></pre></td></tr></table></figure>
<h5 id="安装内核">安装内核</h5>
<p>为了稳定性推荐安装 back­ports 仓库中的内核 (截止发文版本为
5.10)。以下是一把梭命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt -t $(lsb_release -sc)-backports install linux-image-$(dpkg --print-architecture) linux-headers-$(dpkg --print-architecture) --install-recommends -y</span><br></pre></td></tr></table></figure>
<p>安装完重启，并执行 <code>uname -r</code>
命令查看内核版本来确认新内核是否被启用。</p>
<h4 id="debian安装动态内核模块">debian安装动态内核模块</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install wireguard-dkms -y</span><br></pre></td></tr></table></figure>
<p>安装后执行 <code>modprobe wireguard</code> 命令加载 Wire­Guard
内核模块。</p>
<h4 id="debian安装wireguard-go">debian安装wireguard-go</h4>
<p>OpenVZ/LXC VPS 或者不想折腾内核的小伙伴可以安装
<code>wireguard-go</code>，只不过网络性能较低。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -fsSL git.io/wireguard-go.sh | sudo bash</span><br></pre></td></tr></table></figure>
<p>PS：对于 OpenVZ/LXC 的 VPS
需要执行<code>lsmod | grep tun</code>命令来检查 TUN
模块是否正常加载，若没有请自行咕鸽搜索开启方法，否则是不能正常使用的。</p>
<h4 id="ubuntu安装">ubuntu安装</h4>
<p>WireGuard可从默认的Ubuntu存储库中获得。
要安装它，请运行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install wireguard</span><br></pre></td></tr></table></figure>
<p>这将安装WireGuard模块和工具。WireGuard作为内核模块运行。</p>
<h3 id="配置warp">配置WARP</h3>
<h4 id="安装wgcf">安装wgcf</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -fsSL git.io/wgcf.sh | sudo bash</span><br></pre></td></tr></table></figure>
<h4 id="注册-warp-账户-将生成-wgcf-account.toml-文件保存账户信息">注册
WARP 账户 (将生成 <code>wgcf-account.toml</code> 文件保存账户信息)</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wgcf register</span><br></pre></td></tr></table></figure>
<h4
id="生成wireguard配置文件wgcf-profile.conf">生成WireGuard配置文件(wgcf-profile.conf)</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wgcf generate</span><br></pre></td></tr></table></figure>
<p>生成的两个文件记得备份好，尤其是
<code>wgcf-profile.conf</code>，万一未来工具失效、重装系统后可能还用得着。</p>
<h4 id="编辑wireguard配置文件">编辑WireGuard配置文件</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim wgcf-profile.conf</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Interface]</span><br><span class="line">PrivateKey = *</span><br><span class="line">Address = *</span><br><span class="line">Address = *</span><br><span class="line">DNS = 2001:4860:4860::8888</span><br><span class="line">MTU = 1280</span><br><span class="line">[Peer]</span><br><span class="line">PublicKey = *</span><br><span class="line">AllowedIPs = ::/0</span><br><span class="line">Endpoint = [2606:4700:d0::a29f:c001]:2408</span><br></pre></td></tr></table></figure>
<p>默认的<code>Endpoint</code>为
<code>engage.cloudflareclient.com</code>，解析成ip一般是以下两个结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">162.159.192.1</span><br><span class="line">2606:4700:d0::a29f:c001</span><br></pre></td></tr></table></figure>
<p>如果想优先使用<code>warp</code>的ipv4地址访问外部网络，则<code>Endpoint</code>
需要设置为ipv4的地址；ipv6依次类推。</p>
<p>DNS也是一样，如果想用ipv4地址，则需要设置一个ipv4的DNS地址，如<code>8.8.8.8</code>；ipv6则是<code>2001:4860:4860::8888</code>.</p>
<h4
id="将修改好的配置文件移动到指定目录">将修改好的配置文件移动到指定目录</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">cp</span> wgcf-profile.conf /etc/wireguard/wgcf.conf</span><br></pre></td></tr></table></figure>
<h4 id="开启网络接口">开启网络接口</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo wg-quick up wgcf</span><br></pre></td></tr></table></figure>
<h5 id="有可能遇到的问题">有可能遇到的问题</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/bin/wg-quick: line 31: resolvconf: <span class="built_in">command</span> not found [WireGuard | Debian]</span><br></pre></td></tr></table></figure>
<p>解决方案：</p>
<p>执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">ln</span> -s /usr/bin/resolvectl /usr/local/bin/resolvconf</span><br></pre></td></tr></table></figure>
<h4 id="关闭网络接口">关闭网络接口</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo wg-quick down wgcf</span><br></pre></td></tr></table></figure>
<h4 id="正式启用网络接口">正式启用网络接口</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启用守护进程</span></span><br><span class="line">sudo systemctl start wg-quick@wgcf</span><br><span class="line"><span class="comment"># 设置开机启动</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> wg-quick@wgcf</span><br></pre></td></tr></table></figure>
<h3 id="使用warp">使用WARP+</h3>
<h4 id="如何获得更多的warp流量">如何获得更多的Warp+流量</h4>
<p>自动化脚本：https://github.com/navaneethkm004/warp-plus/raw/main/main.py</p>
<p>需要Python3，执行之前请运行：<code>chmod +x main.py</code></p>
<p>ID获取方式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> wgcf-account.toml</span><br></pre></td></tr></table></figure>
<p>输入ID以后，程序开始运行</p>
<p>查看增加的流量：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wgcf update &amp;&amp; wgcf status</span><br></pre></td></tr></table></figure>
<h4 id="多个设备共享">多个设备共享</h4>
<p>将多台设备的<code>license_key</code>设置为同一个，然后执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wgcf update &amp;&amp; wgcf status</span><br></pre></td></tr></table></figure>
<h4 id="检测warp是否启用">检测warp+是否启用</h4>
<p>服务器端执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -6 https://cloudflare.com/cdn-cgi/trace</span><br></pre></td></tr></table></figure>
<p>若<code>warp=plus</code>则说明启用成功。</p>
<p>若<code>warp=on</code>则需要指向以下操作：</p>
<ol type="1">
<li><p>执行<code>wgcf register</code>重新生成一个账户；</p></li>
<li><p>修改生成的<code>wgcf-account.toml</code>，绑定<code>license_key</code>；</p></li>
<li><p>执行<code>wgcf generate</code>生成WireGuard
VPN配置文件；</p></li>
<li><p>执行<code>sudo cp wgcf-profile.conf /etc/wireguard/wgcf.conf</code>；</p></li>
<li><p>启动网络接口，<code>sudo wg-quick up wgcf</code>；</p></li>
<li><p>执行<code>curl -6 https://cloudflare.com/cdn-cgi/trace</code>.</p></li>
</ol>
<p>如果<code>warp</code>的值没有发生变化，需要重新执行1-6步骤。</p>
<h3 id="end">END</h3>
<p>感谢：</p>
<p>https://p3terx.com/archives/use-cloudflare-warp-to-add-extra-ipv4-or-ipv6-network-support-to-vps-servers-for-free.html</p>
<p>https://hiram.wang/cloudflare-wrap-vps/#2021-03%E6%9B%B4%E6%96%B0-%E5%AE%9E%E7%8E%B0%E6%97%A0%E6%8D%9F%E5%8F%8C%E6%A0%88</p>
]]></content>
      <tags>
        <tag>cloudflare</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS实战（四）｜Intel Realsense T265</title>
    <url>/p/Intel-Realsense-T265-in-ubuntu/</url>
    <content><![CDATA[<p><strong>摘要</strong>：英特尔® 实感™ 追踪摄像头 T265
是一款全新的独立同步定位与建图设备，可用于机器人、无人机等领域。本文主要介绍了如何在ubuntu系统上安装Intel
Realsense T265追踪摄像头。</p>
<p><strong>关键词</strong>：T265，ROS</p>
<span id="more"></span>
<h3 id="t265参数">T265参数</h3>
<ol type="1">
<li>T265采用了2视觉处理单元（VPU），V-SLAM算法可以直接在VPU上运行，可直接输出相机位姿；</li>
<li>T265使用了双目鱼眼相机，分辨率848*800，刷新频率30Hz，可以生成单色图像，视场角163(±5°)；</li>
<li>惯性测量单元（IMU）型号为BM1055；</li>
<li>相机与IMU的参数都保存了传感器中，可以通过示例直接读取相机的内参和相机与IMU之间的外参；</li>
<li>相机外形尺寸108x24.5x12.5mm</li>
</ol>
<p><img data-src="t265.png" /></p>
<h3 id="t265开发环境搭建">T265开发环境搭建</h3>
<h4 id="注册公钥">注册公钥</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-key adv --keyserver keys.gnupg.net --recv-key F6E65AC044F831AC80A06380C8B3A55A6F3EFCDE || sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-key F6E65AC044F831AC80A06380C8B3A55A6F3EFCDE</span><br></pre></td></tr></table></figure>
<h4 id="添加库">添加库</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository &quot;deb https://librealsense.intel.com/Debian/apt-repo $(lsb_release -sc) main&quot; -u</span><br></pre></td></tr></table></figure>
<h4 id="安装库">安装库</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install librealsense2-dkms</span><br><span class="line">sudo apt-get install librealsense2-utils</span><br></pre></td></tr></table></figure>
<p>以上两行将部署 librealsense2 udev
规则，构建并激活内核模块，运行时库以及可执行的演示和工具。</p>
<h4 id="安装开发库可选">安装开发库（可选）</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install librealsense2-dev</span><br><span class="line">sudo apt-get install librealsense2-dbg</span><br></pre></td></tr></table></figure>
<p>安装了dev软件包后，可以使用<code>g++ -std=c++11 filename.cpp -lrealsense2</code>或者在IDE中使用<code>librealsense2</code>编译应用程序。</p>
<h4 id="检查安装是否成功">检查安装是否成功</h4>
<p>运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">realsense-viewer</span><br></pre></td></tr></table></figure>
<p>系统会自动打开一个窗口</p>
<p><img data-src="realsense-viewer.png" /></p>
<p>一旦速度过快，T265输出的位姿就会飞掉。</p>
<h3 id="读取t265内外参数信息">读取T265内外参数信息</h3>
<p>T265在出厂前就对相机进行了标定，每个相机内部都带有相机的内参和外参，终端输入以下命令，即可读取T265的配置信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rs-enumerate-devices</span><br></pre></td></tr></table></figure>
<p><img data-src="rs-enumerate-devices.png" /></p>
<p>如果需要读取相机内参和外参，以及IMU的参数可以使用如下命令（添加 -c
参数）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rs-enumerate-devices -c</span><br></pre></td></tr></table></figure>
<p><img data-src="rs-enumerate-devices-c.png" /></p>
<h3 id="使用ros包读取t265数据">使用ROS包读取T265数据</h3>
<p>使用环境ROS melodic 版本</p>
<h4 id="安装依赖">安装依赖</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install ros-<span class="variable">$ROS_DISTRO</span>-ddynamic-reconfigure</span><br></pre></td></tr></table></figure>
<h4 id="下载安装ros包-realsense-ros">下载安装ROS包 realsense-ros</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws/src</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/IntelRealSense/realsense-ros.git</span><br><span class="line"><span class="built_in">cd</span> realsense-ros/</span><br><span class="line">git checkout `git tag | <span class="built_in">sort</span> -V | grep -P <span class="string">&quot;^2.\d+\.\d+&quot;</span> | <span class="built_in">tail</span> -1`</span><br><span class="line"><span class="built_in">cd</span>  ~/catkin_ws/</span><br><span class="line">catkin_make -DCATKIN_ENABLE_TESTING=False -DCMAKE_BUILD_TYPE=Release</span><br></pre></td></tr></table></figure>
<h4
id="启动测试demo即可看到t265的位姿数据">启动测试demo，即可看到T265的位姿数据</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> devel/setup.bash</span><br><span class="line">roslaunch realsense2_camera demo_t265.launch</span><br></pre></td></tr></table></figure>
<p><img data-src="demo_t265.jpg" /></p>
<p>如果需要查看鱼眼相机图像数据，则需要对<code>rs_t265.launch</code>文件进行修改，使能图像输出</p>
<p><img data-src="rs_t265.png" /></p>
<p>运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">roslaunch realsense2_camera demo_t265.launch</span><br></pre></td></tr></table></figure>
<p><img data-src="demo_t265_2.png" /></p>
]]></content>
      <tags>
        <tag>ROS</tag>
        <tag>T265</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS实战（六）｜串口通信</title>
    <url>/p/serial-communication-on-jetson-xavier-nx/</url>
    <content><![CDATA[<p>利用Jetson Xavier和传感器模块进行串口通信</p>
<span id="more"></span>
<h3 id="硬件连接">硬件连接</h3>
<p>默认情况下，Jetson Xavier
NX分配I2C和UART引脚，所有其他引脚（电源和接地除外）均分配为GPIO，建议使用下面标有其他功能的引脚。</p>
<p>这里我们用的是UART1，设备地址<code>/dev/ttyTHS0</code>.</p>
<p><img data-src="jetson_data_sheet.png" /></p>
<p>其中，第8和10引脚就是我们需要的TXD和RXD引脚。</p>
<p><img data-src="jetson_xavier_nx.jpg" /></p>
<p><strong>注意：和电脑连接调试时需要注意，USB转TTL的RXD引脚需和板子的TXD引脚连接，USB转TTL的TXD引脚需和板子的RXD引脚相连。两者的GND引脚也要连起来。</strong></p>
<h3 id="相关代码">相关代码</h3>
<h4 id="安装相关依赖">安装相关依赖</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip3 install pyserial</span><br></pre></td></tr></table></figure>
<h4 id="测试代码">测试代码</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> serial</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;UART Demonstration Program&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">serial_port = serial.Serial(</span><br><span class="line">    port=<span class="string">&quot;/dev/ttyTHS1&quot;</span>,                                      <span class="comment">#串口设备地址</span></span><br><span class="line">    baudrate=<span class="number">115200</span>,                                          <span class="comment">#信号波特率</span></span><br><span class="line">    bytesize=serial.EIGHTBITS,                                <span class="comment">#数据位</span></span><br><span class="line">    parity=serial.PARITY_NONE,  						    <span class="comment">#是否启用奇偶校验</span></span><br><span class="line">    stopbits=serial.STOPBITS_ONE,                             <span class="comment">#停止位</span></span><br><span class="line">)</span><br><span class="line"><span class="comment"># Wait a second to let the port initialize</span></span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># Send a simple header</span></span><br><span class="line">    serial_port.write(<span class="string">&quot;UART Demonstration Program\r\n&quot;</span>.encode())</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> serial_port.inWaiting() &gt; <span class="number">0</span>:</span><br><span class="line">            data = serial_port.read()</span><br><span class="line">            <span class="built_in">print</span>(data)</span><br><span class="line">            serial_port.write(data)</span><br><span class="line">            <span class="comment"># if we get a carriage return, add a line feed too</span></span><br><span class="line">            <span class="comment"># \r is a carriage return; \n is a line feed</span></span><br><span class="line">            <span class="comment"># This is to help the tty program on the other end </span></span><br><span class="line">            <span class="comment"># Windows is \r\n for carriage return, line feed</span></span><br><span class="line">            <span class="comment"># Macintosh and Linux use \n</span></span><br><span class="line">            <span class="keyword">if</span> data == <span class="string">&quot;\r&quot;</span>.encode():</span><br><span class="line">                <span class="comment"># For Windows boxen on the other end</span></span><br><span class="line">                serial_port.write(<span class="string">&quot;\n&quot;</span>.encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Exiting Program&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> exception_error:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Error occurred. Exiting Program&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Error: &quot;</span> + <span class="built_in">str</span>(exception_error))</span><br><span class="line"></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    serial_port.close()</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p><img data-src="uart_demo.png" /></p>
<p>参考资料：</p>
<p>https://www.jetsonhacks.com/2019/10/10/jetson-nano-uart/</p>
<p>https://github.com/JetsonHacksNano/UARTDemo</p>
<p>https://github.com/pyserial/pyserial</p>
<p>​</p>
]]></content>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title>Dedian10使用Rclone同步ondrive</title>
    <url>/p/rclone-on-debian/</url>
    <content><![CDATA[<p>Dedian10 使用Rclone同步onedrive</p>
<span id="more"></span>
<h3 id="安装rclone">安装Rclone</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl https://rclone.org/install.sh | sudo bash</span><br></pre></td></tr></table></figure>
<h3 id="rclone连接onedrive">Rclone连接Onedrive</h3>
<h4 id="获取token">获取Token</h4>
<p>在本地Windows电脑上<a
href="https://rclone.org/downloads/">下载</a>，进入文件夹，资源管理器路径那一栏输入<code>cmd</code>,会在当前目录打开cmd命令行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rclone authorize <span class="string">&quot;onedrive&quot;</span></span><br></pre></td></tr></table></figure>
<p>接下来会弹出浏览器，要求你登录账号进行授权。授权完后命令提示符窗口会出现以下信息：</p>
<p><img data-src="Dedian10使用Rclone同步ondrive/rclone.png" />包含access_token的{}保存好，稍后安装rclone的时候会用到。</p>
<h3 id="配置-rclone">配置 Rclone</h3>
<p>输入 <code>rclone config</code>
命令，会出现以下信息，参照以下进行操作。</p>
<p>其中，id和机密可以进入https://portal.azure.com/#blade/Microsoft_AAD_RegisteredApps/ApplicationsListBlade生成</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">admin@ip-172-26-5-120:~$ rclone config</span><br><span class="line">No remotes found - make a new one</span><br><span class="line">n) New remote</span><br><span class="line">s) Set configuration password</span><br><span class="line">q) Quit config</span><br><span class="line">n/s/q&gt; n</span><br><span class="line">name&gt; e5</span><br><span class="line">Type of storage to configure.</span><br><span class="line">Enter a string value. Press Enter <span class="keyword">for</span> the default (<span class="string">&quot;&quot;</span>).</span><br><span class="line">Choose a number from below, or <span class="built_in">type</span> <span class="keyword">in</span> your own value</span><br><span class="line"> 1 / 1Fichier</span><br><span class="line">   \ <span class="string">&quot;fichier&quot;</span></span><br><span class="line"> 2 / Alias <span class="keyword">for</span> an existing remote</span><br><span class="line">   \ <span class="string">&quot;alias&quot;</span></span><br><span class="line"> 3 / Amazon Drive</span><br><span class="line">   \ <span class="string">&quot;amazon cloud drive&quot;</span></span><br><span class="line"> 4 / Amazon S3 Compliant Storage Providers including AWS, Alibaba, Ceph, Digital Ocean, Dreamhost, IBM COS, Minio, and Tencent COS</span><br><span class="line">   \ <span class="string">&quot;s3&quot;</span></span><br><span class="line"> 5 / Backblaze B2</span><br><span class="line">   \ <span class="string">&quot;b2&quot;</span></span><br><span class="line"> 6 / Box</span><br><span class="line">   \ <span class="string">&quot;box&quot;</span></span><br><span class="line"> 7 / Cache a remote</span><br><span class="line">   \ <span class="string">&quot;cache&quot;</span></span><br><span class="line"> 8 / Citrix Sharefile</span><br><span class="line">   \ <span class="string">&quot;sharefile&quot;</span></span><br><span class="line"> 9 / Compress a remote</span><br><span class="line">   \ <span class="string">&quot;compress&quot;</span></span><br><span class="line">10 / Dropbox</span><br><span class="line">   \ <span class="string">&quot;dropbox&quot;</span></span><br><span class="line">11 / Encrypt/Decrypt a remote</span><br><span class="line">   \ <span class="string">&quot;crypt&quot;</span></span><br><span class="line">12 / Enterprise File Fabric</span><br><span class="line">   \ <span class="string">&quot;filefabric&quot;</span></span><br><span class="line">13 / FTP Connection</span><br><span class="line">   \ <span class="string">&quot;ftp&quot;</span></span><br><span class="line">14 / Google Cloud Storage (this is not Google Drive)</span><br><span class="line">   \ <span class="string">&quot;google cloud storage&quot;</span></span><br><span class="line">15 / Google Drive</span><br><span class="line">   \ <span class="string">&quot;drive&quot;</span></span><br><span class="line">16 / Google Photos</span><br><span class="line">   \ <span class="string">&quot;google photos&quot;</span></span><br><span class="line">17 / Hadoop distributed file system</span><br><span class="line">   \ <span class="string">&quot;hdfs&quot;</span></span><br><span class="line">18 / Hubic</span><br><span class="line">   \ <span class="string">&quot;hubic&quot;</span></span><br><span class="line">19 / In memory object storage system.</span><br><span class="line">   \ <span class="string">&quot;memory&quot;</span></span><br><span class="line">20 / Jottacloud</span><br><span class="line">   \ <span class="string">&quot;jottacloud&quot;</span></span><br><span class="line">21 / Koofr</span><br><span class="line">   \ <span class="string">&quot;koofr&quot;</span></span><br><span class="line">22 / Local Disk</span><br><span class="line">   \ <span class="string">&quot;local&quot;</span></span><br><span class="line">23 / Mail.ru Cloud</span><br><span class="line">   \ <span class="string">&quot;mailru&quot;</span></span><br><span class="line">24 / Mega</span><br><span class="line">   \ <span class="string">&quot;mega&quot;</span></span><br><span class="line">25 / Microsoft Azure Blob Storage</span><br><span class="line">   \ <span class="string">&quot;azureblob&quot;</span></span><br><span class="line">26 / Microsoft OneDrive</span><br><span class="line">   \ <span class="string">&quot;onedrive&quot;</span></span><br><span class="line">27 / OpenDrive</span><br><span class="line">   \ <span class="string">&quot;opendrive&quot;</span></span><br><span class="line">28 / OpenStack Swift (Rackspace Cloud Files, Memset Memstore, OVH)</span><br><span class="line">   \ <span class="string">&quot;swift&quot;</span></span><br><span class="line">29 / Pcloud</span><br><span class="line">   \ <span class="string">&quot;pcloud&quot;</span></span><br><span class="line">30 / Put.io</span><br><span class="line">   \ <span class="string">&quot;putio&quot;</span></span><br><span class="line">31 / QingCloud Object Storage</span><br><span class="line">   \ <span class="string">&quot;qingstor&quot;</span></span><br><span class="line">32 / SSH/SFTP Connection</span><br><span class="line">   \ <span class="string">&quot;sftp&quot;</span></span><br><span class="line">33 / Sugarsync</span><br><span class="line">   \ <span class="string">&quot;sugarsync&quot;</span></span><br><span class="line">34 / Tardigrade Decentralized Cloud Storage</span><br><span class="line">   \ <span class="string">&quot;tardigrade&quot;</span></span><br><span class="line">35 / Transparently chunk/split large files</span><br><span class="line">   \ <span class="string">&quot;chunker&quot;</span></span><br><span class="line">36 / Union merges the contents of several upstream fs</span><br><span class="line">   \ <span class="string">&quot;union&quot;</span></span><br><span class="line">37 / Webdav</span><br><span class="line">   \ <span class="string">&quot;webdav&quot;</span></span><br><span class="line">38 / Yandex Disk</span><br><span class="line">   \ <span class="string">&quot;yandex&quot;</span></span><br><span class="line">39 / Zoho</span><br><span class="line">   \ <span class="string">&quot;zoho&quot;</span></span><br><span class="line">40 / http Connection</span><br><span class="line">   \ <span class="string">&quot;http&quot;</span></span><br><span class="line">41 / premiumize.me</span><br><span class="line">   \ <span class="string">&quot;premiumizeme&quot;</span></span><br><span class="line">42 / seafile</span><br><span class="line">   \ <span class="string">&quot;seafile&quot;</span></span><br><span class="line">Storage&gt; onedrive</span><br><span class="line">** See <span class="built_in">help</span> <span class="keyword">for</span> onedrive backend at: https://rclone.org/onedrive/ **</span><br><span class="line"></span><br><span class="line">OAuth Client Id</span><br><span class="line">Leave blank normally.</span><br><span class="line">Enter a string value. Press Enter <span class="keyword">for</span> the default (<span class="string">&quot;&quot;</span>).</span><br><span class="line">client_id&gt; <span class="comment">####&lt;client_id&gt;</span></span><br><span class="line">OAuth Client Secret</span><br><span class="line">Leave blank normally.</span><br><span class="line">Enter a string value. Press Enter <span class="keyword">for</span> the default (<span class="string">&quot;&quot;</span>).</span><br><span class="line">client_secret&gt; <span class="comment">####&lt;client_secret&gt;</span></span><br><span class="line">Choose national cloud region <span class="keyword">for</span> OneDrive.</span><br><span class="line">Enter a string value. Press Enter <span class="keyword">for</span> the default (<span class="string">&quot;global&quot;</span>).</span><br><span class="line">Choose a number from below, or <span class="built_in">type</span> <span class="keyword">in</span> your own value</span><br><span class="line"> 1 / Microsoft Cloud Global</span><br><span class="line">   \ <span class="string">&quot;global&quot;</span></span><br><span class="line"> 2 / Microsoft Cloud <span class="keyword">for</span> US Government</span><br><span class="line">   \ <span class="string">&quot;us&quot;</span></span><br><span class="line"> 3 / Microsoft Cloud Germany</span><br><span class="line">   \ <span class="string">&quot;de&quot;</span></span><br><span class="line"> 4 / Azure and Office 365 operated by 21Vianet <span class="keyword">in</span> China</span><br><span class="line">   \ <span class="string">&quot;cn&quot;</span></span><br><span class="line">region&gt; 1</span><br><span class="line">Edit advanced config? (y/n)</span><br><span class="line">y) Yes</span><br><span class="line">n) No (default)</span><br><span class="line">y/n&gt;</span><br><span class="line">Remote config</span><br><span class="line">Make sure your Redirect URL is <span class="built_in">set</span> to <span class="string">&quot;http://localhost:53682/&quot;</span> <span class="keyword">in</span> your custom config.</span><br><span class="line">Use auto config?</span><br><span class="line"> * Say Y <span class="keyword">if</span> not sure</span><br><span class="line"> * Say N <span class="keyword">if</span> you are working on a remote or headless machine</span><br><span class="line">y) Yes (default)</span><br><span class="line">n) No</span><br><span class="line">y/n&gt; n</span><br><span class="line">For this to work, you will need rclone available on a machine that has</span><br><span class="line">a web browser available.</span><br><span class="line"></span><br><span class="line">For more <span class="built_in">help</span> and alternate methods see: https://rclone.org/remote_setup/</span><br><span class="line"></span><br><span class="line">Execute the following on the machine with the web browser (same rclone</span><br><span class="line">version recommended):</span><br><span class="line"></span><br><span class="line">        rclone authorize <span class="string">&quot;onedrive&quot;</span> -- <span class="string">&quot;02c884a6-5468-455c-a268-74cdc7203438&quot;</span> <span class="string">&quot;IrjLga~Ac3EiDM~b8Rnj~_.52-9qkl-diz&quot;</span></span><br><span class="line"></span><br><span class="line">Then <span class="built_in">paste</span> the result below:</span><br><span class="line">result&gt; <span class="comment">###&lt;粘贴刚刚复制的access_token&gt;</span></span><br><span class="line">Choose a number from below, or <span class="built_in">type</span> <span class="keyword">in</span> an existing value</span><br><span class="line"> 1 / OneDrive Personal or Business</span><br><span class="line">   \ <span class="string">&quot;onedrive&quot;</span></span><br><span class="line"> 2 / Root Sharepoint site</span><br><span class="line">   \ <span class="string">&quot;sharepoint&quot;</span></span><br><span class="line"> 3 / Sharepoint site name or URL (e.g. mysite or https://contoso.sharepoint.com/sites/mysite)</span><br><span class="line">   \ <span class="string">&quot;url&quot;</span></span><br><span class="line"> 4 / Search <span class="keyword">for</span> a Sharepoint site</span><br><span class="line">   \ <span class="string">&quot;search&quot;</span></span><br><span class="line"> 5 / Type <span class="keyword">in</span> driveID (advanced)</span><br><span class="line">   \ <span class="string">&quot;driveid&quot;</span></span><br><span class="line"> 6 / Type <span class="keyword">in</span> SiteID (advanced)</span><br><span class="line">   \ <span class="string">&quot;siteid&quot;</span></span><br><span class="line"> 7 / Sharepoint server-relative path (advanced, e.g. /teams/hr)</span><br><span class="line">   \ <span class="string">&quot;path&quot;</span></span><br><span class="line">Your choice&gt; 1</span><br><span class="line">Found 1 drives, please <span class="keyword">select</span> the one you want to use:</span><br><span class="line">0: OneDrive (business) <span class="built_in">id</span>=b!lIxfd2Pu9EqZkOv48-aPSRheOv8JQpVMuSEfiWP0gw_uuFm5MjSKT7k1T4f5GToI</span><br><span class="line">Chose drive to use:&gt; 0</span><br><span class="line">Found drive <span class="string">&#x27;root&#x27;</span> of <span class="built_in">type</span> <span class="string">&#x27;business&#x27;</span>, URL: https://fly97-my.sharepoint.com/personal/xiaofeifei_fly97_fun/Documents</span><br><span class="line">Is that okay?</span><br><span class="line">y) Yes (default)</span><br><span class="line">n) No</span><br><span class="line">y/n&gt; y</span><br><span class="line">--------------------</span><br><span class="line">[e5]</span><br><span class="line"><span class="built_in">type</span> = onedrive</span><br><span class="line">client_id = 02c884a6-5468-455c-a268-74cdc7203438</span><br><span class="line">client_secret = IrjLga~Ac3EiDM~b8Rnj~_.52-9qkl-diz</span><br><span class="line">region = global</span><br><span class="line">token = &lt;token&gt;</span><br><span class="line">drive_id = b!lIxfd2Pu9EqZkOv48-aPSRheOv8JQpVMuSEfiWP0gw_uuFm5MjSKT7k1T4f5GToI</span><br><span class="line">drive_type = business</span><br><span class="line">--------------------</span><br><span class="line">y) Yes this is OK (default)</span><br><span class="line">e) Edit this remote</span><br><span class="line">d) Delete this remote</span><br><span class="line">y/e/d&gt; y</span><br><span class="line">Current remotes:</span><br><span class="line"></span><br><span class="line">Name                 Type</span><br><span class="line">====                 ====</span><br><span class="line">e5                   onedrive</span><br><span class="line"></span><br><span class="line">e) Edit existing remote</span><br><span class="line">n) New remote</span><br><span class="line">d) Delete remote</span><br><span class="line">r) Rename remote</span><br><span class="line">c) Copy remote</span><br><span class="line">s) Set configuration password</span><br><span class="line">q) Quit config</span><br><span class="line">e/n/d/r/c/s/q&gt; q</span><br></pre></td></tr></table></figure>
<h3 id="配置自动挂载">配置自动挂载</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/systemd/system/rclone.service</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Rclone</span><br><span class="line">After=network-online.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">ExecStart=/usr/bin/rclone mount e5: /home/e5 \</span><br><span class="line"> --umask 0777 \</span><br><span class="line"> --allow-non-empty \</span><br><span class="line"> --transfers 10 \</span><br><span class="line"> --buffer-size 32M \</span><br><span class="line"> --low-level-retries 200 \</span><br><span class="line"> --vfs-cache-mode full</span><br><span class="line">Restart=on-abort</span><br><span class="line">User=root</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=default.target</span><br></pre></td></tr></table></figure>
<h3 id="一些常用命令">一些常用命令</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 本地到网盘</span></span><br><span class="line">rclone [功能选项] &lt;本地路径&gt; &lt;网盘名称:路径&gt; [参数] [参数] ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 网盘到本地</span></span><br><span class="line">rclone [功能选项] &lt;网盘名称:路径&gt; &lt;本地路径&gt; [参数] [参数] ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 网盘到网盘</span></span><br><span class="line">rclone [功能选项] &lt;网盘名称:路径&gt; &lt;网盘名称:路径&gt; [参数] [参数] ...</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">常用功能选项</span><br><span class="line">rclone copy - 复制</span><br><span class="line">rclone move - 移动，如果要在移动后删除空源目录，请加上 --delete-empty-src-dirs 参数</span><br><span class="line">rclone <span class="built_in">sync</span> - 同步：将源目录同步到目标目录，只更改目标目录。</span><br><span class="line">rclone size - 查看网盘文件占用大小。</span><br><span class="line">rclone delete - 删除路径下的文件内容。</span><br><span class="line">rclone purge - 删除路径及其所有文件内容。</span><br><span class="line">rclone <span class="built_in">mkdir</span> - 创建目录。</span><br><span class="line">rclone <span class="built_in">rmdir</span> - 删除目录。</span><br><span class="line">rclone rmdirs - 删除指定灵境下的空目录。如果加上 --leave-root 参数，则不会删除根目录。</span><br><span class="line">rclone check - 检查源和目的地址数据是否匹配。</span><br><span class="line">rclone <span class="built_in">ls</span> - 列出指定路径下的所有的文件以及文件大小和路径。</span><br><span class="line">rclone lsl - 比上面多一个显示上传时间。</span><br><span class="line">rclone lsd 列出指定路径下的目录</span><br><span class="line">rclone lsf - 列出指定路径下的目录和文件</span><br><span class="line">常用参数</span><br><span class="line">-n = --dry-run - 测试运行，用来查看 rclone 在实际运行中会进行哪些操作。</span><br><span class="line">-P = --progress - 显示实时传输进度，500mS 刷新一次，否则默认 1 分钟刷新一次。</span><br><span class="line">--cache-chunk-size SizeSuffi - 块的大小，默认5M，理论上是越大上传速度越快，同时占用内存也越多。如果设置得太大，可能会导致进程中断。</span><br><span class="line">--cache-chunk-total-size SizeSuffix - 块可以在本地磁盘上占用的总大小，默认10G。</span><br><span class="line">--transfers=N - 并行文件数，默认为4。在比较小的内存的VPS上建议调小这个参数，比如128M的小鸡上使用建议设置为1。</span><br><span class="line">--config string - 指定配置文件路径，string为配置文件路径。</span><br><span class="line">--ignore-errors - 跳过错误。比如 OneDrive 在传了某些特殊文件后会提示Failed to copy: failed to open <span class="built_in">source</span> object: malwareDetected: Malware detected，这会导致后续的传输任务被终止掉，此时就可以加上这个参数跳过错误。但需要注意 RCLONE 的退出状态码不会为0。</span><br></pre></td></tr></table></figure>
<p>参考：https://p3terx.com/archives/rclone-advanced-user-manual-common-command-parameters.html</p>
]]></content>
      <tags>
        <tag>Debian</tag>
        <tag>qbittorrent-nox</tag>
      </tags>
  </entry>
  <entry>
    <title>Dedian 10 使用qbittorrent-nox web</title>
    <url>/p/qbittorrent-nox-on-debian/</url>
    <content><![CDATA[<p>Dedian 10 使用qbittorrent-nox web</p>
<span id="more"></span>
<h3 id="下载安装包">下载安装包</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install qbittorrent qbittorrent-nox</span><br></pre></td></tr></table></figure>
<h3
id="创建用于运行qbittorrent-nox的用户及组">创建用于运行qbittorrent-nox的用户及组</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo adduer --system --group qbittorrent-nox</span><br></pre></td></tr></table></figure>
<p>也可以将系统原有用添加到qbittorrent-nox组中，此处用户主要用于qbittorrnet-nox
的systemd启动脚本</p>
<h3
id="添加qbittorrent-nox服务设置开机自启及启动">添加qbittorrent-nox服务，设置开机自启及启动</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vi /lib/systemd/system/qbittorrent-nox.service</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=qBittorrent Command Line Client</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">User=qbittorrent-nox</span><br><span class="line">Group=qbittorrent-nox</span><br><span class="line">UMask=007</span><br><span class="line">ExecStart=/usr/bin/qbittorrent-nox -d --webui-port=8090</span><br><span class="line">Restart=on-failure</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>
<p>webui-port用于浏览器访问的端口，可以自行更改（非root用户需使用1024-65535以上未被使用的端口）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> qbittorrent-nox</span><br><span class="line">sudo systemctl start qbittorrent-nox</span><br></pre></td></tr></table></figure>
<h3 id="修改web访问用户及密码">修改web访问用户及密码</h3>
<p>使用8090端口访问qbittorrent
web页面，默认用户admin，密码adminadmin</p>
<p>在tools-options-Web
UI中找到Authentication，修改username及password。</p>
]]></content>
      <tags>
        <tag>Debian</tag>
        <tag>qbittorrent-nox</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS实战（三）｜相机标定</title>
    <url>/p/ros-tutorial-03/</url>
    <content><![CDATA[<p>最近的小车需要用到ROS，学习的过程做个记录。</p>
<p>今天写的主要是使用opencv进行相机标定（Camera
Calibration）的步骤。</p>
<span id="more"></span>
<h3 id="下载opencv源码">下载opencv源码</h3>
<p>这里用到的源码版本是opencv3.2.0，操作环境是Ubuntu 18.04 LTS。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://github.com/opencv/opencv/archive/refs/tags/3.2.0.tar.gz</span><br><span class="line">tar -xvf 3.2.0.tar.gz</span><br></pre></td></tr></table></figure>
<h3 id="使用已有的图片进行标定">使用已有的图片进行标定</h3>
<h4 id="编译camera_calibration.cpp">编译camera_calibration.cpp</h4>
<h5 id="进入指定目录">进入指定目录</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd opencv-3.2.0</span><br><span class="line">cd samples/cpp/tutorial_code/calib3d/camera_calibration</span><br></pre></td></tr></table></figure>
<h5 id="创建cmakelist.txt文件">创建CMakeList.txt文件</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim CMakeLists.txt</span><br></pre></td></tr></table></figure>
<p>复制下列代码到文件.</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">2.8</span>)</span><br><span class="line"><span class="keyword">find_package</span>( OpenCV REQUIRED )</span><br><span class="line"><span class="keyword">include_directories</span>( <span class="variable">$&#123;OpenCV_INCLUDE_DIRS&#125;</span> )</span><br><span class="line"><span class="keyword">add_executable</span>( camera_calibration camera_calibration.cpp )</span><br><span class="line"><span class="keyword">target_link_libraries</span>( camera_calibration <span class="variable">$&#123;OpenCV_LIBS&#125;</span> )</span><br></pre></td></tr></table></figure>
<h5 id="编译">编译</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir build </span><br><span class="line">cd build </span><br><span class="line">cmake ..</span><br><span class="line">make </span><br></pre></td></tr></table></figure>
<p><img data-src="calibration01.png" /></p>
<h5 id="修改参数">修改参数</h5>
<p>编辑同级目录下的<code>in_VID5.xml</code>文件，根据标定靶的行数和列数来修改参数。这里的使用的标定靶一共有<strong>6</strong>行，每一行有8个内部角点。</p>
<p><img data-src="calibration02.png" /></p>
<p><img data-src="calibration03.png" /></p>
<p>其中<code>VID5.xml</code>存放的是标定图片路径，一般图片应不少于3张，图片越多标定效果越好。</p>
<p><img data-src="calibration04.png" /></p>
<h5 id="标定">标定</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mv build/camera_calibration .</span><br><span class="line">./camera_calibration ./in_VID5.xml</span><br></pre></td></tr></table></figure>
<p><img data-src="calibration05.png" /></p>
<p>生成的out_camera_data.xml就是标定后得到的参数文件。</p>
<h3 id="使用视频对摄像头进行标定">使用视频对摄像头进行标定</h3>
<h4 id="编译calibration.cpp">编译calibration.cpp</h4>
<h5 id="进入指定目录-1">进入指定目录</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd opencv-3.4.3</span><br><span class="line">mkdir -p ../calibration_ws</span><br><span class="line">cp samples/cpp/calibration.cpp ../calibration_ws</span><br><span class="line">cd ../calibration_ws</span><br></pre></td></tr></table></figure>
<h5 id="创建cmakelists.txt文件">创建CMakeLists.txt文件</h5>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">2.8</span>)</span><br><span class="line"><span class="keyword">find_package</span>( OpenCV REQUIRED )</span><br><span class="line"><span class="keyword">include_directories</span>( <span class="variable">$&#123;OpenCV_INCLUDE_DIRS&#125;</span> )</span><br><span class="line"><span class="keyword">add_executable</span>( calibration calibration.cpp )</span><br><span class="line"><span class="keyword">target_link_libraries</span>( calibration <span class="variable">$&#123;OpenCV_LIBS&#125;</span> )</span><br></pre></td></tr></table></figure>
<h5 id="编译-1">编译</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake ..</span><br><span class="line">make </span><br></pre></td></tr></table></figure>
<p><img data-src="calibration06.png" /></p>
<h5 id="标定-1">标定</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x calibration</span><br><span class="line">./calibration -w=8 -h=6</span><br></pre></td></tr></table></figure>
<p>这里的h指的是标定靶一共有<strong>6</strong>行，w指的是每一行有<strong>8</strong>个内部角点。</p>
<p>按g键开始标定。</p>
<p><img data-src="calibration07.png" /></p>
<p>标定完毕。</p>
<p><img data-src="calibration08.png" /></p>
<p><img data-src="calibration09.png" /></p>
]]></content>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS实战（二）｜工作空间、话题和服务</title>
    <url>/p/ros-tutorial-02/</url>
    <content><![CDATA[<p>最近的小车需要用到ROS，学习的过程做个记录。</p>
<span id="more"></span>
<h3 id="ros中的工作空间">ROS中的工作空间</h3>
<h4 id="工作空间是什么">工作空间是什么</h4>
<p>工作空间是一个存放工程相关开发文件的文件夹，ROS默认使用的是catkin编译系统。</p>
<p>典型的工作空间包含以下四个目录空间：</p>
<ol type="1">
<li><code>src</code>：代码空间，开发过程中最常用的文件夹。用来存放所有ROS功能包的源码文件。</li>
<li><code>build</code>：编译空间，用来存储工作空间编译过程中产生缓存信息和中间文件。</li>
<li><code>devel</code>：开发空间，用来放置编译生成的可执行文件。</li>
<li><code>install</code>：安装空间，编译成功后，可以使用<code>make install</code>命令将可执行文件安装到该空间中，运行该空间中的环境变量脚本，即可以在终端中运行这些可执行文件。注意：安装空间在工作空间中不是必须的，很多工作空间中没有该文件夹。</li>
</ol>
<h4 id="创建工作空间">创建工作空间</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p ~/catkin_ws/src</span><br><span class="line"><span class="built_in">cd</span> ~/catkin_ws/src</span><br><span class="line">catkin_init_workspace</span><br></pre></td></tr></table></figure>
<h4 id="编译工作空间">编译工作空间</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure>
<h4 id="设置环境变量">设置环境变量</h4>
<p>编译完成后<code>devel</code>文件夹下会生成<code>setup.bash</code>形式的环境变量设置脚本，使用<code>source</code>命令运行这些脚本文件，则工作空间的环境变量可以生效。</p>
<p>注意：每一次编译完成后都要运行一次。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> devel/setup.bash</span><br></pre></td></tr></table></figure>
<p>运行以下命令查看环境变量是否生效：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$ROS_PACKAGE_PATH</span></span><br></pre></td></tr></table></figure>
<p>若生效则会显示出当前工作空间的路径。</p>
<h4 id="创建功能包">创建功能包</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws/src</span><br><span class="line">catkin_create_pkg subsciber rospy std_msgs geometry_msgs</span><br></pre></td></tr></table></figure>
<p>其中<code>subsciber</code>是包名，剩下的是功能包所需要的依赖。</p>
<p>创建完成后，需要<strong>编译工作空间</strong>，并且<strong>设置环境变量</strong>。</p>
<h4 id="查看功能包所在的工作空间">查看功能包所在的工作空间</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rospack find subsciber</span><br></pre></td></tr></table></figure>
<h3 id="话题和服务">话题和服务</h3>
<h4 id="话题">话题</h4>
<p>消息以一种发布/订阅的方式传递。一个节点可以订阅多个话题，一个话题也可以被多个节点订阅。两个节点通信时，启动顺序没有强制要求，且<strong>实时性</strong>较弱，不适用于双向的同步传输。</p>
<h4 id="服务">服务</h4>
<p>服务是一种带有应答的通信机制。ROS只允许有一个节点提供指定命名的服务。实时性较强，适用于两个节点之间的同步传输。</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>话题</th>
<th>服务</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>同步性</td>
<td>异步</td>
<td>同步</td>
</tr>
<tr class="even">
<td>通信模型</td>
<td>发布/订阅</td>
<td>客户端/服务端</td>
</tr>
<tr class="odd">
<td>底层协议</td>
<td>ROSTCP/ROSUDP</td>
<td>ROSTCP/ROSUDP</td>
</tr>
<tr class="even">
<td>反馈机制</td>
<td>无</td>
<td>有</td>
</tr>
<tr class="odd">
<td>缓冲区</td>
<td>有</td>
<td>无</td>
</tr>
<tr class="even">
<td>实时性</td>
<td>弱</td>
<td>强</td>
</tr>
<tr class="odd">
<td>节点关系</td>
<td>多对多</td>
<td>一对多（一个server）</td>
</tr>
<tr class="even">
<td>适用场景</td>
<td>数据传输</td>
<td>逻辑处理</td>
</tr>
</tbody>
</table>
]]></content>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS实战（一）｜安装ROS Melodic</title>
    <url>/p/ros-tutorial-01/</url>
    <content><![CDATA[<p>最近的小车需要用到ROS，学习的过程做个记录。</p>
<p>此次记录的主要是软件安装过程中遇到的问题。</p>
<span id="more"></span>
<h3 id="ubuntu1804-换源">ubuntu1804 换源</h3>
<p>安装好Ubuntu 1804以后首先换源：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt update &amp;&amp; sudo apt install apt-transport-https ca-certificates -y</span><br><span class="line"><span class="built_in">cp</span> /etc/apt/sources.list /etc/apt/sources.list.bak</span><br><span class="line">sed -i <span class="string">&quot;s/cn.archive.ubuntu.com/mirrors.aliyun.com/g&quot;</span> /etc/apt/sources.list</span><br><span class="line">sed -i <span class="string">&quot;s/http/https/g&quot;</span> /etc/apt/sources.list</span><br></pre></td></tr></table></figure>
<p>其中，安装<code>apt-transport-https</code>并将安装协议更换到<code>https</code>以避免运营商缓存劫持。</p>
<h3 id="安装ros-melodic">安装ROS Melodic</h3>
<p>参考 <a
href="http://wiki.ros.org/cn/melodic/Installation/Ubuntu">http://wiki.ros.org/cn/melodic/Installation/Ubuntu</a></p>
<h4 id="设置sources.list">设置sources.list</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo sh -c <span class="string">&#x27;echo &quot;deb https://mirrors.aliyun.com/ros/ubuntu $(lsb_release -sc) main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#x27;</span></span><br></pre></td></tr></table></figure>
<h5 id="更新">【更新】</h5>
<p>国科大ROS源：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo sh -c <span class="string">&#x27;echo &quot;deb https://mirrors.ustc.edu.cn/ros/ubuntu $(lsb_release -sc) main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#x27;</span></span><br></pre></td></tr></table></figure>
<p>北外ROS源：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo sh -c <span class="string">&#x27;echo &quot;deb https://mirrors.bfsu.edu.cn/ros/ubuntu/ $(lsb_release -sc) main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#x27;</span></span><br></pre></td></tr></table></figure>
<h4 id="设置密钥">设置密钥</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-key adv --keyserver <span class="string">&#x27;hkp://keyserver.ubuntu.com:80&#x27;</span> --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654</span><br></pre></td></tr></table></figure>
<p>另一种方式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -sSL <span class="string">&#x27;http://keyserver.ubuntu.com/pks/lookup?op=get&amp;search=0xC1CF6E31E6BADE8868B172B4F42ED6FBAB17C654&#x27;</span> | sudo apt-key add -</span><br></pre></td></tr></table></figure>
<h4 id="安装">安装</h4>
<p>桌面完整版：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt update &amp;&amp; sudo apt install ros-melodic-desktop-full -y</span><br></pre></td></tr></table></figure>
<h3 id="初始化rosdep">初始化rosdep</h3>
<p>初始化需要使用代理服务器，设置代理服务器后请修改<code>sudo</code>配置文件以传递环境变量。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo rosdep init</span><br><span class="line">rosdep update</span><br></pre></td></tr></table></figure>
<h3 id="设置环境">设置环境</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;source /opt/ros/melodic/setup.bash&quot; &gt;&gt; ~/.bashrc</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure>
<h3 id="构建工厂依赖">构建工厂依赖</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install python-rosinstall python-rosinstall-generator python-wstool build-essential</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title>安装Chromium浏览器并解决缺少 Google API 密钥问题</title>
    <url>/p/how-to-install-Chromium-and-solve-the-problem/</url>
    <content><![CDATA[<p><strong>Chromium</strong>是<a
href="https://zh.wikipedia.org/wiki/Google">Google</a>为发展浏览器<a
href="https://zh.wikipedia.org/wiki/Google_Chrome">Google
Chrome</a>而开启的免费开源软件项目。Chromium的用户界面极简。Google期望使浏览器“在认知和物理上都让人感觉轻巧，快速”。（英语：feel
lightweight (cognitively and physically) and fast.</p>
<p>本文主要介绍如何下载Chromium浏览器并解决缺少 Google API
密钥问题。</p>
<p><strong>关键词：Chromium缺少 Google API</strong></p>
<span id="more"></span>
<h4 id="下载chromium">下载Chromium</h4>
<p>官方站点：https://download-chromium.appspot.com/</p>
<p>分发站点：<a href="https://chromium.woolyss.com/#updater">Download
latest stable Chromium binaries (64-bit and 32-bit)
(woolyss.com)</a></p>
<p>解压后放置到任意文件夹。</p>
<h4 id="关闭缺少-google-api-密钥提示">关闭缺少 Google API 密钥提示</h4>
<p>首次打开Chromium时，地址栏下方会提示 <strong>缺少 Google API
密钥，因此 Chromium 的部分功能将无法使用</strong>。</p>
<p>法一：如不需要登录谷歌账户，仅仅想屏蔽上述烦人的提示，可以直接设置<strong>相关环境变量为<code>no</code></strong>，屏蔽提示。</p>
<p>打开 windows 的 <code>cmd</code> 命令提示符，依次输入以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">setx GOOGLE_API_KEY <span class="string">&quot;no&quot;</span></span><br><span class="line">setx GOOGLE_DEFAULT_CLIENT_ID <span class="string">&quot;no&quot;</span></span><br><span class="line">setx GOOGLE_DEFAULT_CLIENT_SECRET <span class="string">&quot;no&quot;</span></span><br></pre></td></tr></table></figure>
<p>法二：加入Chromuim-Dev谷歌群组并开启相关API</p>
<p>搬运自：http://www.chromium.org/developers/how-tos/api-keys</p>
<ol type="1">
<li><p>加入Google Groups <a
href="https://groups.google.com/a/chromium.org/forum/?fromgroups#!forum/chromium-dev">chromium-dev@chromium.org</a>，如果介意相关邮件打扰可以选择退订相关邮件。为方便起见，以下API仅限对订加入社群的人可见</p></li>
<li><p>确保登陆了已经订阅chromium-dev社群的Google账号</p></li>
<li><p>打开 https://cloud.google.com/console</p></li>
<li><p>创建或使用现有项目</p></li>
<li><p>选择
<code>API和服务-&gt;库</code>，搜索下图给出的API，并按需启用相关API</p></li>
<li><p>返回上级菜单，选择<code>凭据-&gt;创建凭据-&gt;OAuth客户端ID</code>，应用类型选择<code>桌面应用</code>，名称<code>任选</code>。记录得到的客户端ID和客户端密钥。</p></li>
<li><p>返回上级菜单，选择<code>凭据-&gt;创建凭据-&gt;API密钥</code>，名称<code>任选</code>。</p></li>
</ol>
<h5 id="设置环境变量">设置环境变量</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GOOGLE_API_KEY=your_api_key</span><br><span class="line">GOOGLE_DEFAULT_CLIENT_ID=your_client_id</span><br><span class="line">GOOGLE_DEFAULT_CLIENT_SECRET=your_client_secret</span><br></pre></td></tr></table></figure>
<p>完.</p>
]]></content>
      <tags>
        <tag>Chromium</tag>
      </tags>
  </entry>
  <entry>
    <title>crontab定时任务不执行</title>
    <url>/p/crontab-does-not-work/</url>
    <content><![CDATA[<p>在生产环境下，添加了 crontab
定时计划任务，后面发现，定时任务并没有执行，在指定的文件夹下并没有相对应的日志产生。</p>
<p><strong>关键词：crontab定时计划任务不执行</strong></p>
<span id="more"></span>
<h4 id="查看crontab服务状态">查看crontab服务状态</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">serivice cron status</span><br></pre></td></tr></table></figure>
<p>其中若出现
<code>(CRON) info (No MTA installed, discarding output)</code>字样，说明linux系统中没有安装<code>postfix</code>。Postfix
是一种电子邮件服务器软件。当crontab执行脚本时，会将输出通过本地的文本邮件的方式传递给当前用户，传递的内容存放在<code>/var/mail/&lt;当前用户名&gt;</code>文件中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install postfix -y</span><br></pre></td></tr></table></figure>
<h4
id="将标准错误和标准输出重定向到文件">将标准错误和标准输出重定向到文件</h4>
<p>当所有的输出重定向到文件以后，crontab就不会给本地用户发信息啦，也就解决了上节的问题。</p>
<p><strong>为了将所有的输出</strong>都重定向到文件，可以在cron里写
<code>*/1 * * * * r.sh</code></p>
<p><code>r.sh</code>里写
<code>a.sh &gt;&gt; /root/a.log 2&gt;&amp;1</code></p>
<h5 id="附录linux重定向">附录：linux重定向</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">command</span> &gt; filename 　　　　　把标准输出重定向到一个新文件中</span><br><span class="line"><span class="built_in">command</span> &gt;&gt; filename 　　　　　把标准输出重定向到一个文件中(追加)</span><br><span class="line"><span class="built_in">command</span> 1 &gt; fielname 　　　　　把标准输出重定向到一个文件中</span><br><span class="line"><span class="built_in">command</span> &gt; filename 2&gt;&amp;1 　　　把标准输出和标准错误一起重定向到一个文件中</span><br><span class="line"><span class="built_in">command</span> 2 &gt; filename 　　　　把标准错误重定向到一个文件中</span><br><span class="line"><span class="built_in">command</span> 2 &gt;&gt; filename 　　　　把标准输出重定向到一个文件中(追加)</span><br><span class="line"><span class="built_in">command</span> &gt;&gt; filename 2&gt;&amp;1 　　把标准输出和标准错误一起重定向到一个文件中(追加)</span><br><span class="line"><span class="built_in">command</span> &lt; filename &gt;filename2 　　把<span class="built_in">command</span>命令以filename文件作为标准输入，以filename2文件作为标准输出</span><br><span class="line"><span class="built_in">command</span> &lt; filename 　　　把<span class="built_in">command</span>命令以filename文件作为标准输入</span><br><span class="line"><span class="built_in">command</span> &lt;&lt; <span class="string">delimiter 　　把从标准输入中读入，直至遇到delimiter</span>分界符</span><br><span class="line"><span class="built_in">command</span> &lt;&amp;m 　　　把文件描述符m作为标准输入</span><br><span class="line"><span class="built_in">command</span> &gt;&amp;m 　　　把标准输出重定向到文件描述符m中</span><br><span class="line"><span class="built_in">command</span> &lt;&amp;- 　　　把关闭标准输入 </span><br></pre></td></tr></table></figure>
<p><strong>&gt; 默认为标准输出重定向，与 1&gt; 相同 2&gt;&amp;1</strong>
意思是把 标准错误输出 重定向到 标准输出.</p>
<p><strong>&amp;&gt;file</strong> 意思是把<strong>标准输出</strong> 和
<strong>标准错误输出</strong> 都重定向到文件file中</p>
<p><strong>/dev/null是一个文件，这个文件比较特殊，所有传给它的东西它都丢弃掉</strong></p>
]]></content>
      <tags>
        <tag>crontab</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Zerotier搭建内网穿透服务</title>
    <url>/p/how-to-use-Zerotier/</url>
    <content><![CDATA[<p>什么是Zerotier？</p>
<p>ZeroTier将整个世界转变为单个数据中心或云区域。像将所有设备，虚拟机和应用程序都插入同一交换机一样，将它们联网。</p>
<p>本文主要介绍如何使用Zerotier搭建内网穿透服务。</p>
<span id="more"></span>
<p>有两种连接方式，一种是创建自己管理的虚拟局域网，一种是加入别人已经建立的虚拟局域网。这里先说第一种。</p>
<h4 id="创建账号">创建账号</h4>
<p>https://www.zerotier.com/，点击<code>Sign up</code>.</p>
<p><img data-src="image-20210128181221059.png" /></p>
<p>根据自己需要，选择注册方式。</p>
<p><img data-src="image-20210128181326421.png" /></p>
<h4 id="创建网络">创建网络</h4>
<p><img data-src="image-20210128181610919.png" /></p>
<p>点击 <code>Create A Network</code>，创建自己管理的虚拟局域网。</p>
<p><img data-src="image-20210128181706204.png" /></p>
<p>创建成功以后会得到<code>Network ID</code>。点击网络ID，进入管理界面。</p>
<p><img data-src="image-20210128181808319.png" /></p>
<p>此时虚拟局域网内还没有设备，需要终端加入该网络。</p>
<h4 id="加入网络">加入网络</h4>
<p><img data-src="image-20210128181920181.png" /></p>
<p>点击<code>Download</code>，进入下载页面。</p>
<p><img data-src="image-20210128181957790.png" style="zoom:67%;" /></p>
<p>根据自己的设备类型选择安装包。这里以Windows为例。</p>
<p><img data-src="image-20210128182051328.png" alt="image-20210128182051328" style="zoom:50%;" /></p>
<p>等待下载完成，然后安装。</p>
<p><img data-src="image-20210128182357823.png" alt="image-20210128182357823" style="zoom:50%;" /></p>
<p>打开以后会默认在任务栏运行。</p>
<figure>
<img data-src="image-20210128182448852.png" alt="image-20210128182448852" />
<figcaption aria-hidden="true">image-20210128182448852</figcaption>
</figure>
<p>右键选择<code>Join a network</code>。</p>
<p><img data-src="image-20210128182523631.png" alt="image-20210128182523631" style="zoom:50%;" /></p>
<p>输入先前生成的网络ID，点击<code>Join</code>。其他选择默认设置即可。</p>
<p><img data-src="image-20210128182553099.png" alt="image-20210128182553099" style="zoom: 67%;" /></p>
<p>稍后片刻，返回到管理页面，允许自己的电脑加入该网络，即✔对应的设备。</p>
<p><img data-src="image-20210128182844550.png" /></p>
<p>得到虚拟网络的ip地址，之后再将另一个设备加入，就可以愉快的链接啦。</p>
<p><img data-src="image-20210128183032664.png" /></p>
]]></content>
      <tags>
        <tag>Zerotier</tag>
      </tags>
  </entry>
  <entry>
    <title>记MT7621平台刷入OpenWRT</title>
    <url>/p/how-to-config-OpenWRT/</url>
    <content><![CDATA[<p>什么是OpenWRT？</p>
<span id="more"></span>
<hr />
<h3 id="安装luci相关">安装luci相关</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">opkg install luci luci-base luci-i18n-base-zh-cn</span><br></pre></td></tr></table></figure>
<h3 id="开启sftp">开启sftp</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">opkg update</span><br><span class="line">opkg install vsftpd openssh-sftp-server</span><br><span class="line">/etc/init.d/vsftpd enable</span><br><span class="line">/etc/init.d/vsftpd start</span><br></pre></td></tr></table></figure>
<h3 id="opkg-腾讯源">opkg 腾讯源</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/opkg/distfeeds.conf</span><br></pre></td></tr></table></figure>
<p>写入以下文字</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">src/gz openwrt_core https://mirrors.cloud.tencent.com/openwrt/releases/19.07.2/targets/ramips/mt7621/packages</span><br><span class="line">src/gz openwrt_base https://mirrors.cloud.tencent.com/openwrt/releases/19.07.2/packages/mipsel_24kc/base</span><br><span class="line">src/gz openwrt_packages  https://mirrors.cloud.tencent.com/openwrt/releases/19.07.2/packages/mipsel_24kc/packages</span><br><span class="line">src/gz openwrt_luci https://mirrors.cloud.tencent.com/openwrt/releases/19.07.2/packages/mipsel_24kc/luci</span><br><span class="line">src/gz openwrt_routing https://mirrors.cloud.tencent.com/openwrt/releases/19.07.2/packages/mipsel_24kc/routing</span><br><span class="line">src/gz openwrt_freifunk https://mirrors.cloud.tencent.com/openwrt/releases/19.07.2/packages/mipsel_24kc/freifunk</span><br><span class="line">src/gz openwrt_telephony https://mirrors.cloud.tencent.com/openwrt/releases/19.07.2/packages/mipsel_24kc/telephony</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="luci禁用缓存">luci禁用缓存</h3>
<p>编辑/etc/config/luci</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">config internal &#x27;ccache&#x27;</span><br><span class="line">        option enable &#x27;0&#x27;</span><br></pre></td></tr></table></figure>
<p>重启即可</p>
<h3 id="扩容root分区">扩容root分区</h3>
<p>安装依赖</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">opkg update &amp;&amp; opkg install block-mount kmod-fs-ext4 kmod-usb-storage kmod-usb-ohci kmod-usb-uhci e2fsprogs fdisk</span><br></pre></td></tr></table></figure>
<p>查看sd卡信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">block info</span><br></pre></td></tr></table></figure>
<p>有类似回显，其中<code>/dev/mmcblk0p1</code>就是sd卡</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/dev/mtdblock5: UUID=&quot;d1f1302b-91ce24ca-2c74336e-eea51b51&quot; VERSION=&quot;4.0&quot; MOUNT=&quot;/rom&quot; TYPE=&quot;squashfs&quot;</span><br><span class="line">/dev/mtdblock6: MOUNT=&quot;/overlay&quot; TYPE=&quot;jffs2&quot;</span><br><span class="line">/dev/mmcblk0p1: UUID=&quot;746ffc51-1f29-2646-b2cb-fc2c03fe3c1a&quot; LABEL=&quot;sdcard&quot; VERSION=&quot;1.0&quot; TYPE=&quot;ext4&quot;</span><br></pre></td></tr></table></figure>
<p>格式化内存卡</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mkfs.ext4 /dev/mmcblk0p1</span><br></pre></td></tr></table></figure>
<p>将下面的DEVICE换成你的sd卡分区</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">DEVICE=<span class="string">&quot;/dev/mmcblk0p1&quot;</span></span><br><span class="line"><span class="built_in">eval</span> $(block info <span class="string">&quot;<span class="variable">$&#123;DEVICE&#125;</span>&quot;</span> | grep -o -e <span class="string">&quot;UUID=\S*&quot;</span>)</span><br><span class="line">uci -q delete fstab.overlay</span><br><span class="line">uci <span class="built_in">set</span> fstab.overlay=<span class="string">&quot;mount&quot;</span></span><br><span class="line">uci <span class="built_in">set</span> fstab.overlay.uuid=<span class="string">&quot;<span class="variable">$&#123;UUID&#125;</span>&quot;</span></span><br><span class="line">uci <span class="built_in">set</span> fstab.overlay.target=<span class="string">&quot;/overlay&quot;</span></span><br><span class="line">uci commit fstab</span><br></pre></td></tr></table></figure>
<p>转移数据</p>
<p>如有报错请先查看否自动挂载了sd卡，挂载sd卡时也可能出现如下报错，实测不影响。</p>
<p>报错信息：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">root@GL-MT1300:~<span class="comment"># mount /dev/mmcblk0p1 /mnt/</span></span><br><span class="line">NTFS signature is missing.</span><br><span class="line">Failed to mount <span class="string">&#x27;/dev/mmcblk0p1&#x27;</span>: Invalid argument</span><br><span class="line">The device <span class="string">&#x27;/dev/mmcblk0p1&#x27;</span> doesn<span class="string">&#x27;t seem to have a valid NTFS.</span></span><br><span class="line"><span class="string">Maybe the wrong device is used? Or the whole disk instead of a</span></span><br><span class="line"><span class="string">partition (e.g. /dev/sda, not /dev/sda1)? Or the other way around?</span></span><br></pre></td></tr></table></figure>
<p>执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mount /dev/mmcblk0p1 /mnt</span><br><span class="line">cp -f -a /overlay/. /mnt</span><br><span class="line">umount /mnt</span><br></pre></td></tr></table></figure>
<p>然后重启</p>
<p>扩展分区前</p>
<p><img data-src="image-20210122191844339.png" /></p>
<p>扩展分区后</p>
<p><img data-src="image-20210122191907269.png" /></p>
<h3 id="单独编译openwrt-ipk">单独编译openwrt ipk</h3>
<p>先执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make menuconfig </span><br></pre></td></tr></table></figure>
<p>然后选中相关组件</p>
<p>再执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make package/feeds/luci/luci-base/compile -j1 V=s</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>OpenWRT</tag>
        <tag>MT7621</tag>
      </tags>
  </entry>
  <entry>
    <title>ssh-genkey参数</title>
    <url>/p/ssh-genkey/</url>
    <content><![CDATA[<p>什么是ssh-genkey？</p>
<p>ssh
公钥认证是ssh认证的方式之一。通过公钥认证可实现ssh免密码登陆，git的ssh方式也是通过公钥进行认证的。</p>
<p>在用户目录的home目录下，有一个<code>.ssh</code>的目录，和当前用户ssh配置认证相关的文件，几乎都在这个目录下。</p>
<p><code>ssh-keygen</code>
可用来生成ssh公钥认证所需的公钥和私钥文件。</p>
<span id="more"></span>
<h2 id="常用命令">常用命令</h2>
<h3 id="生成密钥对">生成密钥对</h3>
<p>默认生成 2048 位 RSA 密钥</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure>
<p>生成 4096 位 RSA 密钥</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096</span><br></pre></td></tr></table></figure>
<p>生成 521 位 ECDSA 密钥</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t ecdsa -b 521</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>ssh-genkey</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Proxmox VE的KVM虚拟化实战</title>
    <url>/p/pve-pci-passthrough/</url>
    <content><![CDATA[<p>Proxmox VE是一个既可以运行虚拟机也可以运行容器的虚拟化平台。Proxmox
VE基于Debian Linux 开发，而且完全开源。处于灵活性的考虑，Proxmox
VE同时支持两种虚拟化技术：KVM虚拟机和LXC容器。以下操作基于KVM虚拟机。</p>
<span id="more"></span>
<p><strong>任务背景：</strong>实验室有一台闲置的服务器，配置是64GB内存，10GB
NVIDIA RTX 2080 Ti 显卡，i9-10900K
20核CPU。组内有师姐需要跑深度学习代码，而师兄的项目需要在服务器上运行数据库。为了实现数据隔离（生产环境不影响开发环境），考虑了一下两种方案：</p>
<p>1.Docker方案。服务器装ubuntu系统，每个任务运行一个docker
容器。优点是运行任务简单，直接<code>docker pull</code>
相应的容器即可。缺点对于不熟悉docker运维的人来说，维护相对复杂，有些任务需要持久化，需要将不同容器的不同目录映射到ubuntu下的目录。这样无法实现数据隔离，违背了初衷，而且无法实现<code>ip</code>直接访问，需要设置端口映射。遂放弃。</p>
<p>2.PVE-KVM方案。宿主机安装基于<code>debian</code>的<code>Proxmox VE</code>操作系统，不同的任务创建不同的客户机，根据<code>VM ID</code>和<code>ip</code>区分客户机。缺点是配置复杂。<strong><font color="red">不过生命在于折腾，生命不止，折腾不息。</font></strong></p>
<h4 id="准备工作">准备工作</h4>
<p>检查CPU是否支持VT-d ：
https://ark.intel.com/content/www/cn/zh/ark.html</p>
<p><img data-src="image-20210112135114468.png" /></p>
<h4 id="设置国内源">设置国内源</h4>
<p>修改PVE Debian 源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -i <span class="string">&#x27;s|^deb http://ftp.debian.org|deb https://mirrors.ustc.edu.cn|g&#x27;</span> /etc/apt/sources.list</span><br><span class="line">sed -i <span class="string">&#x27;s|^deb http://security.debian.org|deb https://mirrors.ustc.edu.cn/debian-security|g&#x27;</span> /etc/apt/sources.list</span><br></pre></td></tr></table></figure>
<p>添加 Proxmox 社区源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/os-release</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb https://mirrors.ustc.edu.cn/proxmox/debian/pve <span class="variable">$VERSION_CODENAME</span> pve-no-subscription&quot;</span> &gt; /etc/apt/sources.list.d/pve-no-subscription.list</span><br></pre></td></tr></table></figure>
<p>删除 Proxmox 企业源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/os-release</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;#deb https://enterprise.proxmox.com/debian/pve <span class="variable">$VERSION_CODENAME</span> pve-enterprise&quot;</span> &gt; /etc/apt/sources.list.d/pve-enterprise.list</span><br></pre></td></tr></table></figure>
<h4 id="删除订阅弹窗">删除订阅弹窗</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行完成后，浏览器Ctrl+F5强制刷新缓存</span></span><br><span class="line">sed -Ezi.bak <span class="string">&quot;s/(Ext.Msg.show\(\&#123;\s+title: gettext\(&#x27;No valid sub)/void\(\&#123; \/\/\1/g&quot;</span> /usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.js &amp;&amp; systemctl restart pveproxy.service</span><br></pre></td></tr></table></figure>
<h4 id="修改节点名称">修改节点名称</h4>
<ol type="1">
<li><p>修改 <code>/etc/hostname</code> 、 <code>/etc/hosts</code> 、
<code>/etc/postfix/mail.cf</code>里的主机名称，保存</p></li>
<li><p>复制 <code>/etc/pve/nodes/旧节点名称/</code> 所有文件 至
<code>/etc/pve/nodes/新节点名称/</code> 目录。</p>
<p>直接cp或者mv的话，这一步可能会报错</p>
<p><font color="red">cannot create regular file
‘/etc/pve/nodes/新节点名称/qemu-server/***.conf’: File
exists</font></p></li>
<li><p>如果报错：</p>
<ol type="1">
<li>将旧节点 <code>/etc/pve/nodes/旧节点名称/qemu-server/</code>
目录下的所有 <strong>.conf</strong>
文件转移到其他地方，比如下载到本地</li>
<li>删除旧节点目录 <code>/etc/pve/nodes/旧节点名称/</code></li>
<li>将备份的 <strong>.conf</strong> 文件转移回
<code>/etc/pve/nodes/新节点名称/qemu-server/</code> 目录</li>
</ol></li>
<li><p>重启PVE，在WEB端可以看到节点名称已更改，且旧节点已删除</p></li>
<li><p>修改节点名称后，可能需要修改一下<strong>附加的存储、NFS目录等</strong></p></li>
</ol>
<h4 id="添加多块硬盘">添加多块硬盘</h4>
<h4 id="方法一">方法一</h4>
<ol type="1">
<li><p>选择对应节点----&gt;磁盘-----&gt;需要添加的磁盘，选择<strong>擦除磁盘</strong></p>
<p><img data-src="image-20220503161235807.png" /></p>
<p>勾选<strong>存储</strong>目录选项，等待擦除完毕</p>
<p><img data-src="image-20220503161356950.png" /></p></li>
<li><p>检查是否添加成功：依次点击数据中心----&gt;存储</p>
<p><img data-src="image-20220503161723325.png" /></p></li>
</ol>
<h5 id="方法二">方法二</h5>
<ol type="1">
<li>分区</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fdisk /dev/sde1</span><br><span class="line">&gt; n</span><br><span class="line">&gt; w</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>格式化</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkfs -t ext4 /dev/sde1</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>创建目录</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /mnt/sde1</span><br></pre></td></tr></table></figure>
<ol start="4" type="1">
<li>挂载</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount -t ext4 /dev/sde1 /mnt/sde1</span><br></pre></td></tr></table></figure>
<ol start="5" type="1">
<li>写入启动项</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> /dev/sde1 /mnt/sde1 ext4 defaults 0 2 &gt;&gt; /etc/fstab</span><br></pre></td></tr></table></figure>
<h4 id="启用内存ballooning">启用内存ballooning</h4>
<p>简单理解就是宿主机会收集和客户机未使用的内存，以免内存会浪费。</p>
<p>但启用内存ballooning也有缺点，如：</p>
<ol type="1">
<li>Ballooning需要客户机操作系统加载virtio_balloon驱动，然而并非每个客户机系统都有该驱动（如windows需要自己安装该驱动）</li>
<li>如果有大量内存从客户机系统中回收，Ballooning可能会降低客户机操作系统运行的性能。一方面，内存的减少，可能会让客户机中作为磁盘数据缓存的内存被放到气球中，从而客户机中的磁盘I/O访问会增加；另一方面，如果处理机制不够好，也可能让客户机中正在运行的进程由于内存不足而执行失败。</li>
<li>目前没有比较方便的、自动化的机制来管理ballooning，一般都是采用在QEMU
monitor中执行balloon命令来实现ballooning的。没有对客户机的有效监控，没有自动化的ballooning机制，这可能会让生产环境中实现大规模自动化部署并不很方便。</li>
<li>内存的动态增加或减少，可能会使内存被过度碎片化，从而降低内存使用时的性能。</li>
</ol>
<p>在PVE中可以简单的开启内存ballooning</p>
<ol type="1">
<li><p>创建虚拟机时，在内存选项勾选<strong>Ballooning设备</strong></p>
<p><img data-src="image-20220503163938958.png" /></p></li>
<li><p>查看是否启用成功</p>
<p>进入客户机，输入以下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lspci | grep <span class="string">&quot;Red Hat&quot;</span></span><br></pre></td></tr></table></figure>
<p><img data-src="image-20220503164147722.png" /></p>
<p>如看到 <font color="red"><strong>Red Hat</strong>, Inc. Virtio memory
balloon</font> 说明启用成功</p></li>
<li><p>查看宿主机回收了多少内存</p>
<p>登录宿主机，如这里要查看编号为102客户机的内存回收情况，输入一下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qm monitor 102 <span class="comment"># 进入qm shell</span></span><br><span class="line">qm&gt;info balloon</span><br></pre></td></tr></table></figure>
<p><img data-src="image-20220503164718636.png" /></p></li>
</ol>
<p>​
这里的<code>free_mem</code>就是宿主机从客户机回收的内存大小，可以看到，总共分配了8G，这里回收了大概7G多。在客户机负载比较低的时候还是很有用的。</p>
<h4 id="创建虚拟机">创建虚拟机</h4>
<p>千万注意不要设置自启动！！</p>
<p><img data-src="image-20210112135351055.png" /></p>
<p>选择自己上传的系统镜像，这里以Ubuntu 2004为例。</p>
<p><img data-src="image-20210112135506814.png" /></p>
<p>设置系统选项，注意使用<font color="red"><strong>EFI模式</strong></font></p>
<p><img data-src="image-20210112140758741.png" /></p>
<p>选择CPU时，请根据你的CPU核心数选择。类别选择host。此种模式下客户机下可以看到当前CPU的型号，同时尽量保证虚拟机内的CPU指令集和宿主机内一致。</p>
<p><img data-src="image-20210112140906881.png" /></p>
<p><strong>网络选择：</strong>一般情况下选择默认即可。默认是网桥接入。网桥相当于一个软件实现的物理交换机。所有虚拟机共享一个网桥。网桥接入模式下，可以在上一级网关设备查看当前客户机的IP地址。</p>
<p><img data-src="image-20210112141534116.png" /></p>
<p>确认设置，<strong>先不要开启虚拟机</strong>。</p>
<p><img data-src="image-20210112141614131.png" /></p>
<h5 id="配置显卡直通">配置显卡直通</h5>
<p>首先编辑GRUB配置文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nano /etc/default/grub</span><br></pre></td></tr></table></figure>
<p>开启开启IOMMU支持：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GRUB_CMDLINE_LINUX_DEFAULT=<span class="string">&quot;quiet intel_iommu=on video=efifb:off&quot;</span></span><br></pre></td></tr></table></figure>
<p>如果是AMD的CPU：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GRUB_CMDLINE_LINUX_DEFAULT=<span class="string">&quot;quiet amd_iommu=on video=efifb:off&quot;</span></span><br></pre></td></tr></table></figure>
<p>我是Intel的CPU，因此修改为：</p>
<p><img data-src="image-20210112142014140.png" /></p>
<p>更新GRUB：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">update-grub</span><br></pre></td></tr></table></figure>
<p>添加所需的系统模块（驱动）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;vfio&quot;</span> &gt;&gt; /etc/modules</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;vfio_iommu_type1&quot;</span> &gt;&gt; /etc/modules</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;vfio_pci&quot;</span> &gt;&gt; /etc/modules</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;vfio_virqfd&quot;</span> &gt;&gt; /etc/modules</span><br></pre></td></tr></table></figure>
<p>接着添加模块（驱动）黑名单，即让GPU设备在下次系统启动之后不使用这些驱动，把设备腾出来给<code>vfio</code>驱动用：</p>
<p>N卡/A卡：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;blacklist nouveau&quot;</span> &gt;&gt; /etc/modprobe.d/pve-blacklist.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;blacklist nvidiafb&quot;</span> &gt;&gt; /etc/modprobe.d/pve-blacklist.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;blacklist radeon&quot;</span> &gt;&gt; /etc/modprobe.d/pve-blacklist.conf</span><br></pre></td></tr></table></figure>
<p>如果是N卡还需要加入下面的配置到kvm.conf（据老外说是避免一些莫名其妙的错误）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;options vfio_iommu_type1 allow_unsafe_interrupts=1&quot; &gt; /etc/modprobe.d/iommu_unsafe_interrupts.conf</span><br><span class="line">echo &quot;options kvm ignore_msrs=1&quot; &gt; /etc/modprobe.d/kvm.conf</span><br></pre></td></tr></table></figure>
<p>更新内核：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">update-initramfs -u</span><br></pre></td></tr></table></figure>
<p>重启机器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure>
<p>重启上来之后检查模块是否正常加载：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsmod | grep vfio</span><br></pre></td></tr></table></figure>
<p>成功的话有类似回显：</p>
<p><img data-src="image-20210112142429876.png" /></p>
<p>查看GPU设备ID：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lspci -nn | grep VGA</span><br></pre></td></tr></table></figure>
<p>会有类似的回显：</p>
<p><img data-src="image-20210112142511212.png" /></p>
<p>再执行下面的命令<strong>(01:00.0请替换成你的显卡ID)</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lspci -vvv -s 01:00.0</span><br></pre></td></tr></table></figure>
<p>会有类似的回显：</p>
<p><img data-src="image-20210112152426155.png" /></p>
<p><img data-src="image-20210112152400447.png" /></p>
<p>现在把需要直通给虚拟机的设备ID写到vfio.conf内，注意这次这里的ID不是01:00.0而是自己查看自己设备的ID，ID查看在上面回显里：</p>
<p><img data-src="image-20210112152916014.png" /></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;options vfio-pci ids=10de:1e07&quot;</span> &gt;&gt; /etc/modprobe.d/vfio.conf</span><br></pre></td></tr></table></figure>
<p>然后应用更改：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">update-grub</span><br><span class="line">update-initramfs</span><br></pre></td></tr></table></figure>
<h5 id="更改虚拟机主机类型">更改虚拟机主机类型</h5>
<p>其中100 是VM ID</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qm <span class="built_in">set</span> 100 -machine pc-q35-3.1</span><br></pre></td></tr></table></figure>
<h5 id="添加显卡">添加显卡</h5>
<p>添加PCI设备，注意ID要选择你的电脑对应的显卡ID。注意不要添加成其他设备，如Audio
device等。</p>
<p><img data-src="image-20210112153802857.png" /></p>
<p><img data-src="image-20210112154050976.png" /></p>
<h5 id="安装操作系统">安装操作系统</h5>
<p>此过程略</p>
<h5 id="伪装cpu">伪装CPU</h5>
<p>由于NVIDIA官方限制在虚拟机中使用显卡，通过修改CPU类型，可以达到欺骗NVIDIA显卡驱动的目的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nano /etc/pve/qemu-server/&lt;你的虚拟机的ID&gt;.conf</span><br></pre></td></tr></table></figure>
<p>找到CPU那一行，删掉，然后改为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cpu: host,hidden=1,flags=+pcid</span><br><span class="line">args: -cpu &#x27;host,+kvm_pv_unhalt,+kvm_pv_eoi,hv_vendor_id=NV43FIX,kvm=off&#x27;</span><br></pre></td></tr></table></figure>
<p>如下图：</p>
<p><img data-src="image-20210112154651328.png" /></p>
<h5 id="安装显卡驱动">安装显卡驱动</h5>
<p>以下操作是在<font color="red">客户机</font>上完成的，根据显卡选择合适的驱动安装。</p>
<p><img data-src="image-20210112155127152.png" /></p>
<p>安装完毕，重启客户机。执行一下命令查看驱动是否安装成功：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nvidia-smi</span><br></pre></td></tr></table></figure>
<p>有下图所示回显说明安装成功：</p>
<p><img data-src="image-20210112155315385.png" /></p>
<h5 id="安装qemu-guest-agent">安装qemu-guest-agent</h5>
<p>客户机安装<code>qemu-guest-agent</code>，可以在宿主机直接关闭客户机而不需要客户机确认</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install qemu-guest-agent -y</span><br></pre></td></tr></table></figure>
<h4 id="pve配置wifi">PVE配置WiFi</h4>
<p>如果你的pve宿主机有无线网卡，可以按照如下步骤配置无线连接。</p>
<h5 id="安装必要的软件">安装必要的软件</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install connman -y</span><br></pre></td></tr></table></figure>
<h5 id="设置网络接口">设置网络接口</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nano /etc/network/interfaces</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line"></span><br><span class="line">auto wlp3s0</span><br><span class="line">iface wlp3s0 inet dhcp</span><br><span class="line">        wpa-ssid <span class="string">&quot;SSID&quot;</span></span><br><span class="line">        wpa-psk <span class="string">&quot;PASSWORD&quot;</span></span><br><span class="line">auto vmbr0</span><br><span class="line">iface vmbr0 inet static</span><br><span class="line">        address 192.168.0.1</span><br><span class="line">        netmask 255.255.255.0</span><br><span class="line">        bridge_ports none</span><br><span class="line">        bridge_stp off</span><br><span class="line">        bridge_fd 0</span><br></pre></td></tr></table></figure>
<h4 id="pve的四种网络模式">PVE的四种网络模式</h4>
<h5 id="基于网桥的默认配置">基于网桥的默认配置</h5>
<p>网桥相当于一个软件实现的物理交换机。所有虚拟机共享一个网桥，在多个域的网络环境中，
也可以创建多个网桥以分别对应不同网络域。理论上，每个Proxmox VE
最多可以支持4094个网桥。</p>
<p>Proxmox VE 安装程序会创建一个名为vmbr0
的网桥，并和检测到的服务器第一块网卡桥接。</p>
<p><img data-src="default-network-setup-bridge-16407688858982.svg" /></p>
<p>配置文件<code>/etc/network/interfaces</code>
中的对应配置信息如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line"></span><br><span class="line">iface enp2s0 inet manual</span><br><span class="line"></span><br><span class="line">auto vmbr0</span><br><span class="line">iface vmbr0 inet static</span><br><span class="line">        address 192.168.10.2/24</span><br><span class="line">        gateway 192.168.10.1</span><br><span class="line">        bridge_ports enp2s0</span><br><span class="line">        bridge_stp off</span><br><span class="line">        bridge_fd 0</span><br><span class="line"></span><br><span class="line">iface enp4s0 inet manual</span><br><span class="line"></span><br><span class="line">iface wlp3s0 inet manual</span><br></pre></td></tr></table></figure>
<p>在基于网桥的默认配置下，虚拟机看起来就和直接接入物理网络一样。尽管所有虚拟机共享
一根网线接入网络，但每台虚拟机都使用自己独立的MAC 地址访问网络。</p>
<p><strong>注意：这种模式在当前是通过无线网卡连接外网的状态下可能无法正常工作！</strong></p>
<h5 id="路由配置">路由配置</h5>
<p>处于网络安全的考虑，大部分网络服务托管商一旦发现网络接口上有多个mac地址出现，托管商有可能立刻禁用相关网络接口。</p>
<blockquote>
<p>也许有些网络服务托管商也允许你注册多个mac地址，这样就可以避免上面提到的问题，但这样就需要注册每一个虚拟机的mac地址，实际操作会很麻烦。</p>
</blockquote>
<p>可以采用路由的方式让多个虚拟机共享一个网络端口，这样就可以避免上面提到的问题。这种方式可以确保所有的对外网络通信都使用同一个MAC地址。</p>
<p><img data-src="default-network-setup-routed.svg" /></p>
<p>常见的应用场景是吗，你有一个可以和外部网络通信的IP地址，假定为（192.51.100.5），还有一个供虚拟机使用的IP地址段（203.0.113.16/29）。针对该场景，推荐使用以下配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line"></span><br><span class="line">auto eno0</span><br><span class="line">iface eno0 inet static</span><br><span class="line">        address  198.51.100.5/29</span><br><span class="line">        gateway  198.51.100.1</span><br><span class="line">        post-up <span class="built_in">echo</span> 1 &gt; /proc/sys/net/ipv4/ip_forward</span><br><span class="line">        post-up <span class="built_in">echo</span> 1 &gt; /proc/sys/net/ipv4/conf/eno1/proxy_arp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">auto vmbr0</span><br><span class="line">iface vmbr0 inet static</span><br><span class="line">        address  203.0.113.17/28</span><br><span class="line">        bridge-ports none</span><br><span class="line">        bridge-stp off</span><br><span class="line">        bridge-fd 0</span><br></pre></td></tr></table></figure>
<p>路由模式下，需要在PVE内部搭建DHCP服务器，以便在启动虚拟机时，动态获取网络配置（IP，网关等），该模式下无法直接访问PVE内部虚拟机。如果像直接访问，可以通过代理或者端口转发方式。</p>
<h5
id="基于iptables的网络地址转换配置nat">基于iptables的网络地址转换配置（NAT）</h5>
<p>利用地址转换技术，所有虚拟机可以使用内部私有IP 地址，并通过Proxmox VE
服务器的IP来访问外部网络。Iptables
将改写虚拟机和外部网络通信数据包，对于虚拟机向外部网络发出的数据包，将源IP
地址替换成服务器IP
地址，对于外部网络返回数据包，将目的地址替换为对应虚拟机IP 地址。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line"></span><br><span class="line">auto eno1</span><br><span class="line"><span class="comment">#real IP address</span></span><br><span class="line">iface eno1 inet static</span><br><span class="line">        address  198.51.100.5/24</span><br><span class="line">        gateway  198.51.100.1</span><br><span class="line"></span><br><span class="line">auto vmbr0</span><br><span class="line"><span class="comment">#private sub network</span></span><br><span class="line">iface vmbr0 inet static</span><br><span class="line">        address  10.10.10.1/24</span><br><span class="line">        bridge-ports none</span><br><span class="line">        bridge-stp off</span><br><span class="line">        bridge-fd 0</span><br><span class="line"></span><br><span class="line">        post-up   <span class="built_in">echo</span> 1 &gt; /proc/sys/net/ipv4/ip_forward</span><br><span class="line">        post-up   iptables -t nat -A POSTROUTING -s <span class="string">&#x27;10.10.10.0/24&#x27;</span> -o eno1 -j MASQUERADE</span><br><span class="line">        post-down iptables -t nat -D POSTROUTING -s <span class="string">&#x27;10.10.10.0/24&#x27;</span> -o eno1 -j MASQUERADE</span><br></pre></td></tr></table></figure>
<h4 id="lvc容器网络配置">LVC容器网络配置</h4>
<p>在宿主机的网络配置是通过iptables进行NAT的基础下，设置容器的网络地址为静态配置，从而容器可以正常上网。</p>
<h5 id="安装必要软件">安装必要软件</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt install proxmox-ve postfix open-iscsi -y</span><br></pre></td></tr></table></figure>
<h5 id="下载导入模板">下载、导入模板</h5>
<p><a
href="https://www.cxthhhhh.com/2020/11/08/system-image-the-latest-template-v1-2-of-ubuntu-20-04-lxc-ovz-ssh-enabled-time-zone-optimized.html">点此下载</a></p>
<h5 id="创建lvc容器">创建LVC容器</h5>
<p>注意勾选<strong>无特权的容器</strong></p>
<p><img data-src="image-20211229172815237.png" /></p>
<h5 id="配置网络">配置网络</h5>
<p>桥接vmbr0，设置网关和服务器的IP</p>
<p><img data-src="image-20211229173154573.png" /></p>
<h5 id="设置嵌套虚拟化">设置嵌套虚拟化</h5>
<p>如果需要在LVC容器中安装docker需要设置此项</p>
<p><img data-src="image-20211229173637309.png" /></p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS实战（五）｜NVIDIA Jetson Xavier NX</title>
    <url>/p/How-to-use-Jetson-Xavier/</url>
    <content><![CDATA[<p><strong>摘要：</strong>最近实验室买了两块嵌入式NVIDIA Jetson Xavier
NX 开发板，学长拿来让我折腾下，遂有了这篇文章。</p>
<p><strong>关键词：</strong>Jetson，NVIDIA，CUDA</p>
<span id="more"></span>
<h3 id="介绍">介绍</h3>
<p>略</p>
<h3 id="制作启动盘">制作启动盘</h3>
<p>NVIDIA Jetson Xavie
NX镜像下载地址：https://developer.nvidia.com/embedded/downloads#?search=Jetson%20NX</p>
<p><img data-src="image-20220526124139445.png" /></p>
<p>板子使用的是SD卡作为引导盘和存储盘的，首先要格式化内存卡。使用<strong>SD
Card Formatter</strong>格式化内存卡。<a
href="https://www.sdcard.org/downloads/formatter/eula_windows/">SD Card
Formatter下载地址</a></p>
<p>格式化时注意<strong>盘符</strong>，随后点击<strong>Format</strong>.</p>
<h4 id="烧录镜像到内存卡">烧录镜像到内存卡</h4>
<p>使用<strong>balenaEtcher</strong>软件烧录镜像。下载地址：https://www.balena.io/etcher/</p>
<p>选择下载好的<strong>jetson-nx-jp441-sd-card-image</strong>文件，点击Flash.</p>
<p>刷写完以后会有一个验证数据的操作，不建议跳过。</p>
<p>稍后片刻，等待完成。</p>
<h3 id="点亮主机">点亮主机</h3>
<p>把SD卡插入卡槽，将HDMI线连接到屏幕上，插入鼠标和键盘，启动电源。</p>
<h3 id="初始配置">初始配置</h3>
<h4 id="采用m.2-key-m-ssd作为启动盘">采用M.2 Key M SSD作为启动盘</h4>
<ol type="1">
<li><p>打开Ubuntu18.04自带 Disks 工具，'Ctrl+F' 或点击右上角选择‘Format
Disk' 并将其格式化为GPT 格式</p></li>
<li><p>格式化时必须选择“Ext4”， 等待完成后，点击下方 '三角按钮'，mount
到固定目录如<code>/media/nvidia/xxxx</code></p></li>
<li><p>执行以下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/jetsonhacks/rootOnNVMe.git</span><br><span class="line"><span class="built_in">cd</span> rootOnNVMe</span><br><span class="line">./copy-rootfs-ssd.sh</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./setup-service.sh</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="更改apt源">更改apt源</h4>
<p>感谢<a
href="https://mirrors.tuna.tsinghua.edu.cn/">清华大学开源软件镜像</a>对开源软件的大力支持。</p>
<p>备份原有源文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> /etc/apt/sources.list /etc/apt/sources.list.bak</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/apt/sources.list</span><br></pre></td></tr></table></figure>
<p>将以下内容粘贴到终端</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-updates main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-backports main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-security main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line"># 预发布软件源，不建议启用</span><br><span class="line"># deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-proposed main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-proposed main restricted universe multiverse</span><br></pre></td></tr></table></figure>
<p>更新系统</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt update &amp;&amp; sudo apt upgrade -y</span><br></pre></td></tr></table></figure>
<h4 id="更改pypi源">更改pypi源</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sudo install python3-pip</span><br><span class="line">python3 -m pip install -i https://mirrors.cloud.tencent.com/pypi/simple --upgrade pip</span><br><span class="line">python3 -m pip install config <span class="built_in">set</span> <span class="keyword">global</span>.index-url https://mirrors.cloud.tencent.com/pypi/simple</span><br></pre></td></tr></table></figure>
<h4 id="风扇控制">风扇控制</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> 255 &gt; /sys/devices/pwm-fan/target_pwm</span><br><span class="line"><span class="comment">#范围0-255,风扇默认是不开的</span></span><br></pre></td></tr></table></figure>
<p>重启以后风扇是不转的，所以需要设置开机运行：
创建<code>/etc/rc.local</code>，并添加如下内容：
（注：系统启动的时候会执行<code>/etc/rc.local</code>，如果已存在rc.local，则在<code>exit 0</code>之前加入那3句命令即可）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">sleep</span> 10</span><br><span class="line">sudo /usr/bin/jetson_clocks</span><br><span class="line">sudo sh -c <span class="string">&#x27;echo 255 &gt; /sys/devices/pwm-fan/target_pwm&#x27;</span></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure>
<p>添加执行权限： <code>sudo chmod 755 /etc/rc.local</code></p>
<p>以后重启就会自动开启最大性能并启动风扇了。</p>
<h4 id="远程桌面">远程桌面</h4>
<p>开机以后SSH默认是开启的。这里使用Nomachine作为远程桌面软件。Nomachine的专有NX协议在高延迟低带宽的链路上提供了近乎本地速度的响应能力。</p>
<p><a
href="https://fly97.coding.net/p/github-projects/d/nomachine/git/raw/master/nomachine_6.12.3_5_arm64.deb">ARM64客户端下载链接</a></p>
<p><a
href="https://fly97.coding.net/p/github-projects/d/nomachine/git/raw/master/nomachine_6.12.3_7.exe">Windows客户端下载链接</a></p>
<h4 id="设置分辨率">设置分辨率</h4>
<p>如果没有显示器连接，默认VNC 连接后的分辨率为640x480
，将以下内容添加到<code>/etc/X11/xorg.conf</code>文件，将其设置为默认VNC分辨率设置。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Section <span class="string">&quot;Screen&quot;</span></span><br><span class="line">   Identifier    <span class="string">&quot;Default Screen&quot;</span></span><br><span class="line">   Monitor       <span class="string">&quot;Configured Monitor&quot;</span></span><br><span class="line">   Device        <span class="string">&quot;Tegra0&quot;</span></span><br><span class="line">   SubSection <span class="string">&quot;Display&quot;</span></span><br><span class="line">       Depth    24</span><br><span class="line">       Virtual 1024 768 <span class="comment"># Modify the resolution by editing these values</span></span><br><span class="line">   EndSubSection</span><br><span class="line">EndSection</span><br></pre></td></tr></table></figure>
<h4 id="快捷设置代理">快捷设置代理</h4>
<p>在<code>/home</code>目录下，把一下内容加入到<code>.bashrc</code>.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">alias</span> proxy=<span class="string">&#x27;export all_proxy=http://127.0.0.1:10809</span></span><br><span class="line"><span class="string">export https_proxy=http://127.0.0.1:10809</span></span><br><span class="line"><span class="string">export socks_proxy=socks5://127.0.0.1:10808&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> unproxy=<span class="string">&#x27;unset all_proxy https_proxy socks_proxy&#x27;</span></span><br></pre></td></tr></table></figure>
<h4 id="安装jtop">安装Jtop</h4>
<p>Jtop（一个系统监视实用程序，可在终端上运行，并实时查看和控制 NVIDIA
Jetson的状态 ）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install python3-pip</span><br><span class="line">sudo pip3 install jetson-stats </span><br><span class="line">sudo jtop</span><br></pre></td></tr></table></figure>
<h4 id="查看当前运行功率">查看当前运行功率</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查询当前状态</span></span><br><span class="line">sudo nvpmodel --query</span><br><span class="line"><span class="comment">#切换状态</span></span><br><span class="line">sudo nvpmodel -m <span class="comment">#Mode_ID</span></span><br><span class="line"><span class="comment">#查看处理器状态</span></span><br><span class="line">sudo jetson_clocks --show</span><br><span class="line"><span class="comment">#如果jetson_clocks 后没有参数，则直接开启static MAX 模式</span></span><br><span class="line">sudo jetson=_clocks</span><br></pre></td></tr></table></figure>
<h4 id="安装pytorch">安装Pytorch</h4>
<p><a
href="https://forums.developer.nvidia.com/t/pytorch-for-jetson-version-1-7-0-now-available/72048">下载地址</a></p>
<p>根据自己的Python环境下载whl文件.这里是Python
3.6.9，安装的版本是PyTorch v1.7。</p>
<p>安装命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install python3-pip libopenblas-base libopenmpi-dev </span><br><span class="line">python3 -m pip install Cython</span><br><span class="line">python3 -m pip install numpy torch-1.7.0-cp36-cp36m-linux_aarch64.whl</span><br></pre></td></tr></table></figure>
<h5 id="安装torchvision">安装torchvision</h5>
<p>以<strong>v0.8.1</strong>为例.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libjpeg-dev zlib1g-dev libpython3-dev libavcodec-dev libavformat-dev libswscale-dev</span><br><span class="line">git <span class="built_in">clone</span> --branch v0.8.1 https://e.coding.net/fly97/mechine-learning/torchvision.git   <span class="comment"># see below for version of torchvision to download</span></span><br><span class="line"><span class="built_in">cd</span> torchvision</span><br><span class="line"><span class="built_in">export</span> BUILD_VERSION=v0.8.1  <span class="comment"># where 0.x.0 is the torchvision version</span></span><br><span class="line">python3 -m pip  <span class="string">&#x27;pillow&lt;7&#x27;</span> <span class="comment"># always needed for Python 2.7, not needed torchvision v0.5.0+ with Python 3.6</span></span><br><span class="line">sudo python setup.py install     <span class="comment"># use python3 if installing for Python 3.6</span></span><br><span class="line"><span class="built_in">cd</span> ../  <span class="comment"># attempting to load torchvision from build dir will result in import error</span></span><br></pre></td></tr></table></figure>
<p>对应版本：</p>
<ul>
<li>PyTorch v1.0 - torchvision v0.2.2</li>
<li>PyTorch v1.1 - torchvision v0.3.0</li>
<li>PyTorch v1.2 - torchvision v0.4.0</li>
<li>PyTorch v1.3 - torchvision v0.4.2</li>
<li>PyTorch v1.4 - torchvision v0.5.0</li>
<li>PyTorch v1.5 - torchvision v0.6.0</li>
<li>PyTorch v1.6 - torchvision v0.7.0</li>
<li>PyTorch v1.7 - torchvision v0.8.1</li>
</ul>
<h4 id="cuda">CUDA</h4>
<p>官网最新镜像文件自带cuda 版本为10.2，OpenCV4</p>
<p>将以下命令写入<code>~/.bashrc</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> CUDA_HOME=/usr/local/cuda-10.2</span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/usr/local/cuda-10.2/lib64:<span class="variable">$LD_LIBRARY_PATH</span></span><br><span class="line"><span class="built_in">export</span> PATH=/usr/local/cuda-10.2/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure>
<p>退出后保存</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>
<p>检查</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nvcc -V</span><br></pre></td></tr></table></figure>
<p>返回的文字如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nvcc: NVIDIA (R) Cuda compiler driver</span><br><span class="line">Copyright (c) 2005-2019 NVIDIA Corporation</span><br><span class="line">Built on Wed_Oct_23_21:14:42_PDT_2019</span><br><span class="line">Cuda compilation tools, release 10.2, V10.2.89</span><br></pre></td></tr></table></figure>
<h5 id="安装ros仓库">安装ROS仓库</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo sh -c <span class="string">&#x27;. /etc/lsb-release &amp;&amp; echo &quot;deb http://mirrors.bfsu.edu.cn/ros/ubuntu/ `lsb_release -cs` main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#x27;</span></span><br></pre></td></tr></table></figure>
<h5 id="添加ros密钥">添加ROS密钥</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-key adv --keyserver &#x27;hkp://keyserver.ubuntu.com:80&#x27; --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654</span><br></pre></td></tr></table></figure>
<h5 id="启用额外的软件库">启用额外的软件库</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-add-repository universe</span><br><span class="line">sudo apt-add-repository multiverse</span><br><span class="line">sudo apt-add-repository restricted</span><br></pre></td></tr></table></figure>
<h5 id="添加ros">添加ROS</h5>
<h4 id="opencv">OpenCV</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pkg-config opencv4 --modversion</span><br></pre></td></tr></table></figure>
<p>返回的文字如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4.1.1</span><br></pre></td></tr></table></figure>
<h5 id="安装cuda-opencv">安装CUDA OpenCV</h5>
<h6 id="移除原有opencv">移除原有OpenCV</h6>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">sudo apt-<span class="keyword">get</span> purge libopencv*</span><br><span class="line">sudo apt autoremove                  <span class="meta">#此步不建议运行, 有可能产生奇怪的依赖问题</span></span><br><span class="line">sudo apt-<span class="keyword">get</span> update</span><br></pre></td></tr></table></figure>
<h6 id="安装依赖">安装依赖</h6>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 安装必备库，cmake,git,g++</span><br><span class="line">sudo apt-get install -y build-essential checkinstall cmake pkg-config yasm git gfortran</span><br><span class="line">sudo apt-get install -y libgstreamer1.0-dev libgstreamer-plugins-base1.0-dev</span><br><span class="line">sudo apt-get install -y libjpeg8-dev libjasper-dev libpng12-dev libtiff5-dev libavcodec-dev libavformat-dev libswscale-dev libdc1394-22-dev libxine2-dev libv4l-dev</span><br><span class="line">sudo apt-get install -y libgstreamer1.0-dev libgstreamer-plugins-base1.0-dev libgtk2.0-dev libtbb-dev libatlas-base-dev libfaac-dev libmp3lame-dev libtheora-dev libvorbis-dev libxvidcore-dev libopencore-amrnb-dev libopencore-amrwb-dev x264 v4l-utils</span><br><span class="line"># 处理图像所需的包</span><br><span class="line">sudo apt-get install libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev libjasper-dev libdc1394-22-dev </span><br><span class="line"># 处理视频所需的包</span><br><span class="line">sudo apt-get install libxvidcore-dev libx264-dev ffmpeg</span><br><span class="line"># opencv功能优化</span><br><span class="line">sudo apt-get install libatlas-base-dev gfortran </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="下载opencv源代码">下载OpenCV源代码</h6>
<p>下载地址：https://opencv.org/releases/</p>
<p>此次编译使用的是<code>opencv-4.4.0.zip</code>版本。</p>
<p>额外的库：https://github.com/opencv/opencv_contrib</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">unzip opencv-4.4.0.zip</span><br><span class="line"><span class="built_in">cd</span> opencv-4.4.0</span><br><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br></pre></td></tr></table></figure>
<p>执行CMAKE</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">cmake \</span><br><span class="line">-DCMAKE_BUILD_TYPE=Release \</span><br><span class="line">-DCMAKE_INSTALL_PREFIX=/usr/local \</span><br><span class="line">-DOPENCV_ENABLE_NONFREE=1 \</span><br><span class="line">-DBUILD_opencv_python2=1 \</span><br><span class="line">-DBUILD_opencv_python3=1 \</span><br><span class="line">-DWITH_FFMPEG=1 \</span><br><span class="line">-DCUDA_TOOLKIT_ROOT_DIR=/usr/local/cuda-10.2 \</span><br><span class="line">-DCUDA_ARCH_BIN=7.2 \</span><br><span class="line">-DCUDA_ARCH_PTX=7.2 \</span><br><span class="line">-DWITH_CUDA=1 \</span><br><span class="line">-DENABLE_FAST_MATH=1 \</span><br><span class="line">-DCUDA_FAST_MATH=1 \</span><br><span class="line">-DWITH_CUBLAS=1 \</span><br><span class="line">-DOPENCV_GENERATE_PKGCONFIG=1 \</span><br><span class="line">-DOPENCV_EXTRA_MODULES_PATH=../opencv_contrib-4.4.0/modules \</span><br><span class="line">..</span><br></pre></td></tr></table></figure>
<p>注意<strong>：opencv_contrib-4.4.0是放在opencv-4.4.0中，注意文件的路径！！！</strong></p>
<p><strong>使用cuda，-DWITH_CUDA=1.</strong></p>
<p>官方文档的cmake的配置情况：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">cmake \</span><br><span class="line">-<span class="variable constant_">DCMAKE_BUILD_TYPE</span>=<span class="title class_">Release</span> \</span><br><span class="line">-<span class="variable constant_">DCMAKE_INSTALL_PREFIX</span>=<span class="regexp">/usr \</span></span><br><span class="line"><span class="regexp">-DBUILD_PNG=OFF \</span></span><br><span class="line"><span class="regexp">-DBUILD_TIFF=OFF \</span></span><br><span class="line"><span class="regexp">-DBUILD_TBB=OFF \</span></span><br><span class="line"><span class="regexp">-DBUILD_JPEG=OFF \</span></span><br><span class="line"><span class="regexp">-DBUILD_JASPER=OFF \</span></span><br><span class="line"><span class="regexp">-DBUILD_ZLIB=OFF \</span></span><br><span class="line"><span class="regexp">-DBUILD_EXAMPLES=ON \</span></span><br><span class="line"><span class="regexp">-DBUILD_JAVA=OFF \</span></span><br><span class="line"><span class="regexp">-DBUILD_opencv_python2=ON \</span></span><br><span class="line"><span class="regexp">-DBUILD_opencv_python3=OFF \</span></span><br><span class="line"><span class="regexp">-DENABLE_NEON=ON \</span></span><br><span class="line"><span class="regexp">-DWITH_OPENCL=OFF \</span></span><br><span class="line"><span class="regexp">-DWITH_OPENMP=OFF \</span></span><br><span class="line"><span class="regexp">-DWITH_FFMPEG=ON \</span></span><br><span class="line"><span class="regexp">-DWITH_GSTREAMER=OFF \</span></span><br><span class="line"><span class="regexp">-DWITH_GSTREAMER_0_10=OFF \</span></span><br><span class="line"><span class="regexp">-DWITH_CUDA=ON \</span></span><br><span class="line"><span class="regexp">-DWITH_GTK=ON \</span></span><br><span class="line"><span class="regexp">-DWITH_VTK=OFF \</span></span><br><span class="line"><span class="regexp">-DWITH_TBB=ON \</span></span><br><span class="line"><span class="regexp">-DWITH_1394=OFF \</span></span><br><span class="line"><span class="regexp">-DWITH_OPENEXR=OFF \</span></span><br><span class="line"><span class="regexp">-DCUDA_TOOLKIT_ROOT_DIR=/usr</span><span class="regexp">/local/cuda</span>-<span class="number">8.0</span> \</span><br><span class="line">-<span class="variable constant_">DCUDA_ARCH_BIN</span>=<span class="number">6.2</span> \</span><br><span class="line">-<span class="variable constant_">DCUDA_ARCH_PTX</span>=<span class="string">&quot;&quot;</span> \</span><br><span class="line">-<span class="variable constant_">DINSTALL_C_EXAMPLES</span>=<span class="variable constant_">ON</span> \</span><br><span class="line">-<span class="variable constant_">DINSTALL_TESTS</span>=<span class="variable constant_">OFF</span> \</span><br><span class="line">-<span class="variable constant_">DOPENCV_TEST_DATA_PATH</span>=../opencv_extra/testdata \</span><br><span class="line">../opencv</span><br></pre></td></tr></table></figure>
<p>注意：<strong>请根据自己的的CUDA版本和实际路径修改参数！</strong></p>
<p>参考链接：<a
href="https://docs.opencv.org/4.4.0/d6/d15/tutorial_building_tegra_cuda.html#tutorial_building_tegra_cuda_installing">OpenCV:
Building OpenCV for Tegra with CUDA</a></p>
<h6 id="编译">编译</h6>
<p>执行以下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make -j1</span><br></pre></td></tr></table></figure>
<p>其中1指的线程，初次编译建议使用单线程,，解决一些奇怪问题。</p>
<h6 id="安装">安装</h6>
<p>执行以下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<h6 id="成功啦">成功啦</h6>
<h6 id="解决各种出错问题">解决各种出错问题</h6>
<ol type="1">
<li><strong>src/grfmt_jpeg2000.cpp.o failed</strong></li>
</ol>
<p>编译时关闭如下tag：<strong>-DBUILD_JASPER=OFF</strong> 即可.</p>
<ol start="2" type="1">
<li><p><strong>fatal error: boostdesc_bgm.i: No such file or
directory</strong></p>
<p>可参考：https://github.com/AastaNV/JEP/issues/20</p>
<p>https://github.com/opencv/opencv_contrib/issues/1301#issuecomment-618262386</p></li>
</ol>
<p>将下载好的文件解压到以下文件夹：</p>
<h4 id="cudnn">cuDNN</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/src/cudnn_samples_v8/mnistCUDNN</span><br><span class="line">sudo make</span><br><span class="line">sudo <span class="built_in">chmod</span> a+x mnistCUDNN</span><br><span class="line">./mnistCUDNN</span><br></pre></td></tr></table></figure>
<h4 id="更改桌面">更改桌面</h4>
<p>默认的桌面环境是Unity，此次更改成更轻量的<code>ubuntu-mate</code>.</p>
<p>注意：安装过程中请勿卸载现有的桌面登录管理器，以免出现无法登录进系统的尴尬。</p>
<p>安装更轻量的桌面登录管理器<strong>LightDM</strong>：LightDM是2010年开始的新项目，且被设计为轻量、小巧、快速。相较于GDM-GTK、KDM-Qt、LightDM实际上与界面无关，它仅支持本地图形界面获得最好兼容性。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install lightdm</span><br></pre></td></tr></table></figure>
<p>安装<code>ubuntu-mate-destop</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install ubuntu-mate-core ubuntu-mate-desktop</span><br></pre></td></tr></table></figure>
<h5 id="lightdm设置自动登录">lightdm设置自动登录</h5>
<p>设置<strong>autologin-user</strong>来设置系统启动时自动登录某个帐户。设置<strong>autologin-user-timeout</strong>限制用户在设定秒内如果没有自动登录则不能自动登录。</p>
<p>编辑以下文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/lightdm/lightdm.conf </span><br></pre></td></tr></table></figure>
<p>设置<strong>autologin-user</strong>来设置系统启动时自动登录某个帐户。设置<strong>autologin-user-timeout</strong>限制用户在设定秒内如果没有自动登录则不能自动登录。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[SeatDefaults]</span><br><span class="line">autologin-user=username</span><br><span class="line">autologin-user-timeout=delay</span><br></pre></td></tr></table></figure>
<h5 id="lightdm修改默认会话"><strong>lightdm修改默认会话</strong></h5>
<p>默认会话设置保存在<strong>/usr/share/lightdm/lightdm.conf.d</strong>会话包中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[SeatDefaults]</span><br><span class="line">user-session=name</span><br></pre></td></tr></table></figure>
<p>其中name代表<strong>/usr/share/xsessions/*.desktop</strong>中<name>.desktop。</p>
<p>转载自：https://www.cnblogs.com/EasonJim/p/7128317.html</p>
<h4 id="sudo无需输入密码">sudo无需输入密码</h4>
<p>切换到<code>root</code>用户，输入以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">visudo</span><br></pre></td></tr></table></figure>
<p>在最后一行输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;用户名&gt; ALL=(ALL) NOPASSWD: ALL </span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS基础（二）｜创建工作空间并编译ROS功能包</title>
    <url>/p/ROS-system-learning-notes-02/</url>
    <content><![CDATA[<p><strong>关键词：</strong>ROS</p>
<span id="more"></span>
<h3 id="ros使用练习">ROS使用练习</h3>
<h4 id="ros文件系统">ROS文件系统</h4>
<p>我们通过命令行工具来浏览ROS的文件系统。</p>
<p>为了获得功能包和功能包集的信息,比如,其路径、依赖关系等，我们将使用<strong>rospack</strong>、<strong>rosstack</strong>命令进入功能包和功能包集，并列出其中
的内容。</p>
<p>例如，如果你想要找<strong>turtlesim</strong>包的路径，可以使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rospack find turtlesim </span><br></pre></td></tr></table></figure>
<p>你将要获得以下信息：</p>
<p><img data-src="image-20201019194410801.png" /></p>
<p>如果你想要找到已经在系统安装过的某个<strong>元功能包</strong>，示例如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rospack find ros_comm</span><br></pre></td></tr></table></figure>
<p>你将获得ros-comm元功能包的路径：<img data-src="image-20201019194825060.png" /></p>
<p><em>注意：功能包是rospack ，元功能包是rosstack，要注意区分。</em></p>
<p>要获得功能包或者功能包集下面的文件列表，需要使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosls turtlesim</span><br></pre></td></tr></table></figure>
<p><img data-src="image-20201019195209283.png" /></p>
<p>更改当前目录，尤其是进入某个文件夹，可以使用roscd命令完成：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">roscd turtlesim</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">pwd</span></span><br></pre></td></tr></table></figure>
<p>将获得以下新路径：</p>
<p><img data-src="image-20201019195406492.png" /></p>
<h4 id="创建工作空间">创建工作空间</h4>
<p>我们会在工作空间完成本书使用的所有代码。</p>
<p>要查看ROS正在使用的工作空间，请使用下面的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$ROS_PACKAGE_PATH</span></span><br></pre></td></tr></table></figure>
<p>会看到如下类似信息：<img data-src="image-20201019195658744.png" /></p>
<p>我们将要创建的文件夹位于<code>/root/dev/catkin_ws/src</code>中。要新建文件夹，使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /root/dev/catkin_ws/src</span><br><span class="line"><span class="built_in">cd</span> /root/dev/catkin_ws/src</span><br><span class="line">catkin_init_workspace</span><br></pre></td></tr></table></figure>
<p>当创建工作空间文件夹后，里面并没有功能包，只有CMakeList.txt文件。使用下面的命令来<strong>编译工作空间</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /root/dev/catkin_ws</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure>
<p>你将看到类似信息：<img data-src="image-20201019200504031.png" /></p>
<p>现在输入<code>ls</code>命令，可以看到创建的新文件夹，分别是build和devel文件夹。</p>
<p>输入以下命令，再次初始化ros环境，至此，工作空间创建完毕。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> devel/setup.bash</span><br></pre></td></tr></table></figure>
<p>这一步只重新加载了setup.bash文件，如果关闭并打开一个新的命令行窗口，也将得到同样的效果。</p>
<p>输入以下命令，将ROS的初始化脚本加入到bash的配置文件中，这样，每次打开一个新的bash
shell窗口时，就自动完成了ROS的初始化。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;source /opt/ros/kinetic/setup.bash&quot;</span> &gt;&gt; ~/.bashrc</span><br></pre></td></tr></table></figure>
<h4 id="创建ros功能包和元功能包">创建ROS功能包和元功能包</h4>
<p>使用以下命令在之前建立的工作空间中创建新的功能包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /root/dev/catkin_ws/src</span><br><span class="line">catkin_create_pkg TEST std_msgs roscpp</span><br></pre></td></tr></table></figure>
<p>此命令的格式包括包的名称和依赖项。在这个示例中，依赖项包括
<strong>std_msgs</strong> 和 <strong>roscpp</strong>.</p>
<p>如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">catkin_create_pkg name [dependencies [dependencies ...]]</span><br><span class="line">positional arguments:</span><br><span class="line">  name                  The name for the package</span><br><span class="line">  dependencies          Catkin package Dependencies</span><br></pre></td></tr></table></figure>
<p>这些依赖项主要包括以下几个：</p>
<ul>
<li>std_msgs：包含了常见的消息类型，表示基本数据类型和其他基本的消息构造，如多维数组。</li>
<li>roscpp：使用C++实现了ROS的各种功能。它提供了一个客户端库，让C++程序员能够调用这些接口快速完成与ROS的主题、服务和参数相关的开发工作。</li>
</ul>
<p>如果所有步骤一切顺利，结果如下图所示：</p>
<p><img data-src="image-20201019202650647.png" /></p>
<p>正如我们看到的，可以使用rospack、roscd和rosls命令来获取新的功能包信息。下面是可以执行的一些操作。</p>
<ul>
<li>rospack
profile：此命令用于通知用户ROS中新添加的内容。在安装任何功能包之后使用它。</li>
<li>rospack find TEST：此命令用于查看依赖关系。</li>
<li>rosls TEST：此命令用于查看内容</li>
<li>roscd TEST：此命令会切换到TEST功能包所在的路径。</li>
</ul>
<h4 id="编译ros功能包">编译ROS功能包</h4>
<p>编译功能包的的时候，主要是代码的编译过程，不仅包括用户添加的代码，还包括由消息和服务生成的代码。</p>
<p>为了编译功能包，可以使用<code>catin_make</code>工具：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /root/dev/catkin_ws/</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure>
<p>如果没有看到错误提示信息，说明功能包编译成功。</p>
<p>必须在<code>workspace</code>文件夹中运行catkin_make命令。如果在其他文件这样做，命令将无法执行！</p>
<p>当你在TEST文件夹中试图使用catkin_make编译工具包时，你会看到如下错误：</p>
<p><img data-src="image-20201019204443411.png" /></p>
<p>当你在<code>catkin_ws</code>文件夹中执行catkin_make命令时，则会编译成功。</p>
<p>如果编译单个工具包，可以使用如下格式的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">catkin_make --pkg &lt;package name&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title>Jupyter NoteBook的快捷键使用指南</title>
    <url>/p/jupyter-notebook-keyboard-shortcut/</url>
    <content><![CDATA[<p><strong>概述：</strong>Jupyter
Notebook是基于网页的用于交互计算的应用程序。其可被应用于全过程计算：开发、文档编写、运行代码和展示结果。</p>
<p>此文简单介绍了 Jupyter Notebook 的快捷键用法。</p>
<p><strong>关键词：</strong>Jupyter Notebook</p>
<span id="more"></span>
<p><strong>Jupyter Notebook</strong>
有两种键盘输入模式。即命令模式和编辑模式，这与 <a
href="http://www.vim.org/">Vim</a> 有些类似。</p>
<p>在<strong>编辑模式</strong>下，可以往单元中键入代码或文本，<u>此时单元格被绿色的框线包围，且命令模式下的快捷键不生效。</u></p>
<p>在<strong>命令模式</strong>下，可以用快捷键命令运行单元格，移动单元格，切换单元格编辑状态等等，<u>此时的单元格被灰色的框线包围，且编辑模式下的快捷键不生效。</u></p>
<p>从命令模式进入编辑模式需按 <code>Enter</code>
键，从编辑模式切换到命令模式需按 <code>Esc</code> 键。</p>
<p>以下两表分别是对命令和编辑两种模式下快捷键的简单说明：</p>
<h3 id="命令模式">命令模式</h3>
<p><strong>快捷键（按 Esc 键开启）:</strong></p>
<table>
<colgroup>
<col style="width: 24%" />
<col style="width: 23%" />
<col style="width: 51%" />
</colgroup>
<thead>
<tr class="header">
<th>快捷键</th>
<th style="text-align: center;">作用</th>
<th style="text-align: center;">说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Enter</strong></td>
<td style="text-align: center;">转入编辑模式</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><strong>Shift-Enter</strong></td>
<td style="text-align: center;">运行本单元，选中下个单元</td>
<td style="text-align: center;">新单元默认为命令模式</td>
</tr>
<tr class="odd">
<td><strong>Ctrl-Enter</strong></td>
<td style="text-align: center;">运行本单元</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><strong>Alt-Enter</strong></td>
<td style="text-align: center;">运行本单元，在其下插入新单元</td>
<td style="text-align: center;">新单元默认为编辑模式</td>
</tr>
<tr class="odd">
<td><strong>Y</strong></td>
<td style="text-align: center;">单元转入代码状态</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><strong>M</strong></td>
<td style="text-align: center;">单元转入 <strong>markdown</strong>
状态</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><strong>R</strong></td>
<td style="text-align: center;">单元转入 raw 状态</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><strong>1</strong></td>
<td style="text-align: center;">设定 1 级标题</td>
<td style="text-align: center;">仅在 markdown
状态下时建议使用标题相关快捷键，如果单元处于其他状态，则会强制切换到
markdown 状态</td>
</tr>
<tr class="odd">
<td><strong>2</strong></td>
<td style="text-align: center;">设定 2 级标题</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><strong>3</strong></td>
<td style="text-align: center;">设定 3 级标题</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><strong>4</strong></td>
<td style="text-align: center;">设定 4 级标题</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><strong>5</strong></td>
<td style="text-align: center;">设定 5 级标题</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><strong>6</strong></td>
<td style="text-align: center;">设定 6 级标题</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><strong>Up</strong></td>
<td style="text-align: center;">选中上方单元</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><strong>K</strong></td>
<td style="text-align: center;">选中上方单元</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><strong>Down</strong></td>
<td style="text-align: center;">选中下方单元</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><strong>J</strong></td>
<td style="text-align: center;">选中下方单元</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><strong>Shift-K</strong></td>
<td style="text-align: center;">连续选择上方单元</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><strong>Shift-J</strong></td>
<td style="text-align: center;">连续选择下方单元</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><strong>A</strong></td>
<td style="text-align: center;">在上方插入新单元</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><strong>B</strong></td>
<td style="text-align: center;">在下方插入新单元</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><strong>X</strong></td>
<td style="text-align: center;">剪切选中的单元</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><strong>C</strong></td>
<td style="text-align: center;">复制选中的单元</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><strong>Shift-V</strong></td>
<td style="text-align: center;">粘贴到上方单元</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><strong>V</strong></td>
<td style="text-align: center;">粘贴到下方单元</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><strong>Z</strong></td>
<td style="text-align: center;">恢复删除的最后一个单元</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><strong>D,D</strong></td>
<td style="text-align: center;">删除选中的单元</td>
<td style="text-align: center;">连续按两个 D 键</td>
</tr>
<tr class="even">
<td><strong>Shift-M</strong></td>
<td style="text-align: center;">合并选中的单元</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><strong>Ctrl-S</strong></td>
<td style="text-align: center;">保存当前 NoteBook</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><strong>S</strong></td>
<td style="text-align: center;">保存当前 NoteBook</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><strong>L</strong></td>
<td style="text-align: center;">开关行号</td>
<td style="text-align: center;">编辑框的行号是可以开启和关闭的</td>
</tr>
<tr class="even">
<td><strong>O</strong></td>
<td style="text-align: center;">转换输出</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><strong>Shift-O</strong></td>
<td style="text-align: center;">转换输出滚动</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><strong>Esc</strong></td>
<td style="text-align: center;">关闭页面</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><strong>Q</strong></td>
<td style="text-align: center;">关闭页面</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><strong>H</strong></td>
<td style="text-align: center;">显示快捷键帮助</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><strong>I,I</strong></td>
<td style="text-align: center;">中断 NoteBook 内核</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><strong>0,0</strong></td>
<td style="text-align: center;">重启 NoteBook 内核</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><strong>Shift</strong></td>
<td style="text-align: center;">忽略</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><strong>Shift-Space </strong></td>
<td style="text-align: center;">向上滚动</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><strong>Space</strong></td>
<td style="text-align: center;">向下滚动</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<h3 id="编辑模式">编辑模式</h3>
<p><strong>快捷键（ 按 Enter 键启动）:</strong></p>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 25%" />
<col style="width: 54%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">快捷键</th>
<th style="text-align: left;">作用</th>
<th style="text-align: left;">说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>Tab</strong></td>
<td style="text-align: left;">代码补全或缩进</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Shift-Tab</strong></td>
<td style="text-align: left;">提示</td>
<td
style="text-align: left;">输出帮助信息，部分函数、类、方法等会显示其定义原型，如果在其后加
<code>?</code> 再运行会显示更加详细的帮助</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Ctrl-]</strong></td>
<td style="text-align: left;">缩进</td>
<td style="text-align: left;">向右缩进</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Ctrl-[</strong></td>
<td style="text-align: left;">解除缩进</td>
<td style="text-align: left;">向左缩进</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Ctrl-A</strong></td>
<td style="text-align: left;">全选</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Ctrl-Z</strong></td>
<td style="text-align: left;">撤销</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Ctrl-Shift-Z</strong></td>
<td style="text-align: left;">重做</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Ctrl-Y</strong></td>
<td style="text-align: left;">重做</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Ctrl-Home</strong></td>
<td style="text-align: left;">跳到单元开头</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Ctrl-Up</strong></td>
<td style="text-align: left;">跳到单元开头</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Ctrl-End</strong></td>
<td style="text-align: left;">跳到单元末尾</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Ctrl-Down</strong></td>
<td style="text-align: left;">跳到单元末尾</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Ctrl-Left</strong></td>
<td style="text-align: left;">跳到左边一个字首</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Ctrl-Right</strong></td>
<td style="text-align: left;">跳到右边一个字首</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Ctrl-Backspace</strong></td>
<td style="text-align: left;">删除前面一个字</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Ctrl-Delete</strong></td>
<td style="text-align: left;">删除后面一个字</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Esc</strong></td>
<td style="text-align: left;">切换到命令模式</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Ctrl-M</strong></td>
<td style="text-align: left;">切换到命令模式</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Shift-Enter</strong></td>
<td style="text-align: left;">运行本单元，选中下一单元</td>
<td style="text-align: left;">新单元默认为命令模式</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Ctrl-Enter</strong></td>
<td style="text-align: left;">运行本单元</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Alt-Enter</strong></td>
<td style="text-align: left;">运行本单元，在下面插入一单元</td>
<td style="text-align: left;">新单元默认为编辑模式</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Ctrl-Shift--</strong></td>
<td style="text-align: left;">分割单元</td>
<td style="text-align: left;">按光标所在行进行分割</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Ctrl-Shift-Subtract</strong></td>
<td style="text-align: left;">分割单元</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Ctrl-S</strong></td>
<td style="text-align: left;">保存当前 NoteBook</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Shift</strong></td>
<td style="text-align: left;">忽略</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Up</strong></td>
<td style="text-align: left;">光标上移或转入上一单元</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Down</strong></td>
<td style="text-align: left;">光标下移或转入下一单元</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Ctrl-/</strong></td>
<td style="text-align: left;">注释整行/撤销注释</td>
<td style="text-align: left;">仅代码状态有效</td>
</tr>
</tbody>
</table>
<p><strong>注：</strong>
如果快捷键被系统中的其它应用占用，则可能会失效</p>
]]></content>
      <tags>
        <tag>Jupyter</tag>
      </tags>
  </entry>
  <entry>
    <title>数值分析第一章作业</title>
    <url>/p/Chapter-01-of-Numerical-Analysis/</url>
    <content><![CDATA[<p><strong>摘要：</strong>此系列文章是我从2020年9月21日开始在浙江理工大学读研一时《数值分析》课后作业练习题及答案。</p>
<p><strong>关键词：</strong>研一，数值分析</p>
<span id="more"></span>
<p><img data-src="image-20201013093358782.png" /></p>
<p><img data-src="image-20201013102937713.png" /></p>
<p><img data-src="image-20201013104909315.png" /></p>
<p><img data-src="image-20201013104922645.png" /></p>
<p><img data-src="image-20201013104953613.png" /></p>
<p><img data-src="image-20201013110136891.png" /></p>
<p><img data-src="image-20201013110806596.png" /> <span
class="math display">\[
2^{256}=2^{16} \times 2^{16}=[(2^{4})^{2}]^{2}
\]</span></p>
]]></content>
      <tags>
        <tag>研一</tag>
        <tag>现代信号分析</tag>
      </tags>
  </entry>
  <entry>
    <title>现代信号分析第四章作业</title>
    <url>/p/Chapter-02-of-Modern-Signal-Analysis/</url>
    <content><![CDATA[<p><strong>摘要：</strong>此系列文章是我从2020年9月21日开始在浙江理工大学读研一时《现代信号分析》课后作业练习题及答案。</p>
<p><strong>关键词：</strong>研一，现代信号分析</p>
<span id="more"></span>
<p><img data-src="image-20201012134854422.png" /></p>
<p><img data-src="image-20201012135051489-16370605554431.png" /></p>
<p><img data-src="image-20201012135105822.png" /></p>
<p><img data-src="image-20201012135149144.png" /></p>
<p><img data-src="image-20201012140126858.png" /></p>
<p><img data-src="image-20201012140338034.png" /></p>
<p><img data-src="image-20201012141112290.png" /></p>
]]></content>
      <tags>
        <tag>研一</tag>
        <tag>现代信号分析</tag>
      </tags>
  </entry>
  <entry>
    <title>现代信号分析第二章作业</title>
    <url>/p/Chapter-01-of-Modern-Signal-Analysis/</url>
    <content><![CDATA[<p><strong>摘要：</strong>此系列文章是我从2020年9月21日开始在浙江理工大学读研一时《现代信号分析》课后作业练习题及答案。</p>
<p><strong>关键词：</strong>研一，现代信号分析</p>
<span id="more"></span>
<p><img data-src="image-20200928193703316.png" /></p>
<p><img data-src="image-20201011203228683.png" /></p>
<p><img data-src="image-20201011203330808.png" /></p>
<p><img data-src="image-20200928193714036.png" /></p>
<p><img data-src="image-20201011203626045.png" /></p>
<p><img data-src="image-20201011203639917.png" /></p>
<p><img data-src="image-20201011203658032.png" /></p>
<p><img data-src="image-20201011203716172.png" /></p>
<p><img data-src="image-20201011203748238.png" /></p>
<p><img data-src="image-20201011203823320.png" /></p>
<p><img data-src="image-20201011203917101.png" /></p>
<p><img data-src="image-20201011203848593.png" /></p>
<p><img data-src="image-20200928193737091.png" /></p>
<p><img data-src="image-20201011204004991.png" /></p>
<p><img data-src="image-20201011204054961.png" /></p>
<p><img data-src="image-20201011204157647.png" /></p>
<p><img data-src="image-20200928193754540.png" /></p>
<p><img data-src="image-20201011204330872.png" /></p>
<p><img data-src="image-20201011204359072.png" /></p>
<p><img data-src="image-20201011204438075.png" /></p>
]]></content>
      <tags>
        <tag>研一</tag>
        <tag>现代信号分析</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS基础（一）｜ROS架构及概念</title>
    <url>/p/ROS-system-learning-notes-01/</url>
    <content><![CDATA[<p><strong>关键词：</strong>ROS</p>
<span id="more"></span>
<h3 id="ros架构及概念">ROS架构及概念</h3>
<p>ROS的架构经过设计并划分为三部分，每一部分都代表一个层级的概念：</p>
<ul>
<li>文件系统级（Filesystem level)</li>
<li>计算图级(Computation Graph level)</li>
<li>社区级(Community level)</li>
</ul>
<p>第一级是文件系统级。在这一级，我们会使用一组概念来解释ROS的内部构成、文件夹结构，以及工作所需要的核心文件。</p>
<p>第二级是计算图级，体现的是进程和系统之间的通信。在相关小节中，我们将学习ROS的各个概念和功能，包括建立系统、处理各类进程、与多台机器通信等。</p>
<p>第三级是社区级，我们将解释一系列的工具和概念，包括在开发人员之间如何共享知识、算法和代码。由于强大社区的支持，不仅提高了初学者理解复杂软件的能力，还解决了最常见的问题。</p>
<h4 id="理解ros文件系统级">理解ROS文件系统级</h4>
<p><img data-src="image-20200923190637341.png" /></p>
<p>与其他操作系统类似，一个ROS程序的不同组件要放在不同的文件夹下，这些文件夹是根据功能的不同来对文件进行组织的。</p>
<ol type="1">
<li>功能包（Package）：功能包构成ROS中的原子级。一个功能包具有创建ROS程序最小结构和最少内容。它可以包含ROS运行时进程（节点）、配置文件等。</li>
<li>功能包清单（Package
Manifest）：功能包清单提供关于功能包、许可证、依赖关系、编译标志等的信息。包清单又一个名为<strong>package.xml</strong>的文件管理。</li>
<li>元功能包（Metapackage）：如果你希望将几个具有<strong>某些功能的包组织在一起</strong>，那么你将使用一个元功能包。这种包的组织形式<strong>之前被称</strong>为功能包集（Stack
）。功能包集被废除，现在使用元功能包实现这个功能。在ROS中，存在大量不同用途的元功能包，例如<strong>导航功能包集</strong>。</li>
<li>元功能包清单（Metapackage
manifest）：元功能包清单（package.xml）类似普通功能包但又一个XML格式的导出标记，他在结构上也有一定的限制。</li>
<li>消息类型（Message（msg）type）：消息是一个进程发送到其他进程的消息。ROS
的消息类型的说明存储在<strong>my_package/msg/MyMessageType.msg</strong>中。</li>
<li>服务类型（Service (srv)
Type）：服务描述说明存储在<strong>my_package/srv/MyServiceType.srv</strong>中，为ROS中由每个进程提供的服务定义请求和响应数据结构。</li>
</ol>
<p>下面的截图说明了<strong>turtlesim</strong>功能包的内容。所看到的是一系列文件和文件夹，包含代码、图片、启动文件服务和消息。以下只是文件的一个简短列表。</p>
<p><img data-src="image-20200923193232140.png" /></p>
<h5 id="工作空间">工作空间</h5>
<p>工作空间包含功能包，功能包包含源文件和环境和工作空间，是集中开发的一种好方式。</p>
<p>下图所示是一个典型的工作空间。<img data-src="image-20200924144159317.png" /></p>
<p>主要包含一下内容：</p>
<ul>
<li>源文件空间（Source
space）：在源空间（src文件夹）中，放置了功能包、项目、复制的包等。<strong>最重要文件：CMakeLists.txt</strong>。当在工作空间配置包时，通过cmake调用CMakeLists.txt。这个文件是通过<strong>catkin_init_workspace</strong>命令创建的。</li>
<li>编译空间（build
space）：在build文件夹里，cmake和catkin为功能包和项目保存缓存信息、配置和其他中间文件。</li>
<li>开发空间（Development
（devel）space）：devel文件夹用来保存编译后的程序，这些是无需安装就能用来测试的程序。</li>
</ul>
<p>用catkin编译包有两个选项。第一个是使用标准CMake工作流程。通过使用此方式。可以一次编译一个包，见以下命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cmake packageToBuild/</span><br><span class="line">make</span><br></pre></td></tr></table></figure>
<p>如果想编译所有的包，可以用<strong>catkin_make</strong>命令行，见以下命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> workspace</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure>
<p>在ROS配置的编译空间目录中，这两个命令编译出可执行文件。</p>
<p>ROS支持覆盖（overlay）。当你正在使用ROS功能包例如（<strong>Turtlesim</strong>）时，可以使用安装版本，也可以下载源文件并编译它来使用你修改后的版本。</p>
<p>ROS允许使用自己版本的功能包去替代安装版本。下一章我们将使用这个功能来创建自己的插件。</p>
<h5 id="功能包">功能包</h5>
<p>包指的是一种特定结构的文件和文件夹组合。</p>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 75%" />
</colgroup>
<thead>
<tr class="header">
<th>目录</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>include/package_name</td>
<td>此目录包含了需要的库的头文件</td>
</tr>
<tr class="even">
<td>msg/</td>
<td>如果开发需要<strong>非标准</strong>的消息，请把文件放在这里。</td>
</tr>
<tr class="odd">
<td>script/</td>
<td>其中包含Bash、Python或者任何其他脚本语言的可执行脚本。</td>
</tr>
<tr class="even">
<td>src/</td>
<td>存储程序源文件。可以为节点创建一个文件夹或按照希望的方式组织它。</td>
</tr>
<tr class="odd">
<td>srv/</td>
<td>（srv）服务类型</td>
</tr>
<tr class="even">
<td>CMakeLists.txt</td>
<td>CMake的生成文件</td>
</tr>
<tr class="odd">
<td>package.xml</td>
<td>功能包清单文件</td>
</tr>
</tbody>
</table>
<p>ROS提供的工具（命令）</p>
<table>
<thead>
<tr class="header">
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>rospack</td>
<td>使用此命令来获取信息或在系统中查找包</td>
</tr>
<tr class="even">
<td>catkin_create_pkg</td>
<td>使用此命令创建一个新的功能包</td>
</tr>
<tr class="odd">
<td>catin_make</td>
<td>使用此命令来编译工作空间</td>
</tr>
<tr class="even">
<td>rosdep</td>
<td>使用此命令按照功能包的系统依赖项</td>
</tr>
<tr class="odd">
<td>rqt_dep</td>
<td>使用此命令来查看包的依赖关系图</td>
</tr>
</tbody>
</table>
<p>如果要在文件夹和功能包之间移动文件，ROS提供了非常有用的<strong>rosbash</strong>，功能包，其中包含的非常类似Linux命令的命令。</p>
<table>
<thead>
<tr class="header">
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>roscd</td>
<td>此命令用于更改目录，相当于Linux中的cd命令</td>
</tr>
<tr class="even">
<td>rosed</td>
<td>此命令用来编辑文件</td>
</tr>
<tr class="odd">
<td>roscp</td>
<td>此命令用于从功能包复制文件。</td>
</tr>
<tr class="even">
<td>rosls</td>
<td>此命令列出功能包下的文件，类似Linux中的ls命令。</td>
</tr>
</tbody>
</table>
<p>文件<strong>package.xml</strong>必须在每个功能包中，它用来说明此包相关的各类信息。如果你发现在某个文件夹内包含此文件，那么这个文件夹很可能是<strong>一个包或者元功能包</strong>。</p>
<p>打开<strong>package.xml</strong>文件，可以看到包的名称、依赖关系等信息。功能包清单的作用就是为了方便安装和分发这些功能包。</p>
<p>在<strong>package.xml</strong>文件中使用的两个典型标记是<strong><build_depend></strong>和<strong><run_depend></strong>.</p>
<p><strong><build_depend></strong>标记会显示当前功能包安装之前必须先安装哪些功能包。这是因为新的功能包会使用其他包的一些功能。</p>
<p><strong><run_depend></strong>标记显示运行功能包中代码所需要的包。以下是package.xml文件的示例。</p>
<p><img data-src="image-20200924154802735.png" /></p>
<h5 id="元功能包">元功能包</h5>
<p>元包中只有一个文件，这个文件就是<strong>package.xml</strong>。它不包含其他文件，如代码等。</p>
<p>元功能包用于指代其他按照类似功能特性分组的包，例如导航功能包集，ros_tutorials等。</p>
<p>使用迁移的特定规则，可以讲ROS
Fuerte中的功能包和功能包集转换为Kinetic等。具体参见http://wiki.ros.org/catkin/migrating_from_rosbuild。</p>
<p>在下图中。可以看到在ros_tutorials元功能包中package.xml的内容。可以看到
&lt;export&gt;标记和&lt;run_depend&gt;标记。这些事功能包清单中必不可缺少的，在下图中也可以看到这些标记。</p>
<p><img data-src="image-20200924160401768.png" /></p>
<p>如果你想定位<strong>ros_tutorials</strong>元功能包，可以使用下面的命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">rosstack find ros_tutorials</span><br></pre></td></tr></table></figure>
<p>显示路径为：</p>
<p><img data-src="image-20200924161034651.png" /></p>
<p>查看里面的代码</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vim /opt/ros/kinetic/share/ros_tutorials/package.xml</span><br></pre></td></tr></table></figure>
<p>注意：Kinetic使用元功能包，不是功能包集，但是<strong>rosstack
find</strong> 命令也可以用于查找元功能包。</p>
]]></content>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title>自然语言处理实战（一）｜NLTK入门教程.md</title>
    <url>/p/an-introduction-to-NLTK/</url>
    <content><![CDATA[<p>本文主要介绍了NLTK语言工具包。</p>
<p><strong>摘要：</strong>自然语言处理（NLP）是计算机科学领域与人工智能的一个重要方向。他研究实现人与计算机之间用自然语言进行有效的通信的各种领域和方法，涉及所有用计算机对自然语言处理进行的操作。以下例子是基于Python语言和一个名为NLTK的自然语言工具包的开源库实现的。</p>
<p><strong>关键词：</strong>自然语言处理，NLP，NLTK</p>
<span id="more"></span>
<p>NLTK创建于2001年，最初是宾夕法尼亚州立大学计算机与信息科学系计算语言学课程的一部分。从那以后，在数十名贡献者的帮助下不断发展壮大，如今，它已被数十所大学的课程所采纳，并作为许多项目研究的基础。</p>
<h3 id="第一章-语言处理与python">第一章 语言处理与Python</h3>
<p>提出问题：</p>
<ol type="1">
<li>通过将技术性较为简单的程序与大规模文本结合起来，我们能实现什么？</li>
<li>如何自动的提取处关键字和词组，用来总结文本的风格和内容？</li>
<li>Python编程语言为上述工作提供了哪些工具和技术？</li>
<li>自然语言处理中有哪些有趣的挑战呢？</li>
</ol>
<h4 id="语言计算文本和词汇">语言计算：文本和词汇</h4>
<h5 id="安装nltk">安装nltk</h5>
<p>使用pip进行安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install nltk</span><br></pre></td></tr></table></figure>
<p>输入以下命令来安装数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> nltk</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>nltk.download()</span><br></pre></td></tr></table></figure>
<p>或者直接点击以下链接进行下载：<a
href="https://github.com/nltk/nltk_data/archive/gh-pages.zip">点击下载</a></p>
<p>这里使用第二种方法。</p>
<p>下载完毕以后得到如图所示的压缩文件</p>
<p><img data-src="NLTK01.png" /></p>
<p>解压并打开文件夹</p>
<p><img data-src="NLTK02.png" /></p>
<p>打开packages，复制路径，添加<code>NLTK_DATA</code>到环境变量</p>
<p><img data-src="NLTK03.png" /></p>
<p>测试是否安装成功</p>
<p><img data-src="NLTK04.png" /></p>
<p>输入以下命令加载一些我们需要的文本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> nltk.book <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure>
<p><img data-src="NLTK05.png" /></p>
<p>无论什么时候想要找到这些文本，只需要在Python提示符后面输入它的名字即可</p>
<p><img data-src="NLTK06.png" /></p>
<h5 id="搜索文本">搜索文本</h5>
<p>除了简单地阅读文本之外，还有很多方法可以用来查看文本内容。词语索引视图可以显示指定单词地出现情况，同时可以显示一些上下文。</p>
<p>使用以下方法搜索<code>text1</code>文本中的<code>monstrous</code>单词。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">text1.concordance(<span class="string">&#x27;monstrous&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>搜索结果</p>
<p><img data-src="NLTK06.png" /></p>
<p>小试牛刀：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">text2.concordance(<span class="string">&#x27;lived&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><img data-src="NLTK07.png" /></p>
<p>关键词索引可以让我们看到上下文中的词，例如，可以看到monstrous出现在文章中，如the
__ pictures 和 the __
size，<strong>还有那些词出现在相似地上下文</strong>中？可以通过以下函数查看。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">text1.similar(<span class="string">&#x27;monstrous&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><img data-src="NLTK08.png" /></p>
<p>使用以下函数研究<strong>共用两个或者两个以上的词汇的上下文</strong>，如monstrous
和 very. 使用方括号和圆括号讲这些词括起来，中间用逗号分割。</p>
<p>【在<strong>text2</strong>找到用法、意义与该单词集合相似的词 】</p>
<p>【用来识别2个关键词相似的词语。】</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">text2.common_contexts([&quot;monstrous&quot;, &quot;very&quot;])</span><br></pre></td></tr></table></figure>
<p><img data-src="NLTK09.png" /></p>
]]></content>
      <tags>
        <tag>自然语言处理</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次重装Win10系统</title>
    <url>/p/an-experience-of-reinstalling-win10/</url>
    <content><![CDATA[<p>本文主要介绍了如何使用U盘进行重装系统，主要面向电脑小白用户。</p>
<p><strong>关键字</strong>：重装win10，电脑重装</p>
<span id="more"></span>
<p><strong><font color="red">对重装系统过程有疑问的小伙伴可以通过站内方式联系我！切勿自己胡乱操作以免造成数据损失！</font></strong></p>
<p><strong>下载链接有时间和流量限制，不定期开放！若链接过期请自行寻找下载链接！</strong></p>
<h3 id="准备工作">准备工作</h3>
<ol type="1">
<li>大于<strong>8G</strong>的U盘</li>
<li>微PE</li>
<li>Windows 10 1909原版系统镜像</li>
</ol>
<h3 id="制作启动盘">制作启动盘</h3>
<p>制作系统盘期间需要格式化U盘，如有需要请先备份U盘的文件。</p>
<h4 id="打开微pe工具箱">打开微PE工具箱</h4>
<h4 id="选择其他安装方式">选择其他安装方式</h4>
<p>注意不要点击<strong>立即安装进系统</strong></p>
<h4 id="选择安装pe进u盘">选择安装PE进U盘</h4>
<p>注意待写入U盘<strong>盘符、容量</strong>是不是正确，安装方法默认即可。</p>
<h4 id="等待安装完毕">等待安装完毕</h4>
<p>稍后片刻，安装速度视U盘写入速度决定，建议安装过程中<strong>不要操作电脑</strong>。</p>
<h4 id="检查启动盘是否制作成功">检查启动盘是否制作成功</h4>
<p>安装完毕后，打开<strong>此电脑</strong>，如果发现多了两个盘符，则视为完整成功。</p>
<p>如果没有发现多余的盘符，重新插拔U盘后再尝试查看。</p>
<h4 id="将下载的镜像复制进u盘">将下载的镜像复制进U盘</h4>
<p>切记切记！复制文件的速度视U盘读写速度决定，请耐心等待。</p>
<h3 id="切换到windows-pe">切换到Windows PE</h3>
<p>将U盘插入电脑并重启电脑，切换到Windows PE系统。</p>
<p>大多数的电脑都提供了启动选项菜单，开机的时候按住对应的快捷键即可进入启动选择界面。</p>
<p>重启时，电脑亮屏后立马按下对应的快捷键。</p>
<p>如果电脑键盘还有Fn键，且重启过程单独按下<strong>快捷键</strong>无效，那么可以尝试按下<strong>Fn键+快捷键</strong>，反复尝试几次。</p>
<h4 id="选择u盘启动">选择U盘启动</h4>
<p>使用键盘的上下进行选择，然后敲回车。这里以<strong>Shinelon</strong>笔记本为例。这款笔记本的启动项选择的快捷键是<strong>F7</strong>.</p>
<p>不同品牌的笔记本启动项选择的界面可能不同，但都<strong>大同小异</strong>。</p>
<p>选择<strong>已经写入好PE</strong>的U盘，如下图所示.</p>
<h4 id="进入pe系统">进入PE系统</h4>
<p>如果上述操作没有问题，会出现一个<strong>Windows Boot
Mananger</strong>的选择界面，选择第一项即可。</p>
<p>进入PE以后的界面，如下图所示。</p>
<h4 id="进行磁盘分区">进行磁盘分区</h4>
<p><strong><em>注意：如果不需要改变磁盘分区的大小，只想格式化原有的系统盘并安装全新的系统，此步可以跳过！直接跳转到下一步安装全新系统！强烈建议小白跳过此步！</em></strong></p>
<p>打开上图所示的<strong>分区助手</strong>，找到你要安装的磁盘，如下图所示。</p>
<p><em>操作到这里要注意：</em></p>
<ol type="1">
<li>如果你的电脑只有一个磁盘，继续操作会丢失<strong>全部硬盘</strong>的数据！切记切记！</li>
<li>如果你的电脑和我一样有多个磁盘，请选中你要安装系统的磁盘。继续操作会丢失<strong>以前系统盘</strong>的数据！</li>
</ol>
<p>进行<strong>磁盘分区</strong>是为了便于磁盘管理，和磁盘的个数无关。</p>
<ol type="1">
<li>如果你的电脑只有一个磁盘，接下来进行的<strong>快捷分区操作</strong>你可以选择<u>多分出几个分区</u>，重装完毕后打开此电脑，你选了几个分区就会看到有几个盘。</li>
<li>如果你的电脑和我一样有多个磁盘，建议将要安装系统的磁盘<u>全部分成一个区</u>，这样后期不会因为C盘容量较小而影响系统正常运行。具体参照以下步骤。</li>
</ol>
<p>注意，如果你的电脑有多个磁盘，请不要选错。分区数目视个人情况决定，多磁盘建议<strong>一个分区</strong>。磁盘的类型请选择<strong>GPT</strong>，注意勾选<strong>重建MBR</strong>、<strong>创建ESP和MSR分区</strong>。如果你的系统盘是<strong>固态硬盘</strong>，请<strong>勾选分区对其到4096扇区</strong>。</p>
<p>一般来说，如果你的电脑有多个磁盘，那么一个是<strong>传统的机械硬盘</strong>，一个是固态硬盘。固态硬盘的读写速度要比机械硬盘的读写速度要快得多。所以一般将固态硬盘安装成系统盘。</p>
<p>点击开始执行，进行系统分区。</p>
<p><strong><em>执行过程中请勿操作电脑！否则有可能对磁盘造成不可逆的损害！等待执行完毕。</em></strong></p>
<p>执行完毕后的新磁盘，如下图所示：</p>
<p>可以看到，磁盘已经被清空，且只有一个<strong>系统</strong>分区。</p>
<h4 id="还原系统镜像">还原系统镜像</h4>
<p>此步是重装系统的核心步骤，主要就是将全新的系统还原到系统盘中。</p>
<p>打开PE系统桌面的<strong>CGI备份还原</strong>，如图所示：</p>
<p>选择<strong>还原分区</strong>，一般来说，分区会默认选择好。通过<strong>盘符</strong>、<strong>可用空间</strong>和<strong>卷标</strong>来判断是不是系统盘。</p>
<p>镜像文件选择已经移动到U盘里的ISO文件，并选择<u>Windows 10 Pro</u> 即
<u>Windows10专业版</u> 的镜像。</p>
<p>点击执行，选中<strong>不保留目标分区的文件</strong>。最后点击确定。</p>
<p><strong><em>等待执行完毕，进度条大概会走三次，执行过程中请勿操作电脑！</em></strong></p>
<p>执行完毕后，请自行重启。点击<strong>开始</strong> ==&gt;
<strong>重启</strong>。电脑黑屏以后可以将U盘拔出，以免下次启动再进入U盘的PE系统。</p>
<h4 id="进入新系统">进入新系统</h4>
<p>重启过程可能比较慢。请耐心等待。</p>
<p>海内存知己，天涯若比邻。无为在歧路，儿女共沾巾。</p>
<p>出自唐代诗人王勃《送杜少府之任蜀州》</p>
<p>接下来是设置区域。默认帮你选好中国。</p>
<p>然后是设置网络。这里推荐设置，连接网络以后Win 10
可以帮你安装<strong>硬件设备的驱动</strong>。<strong>没有硬件驱动的电脑显卡，声卡，以及其他设备可能无法正常工作。</strong>由于个人网络原因这里选择不连接。</p>
<p>再次推荐你连接到网络。</p>
<p>接受许可协议。不接受无法继续安装23333</p>
<p>设置用户名。这里推荐设置英文的用户名，以免安装一些软件时出现一些莫名其妙的问题。</p>
<p>接下来是设置密码。可以留空。</p>
<p>选择隐私设置。</p>
<p>继续下一步。</p>
<p>设置微软个人助理小娜。</p>
<p>耐心等待。这是最后一步了。</p>
<p>即将完成。</p>
<p>熟悉的Windows 窗口又回来了！</p>
<p>至此，系统安装已经完成。后续还有<strong>激活系统，安装office办公软件</strong>等其他操作。</p>
<h3 id="后续操作">后续操作</h3>
<h4 id="激活系统">激活系统</h4>
<p>激活软件</p>
<p>打开激活软件，需要<strong>连接网络</strong>。点击<strong>数字激活</strong>。稍后片刻提示激活成功。</p>
<p>接下来是还原<strong>此电脑，控制面板等一系列图标</strong></p>
<p>单机<strong>桌面</strong> ==&gt;
<strong>个性化</strong>，找到<strong>主题</strong>。</p>
<p>下拉菜单，选择桌面光标设置</p>
<p>根据需要找回桌面图标。</p>
<p>回到<strong>桌面</strong>，右击<strong>此电脑</strong>，找到<strong>属性</strong>。</p>
<p>这里提示，此电脑已激活。此项激活是永久激活。</p>
<p>激活系统的步骤到此结束。</p>
<h4 id="安装office-2019-办公软件">安装office 2019 办公软件</h4>
<h5 id="下载镜像">下载镜像</h5>
<p>下载地址：<a
href="https://ftp.fly97.cn/file/proplus2019retail.img">点此下载</a></p>
<h5 id="安装office">安装office</h5>
<p>右键下载好的镜像，选择<strong>装载</strong>。</p>
<p>打开<strong>此电脑</strong>，此时会发现已经多出来一个<strong>DVD驱动器</strong>，如图所示。</p>
<p>双击打开，点击<strong>setup.exe</strong>，开始安装。</p>
<p>注意：如果不想安装office的全部组件，只想安装诸如<strong>word、excel、powerpoint</strong>等核心组件，请参考以下步骤：</p>
<h6 id="下载辅助安装软件">下载辅助安装软件</h6>
<p>Office Tool v7.6：<a
href="https://ftp.fly97.cn/file/Office-Tool-v7.6.zip">点击下载</a></p>
<h6 id="双击运行">双击运行</h6>
<p>该软件无需安装，双击打开即可。</p>
<h6 id="开始部署office">开始部署office</h6>
<p>点击部署，进入部署选择菜单</p>
<p>选择<strong>已经挂载好的DVD驱动器</strong>，打开<strong>Office ==&gt;
Data</strong>文件夹，选中<strong>v64</strong>，点击打开。</p>
<p>架构选择<strong>x64</strong>，安装方式为离线安装，安装模块为office部署工具。根据自身需要安装所需要的office应用程序。这里以<strong>Excel、PowerPoint和Word</strong>为例。最后点击开始部署。</p>
<h5 id="等待安装完毕-1">等待安装完毕</h5>
<p>耐心等待即可。</p>
<h5 id="安装完毕">安装完毕</h5>
<h5
id="使用kms密钥管理服务激活office">使用KMS密钥管理服务激活office</h5>
<p>打开上文提到的辅助安装工具，进入激活选择菜单。</p>
<p>许可证管理选项中，选择<strong>Office 2019
Volume</strong>，点击安装许可证。<strong><em>出现产品密钥安装成功则已安装完毕。</em></strong></p>
<p>KMS管理选项中，输入<strong>windows.kms.app</strong>，检测KMS可用性。</p>
<p>右侧出现<strong>successful</strong>则说明这个kms服务器是可用的。</p>
<p>点击激活，最后出现<strong>产品激活成功</strong>。到此激活完毕。</p>
<p>使用密钥管理服务激活office，每次激活成功以后可以使用180天，180天以后自动重新激活，只要<strong>KMS激活服务器</strong>还在生效就可以一直续期。可以实现<strong>永久激活</strong>。</p>
]]></content>
      <tags>
        <tag>win10</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Github Action定时重启IBM cloud foundry</title>
    <url>/p/ibm-cloud-auto-restart/</url>
    <content><![CDATA[<p>本文简单介绍了Github Action的用法，并使用Gihub Action定时重启IBM
cloud foundry容器。</p>
<p><strong>摘要：</strong>GitHub
Actions是GitHub自家的持续集成及自动化工作流服务，它使用起来非常简单，只要在你的仓库根目录建立<code>.github/workflows</code>文件夹，将你的工作流配置(YML文件)放到这个目录下，就能启用GitHub
Actions服务。</p>
<p><strong>关键字</strong>：Github Action，IBM cloud foundry</p>
<span id="more"></span>
<h3 id="yml配置文件">yml配置文件</h3>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">IBM</span> <span class="string">Cloud</span> <span class="string">Auto</span> <span class="string">Restart</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span> [ <span class="string">master</span> ]</span><br><span class="line">  <span class="attr">pull_request:</span></span><br><span class="line">    <span class="attr">branches:</span> [ <span class="string">master</span> ]</span><br><span class="line">  <span class="attr">schedule:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">cron:</span> <span class="string">&#x27;0 0 * * *&#x27;</span>      <span class="comment"># 根据自己的需要设置何时重启</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">ibm-cloud-restart:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Init</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        wget -q -O - https://packages.cloudfoundry.org/debian/cli.cloudfoundry.org.key | sudo apt-key add -</span></span><br><span class="line"><span class="string">        echo &quot;deb https://packages.cloudfoundry.org/debian stable main&quot; | sudo tee /etc/apt/sources.list.d/cloudfoundry-cli.list</span></span><br><span class="line"><span class="string">        sudo apt-get update</span></span><br><span class="line"><span class="string">        sudo apt-get install cf-cli</span></span><br><span class="line"><span class="string"></span>    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Login</span> <span class="string">IBM</span> <span class="string">Cloud</span></span><br><span class="line">      <span class="attr">env:</span></span><br><span class="line">        <span class="attr">IBM_ACCOUNT:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.IBM_ACCOUNT</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">IBM_PASSWORD:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.IBM_PASSWORD</span> <span class="string">&#125;&#125;</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        cf login -a https://api.us-south.cf.cloud.ibm.com -u $IBM_ACCOUNT &lt;&lt; EOF</span></span><br><span class="line"><span class="string">        $IBM_PASSWORD</span></span><br><span class="line"><span class="string">        EOF</span></span><br><span class="line"><span class="string"></span>    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Get</span> <span class="string">IBM</span> <span class="string">Cloud</span> <span class="string">Apps</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        cf a</span></span><br><span class="line"><span class="string"></span>    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Restart</span> <span class="string">IBM</span> <span class="string">Cloud</span></span><br><span class="line">      <span class="attr">env:</span></span><br><span class="line">        <span class="attr">IBM_APP_NAME:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.IBM_APP_NAME</span> <span class="string">&#125;&#125;</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">        <span class="string">cf</span> <span class="string">restart</span> <span class="string">$IBM_APP_NAME</span></span><br></pre></td></tr></table></figure>
<h3 id="使用方法">使用方法</h3>
<h4
id="fork仓库httpsgithub.comwf09ibmworkflow">fork仓库：https://github.com/wf09/IBMWorkflow</h4>
<h4 id="设置环境变量">设置环境变量</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IBM_ACCOUNT：账户邮箱</span><br><span class="line"></span><br><span class="line">IBM_APP_NAME：app的名字</span><br><span class="line"></span><br><span class="line">IBM_PASSWORD：密码</span><br></pre></td></tr></table></figure>
<p>设置完环境变量以后记得commit一下yml文件触发Action。</p>
<h4 id="效果图">效果图</h4>
<p><img data-src="image-20200827193322808.png" /></p>
<p>PS：达拉斯的容器测试通过，其他的地区可能需要将<code>https://api.us-south.cf.cloud.ibm.com</code>修改成你所在的地区。</p>
]]></content>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx.conf配置文件详解</title>
    <url>/p/How-to-configure-nginx-conf/</url>
    <content><![CDATA[<p>本文主要介绍了nginx的配置文件。</p>
<p><strong>摘要：</strong>Nginx
配置文件主要分成四部分：main（全局设置）、server（主机设置）、upstream（上游服务器设置，主要为反向代理、负载均衡相关配置）和
location（URL匹配特定位置后的设置）。main
部分设置的指令影响其他所有部分的设置；server
部分的指令主要用于制定虚拟主机域名、IP 和端口号；upstream
的指令用于设置一系列的后端服务器，设置反向代理及后端服务器的负载均衡；location
部分用于匹配网页位置（比如，根目录“/”，“/images”，等等）。他们之间的关系：server
继承 main，location 继承 server；upstream
既不会继承指令也不会被继承。</p>
<p><strong>关键词：</strong>Nginx</p>
<span id="more"></span>
<p>当前 nginx 支持的几个指令上下文()：</p>
<h4 id="nginx.conf-配置文件">nginx.conf 配置文件</h4>
<hr />
<p>下面是 nginx.conf
详细的配置文件介绍（<strong>以下配置参数很多时候并不一定用的到，只是作为配置参数说明参考，可以看下面的通用版介绍</strong>）</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment">#定义Nginx运行的用户和用户组</span></span><br><span class="line"><span class="attribute">user</span> www www; </span><br><span class="line"></span><br><span class="line"><span class="comment">#nginx进程数，通常设置成和cpu的数量相等</span></span><br><span class="line"><span class="attribute">worker_processes</span> <span class="number">4</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">#全局错误日志定义类型，[debug | info | notice | warn | error | crit]</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  notice;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  info;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#进程pid文件</span></span><br><span class="line"><span class="comment">#pid        logs/nginx.pid;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#指定进程可以打开的最大描述符：数目</span></span><br><span class="line"><span class="comment">#工作模式与连接数上限</span></span><br><span class="line"><span class="comment">##这个指令是指当一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（ulimit -n）与nginx进程数相除，但是nginx分配请求并不是那么均匀，所以最好与ulimit -n 的值保持一致。</span></span><br><span class="line"><span class="comment">#这是因为nginx调度时分配请求到进程并不是那么的均衡，所以假如填写10240，总并发量达到3-4万时就有进程可能超过10240了，这时会返回502错误。</span></span><br><span class="line"><span class="attribute">worker_rlimit_nofile</span> <span class="number">65535</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="comment">#参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; epoll模型</span></span><br><span class="line">    <span class="comment">#是Linux 2.6以上版本内核中的高性能网络I/O模型，linux建议epoll，如果跑在FreeBSD上面，就用kqueue模型。</span></span><br><span class="line">    <span class="comment">#补充说明：</span></span><br><span class="line">    <span class="comment">#与apache相类，nginx针对不同的操作系统，有不同的事件模型</span></span><br><span class="line">    <span class="comment">#A）标准事件模型</span></span><br><span class="line">    <span class="comment">#Select、poll属于标准事件模型，如果当前系统不存在更有效的方法，nginx会选择select或poll</span></span><br><span class="line">    <span class="comment">#B）高效事件模型</span></span><br><span class="line">    <span class="comment">#Kqueue：使用于FreeBSD 4.1+, OpenBSD 2.9+, NetBSD 2.0 和 MacOS X.使用双处理器的MacOS X系统使用kqueue可能会造成内核崩溃。</span></span><br><span class="line">    <span class="comment">#Epoll：使用于Linux内核2.6版本及以后的系统。</span></span><br><span class="line">    <span class="comment">#/dev/poll：使用于Solaris 7 11/99+，HP/UX 11.22+ (eventport)，IRIX 6.5.15+ 和 Tru64 UNIX 5.1A+。</span></span><br><span class="line">    <span class="comment">#Eventport：使用于Solaris 10。 为了防止出现内核崩溃的问题， 有必要安装安全补丁。</span></span><br><span class="line">    <span class="attribute">use</span> <span class="literal">epoll</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">#单个进程最大连接数（最大连接数=连接数+进程数）</span></span><br><span class="line">    <span class="comment">#根据硬件调整，和前面工作进程配合起来用，尽量大，但是别把cup跑到100%就行。</span></span><br><span class="line">    worker_connections  <span class="number">1024</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#keepalive 超时时间</span></span><br><span class="line">    <span class="attribute">keepalive_timeout</span> <span class="number">60</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求头的大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。</span></span><br><span class="line">    <span class="comment">#分页大小可以用命令getconf PAGESIZE 取得。</span></span><br><span class="line">    <span class="comment">#[root@web001 ~]# getconf PAGESIZE</span></span><br><span class="line">    <span class="comment">#但也有client_header_buffer_size超过4k的情况，但是client_header_buffer_size该值必须设置为“系统分页大小”的整倍数。</span></span><br><span class="line">    <span class="attribute">client_header_buffer_size</span> <span class="number">4k</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#这个将为打开文件指定缓存，默认是没有启用的，max指定缓存数量，建议和打开文件数一致，inactive是指经过多长时间文件没被请求后删除缓存。</span></span><br><span class="line">    <span class="attribute">open_file_cache</span> max=<span class="number">65535</span> inactive=<span class="number">60s</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">#这个是指多长时间检查一次缓存的有效信息。</span></span><br><span class="line">    <span class="comment">#语法:open_file_cache_valid time 默认值:open_file_cache_valid 60 使用字段:http, server, location 这个指令指定了何时需要检查open_file_cache中缓存项目的有效信息.</span></span><br><span class="line">    <span class="attribute">open_file_cache_valid</span> <span class="number">80s</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">#open_file_cache指令中的inactive参数时间内文件的最少使用次数，如果超过这个数字，文件描述符一直是在缓存中打开的，如上例，如果有一个文件在inactive时间内一次没被使用，它将被移除。</span></span><br><span class="line">    <span class="comment">#语法:open_file_cache_min_uses number 默认值:open_file_cache_min_uses 1 使用字段:http, server, location  这个指令指定了在open_file_cache指令无效的参数中一定的时间范围内可以使用的最小文件数,如果使用更大的值,文件描述符在cache中总是打开状态.</span></span><br><span class="line">    <span class="attribute">open_file_cache_min_uses</span> <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#语法:open_file_cache_errors on | off 默认值:open_file_cache_errors off 使用字段:http, server, location 这个指令指定是否在搜索一个文件是记录cache错误.</span></span><br><span class="line">    <span class="attribute">open_file_cache_errors</span> <span class="literal">on</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#设定http服务器，利用它的反向代理功能提供负载均衡支持</span></span><br><span class="line">http&#123;</span><br><span class="line">    <span class="comment">#文件扩展名与文件类型映射表</span></span><br><span class="line">    <span class="attribute">include</span> mime.types;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#默认文件类型</span></span><br><span class="line">    <span class="attribute">default_type</span> application/octet-stream;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#默认编码</span></span><br><span class="line">    <span class="attribute">charset</span> utf-<span class="number">8</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#服务器名字的hash表大小</span></span><br><span class="line">    <span class="comment">#保存服务器名字的hash表是由指令server_names_hash_max_size 和server_names_hash_bucket_size所控制的。参数hash bucket size总是等于hash表的大小，并且是一路处理器缓存大小的倍数。在减少了在内存中的存取次数后，使在处理器中加速查找hash表键值成为可能。如果hash bucket size等于一路处理器缓存的大小，那么在查找键的时候，最坏的情况下在内存中查找的次数为2。第一次是确定存储单元的地址，第二次是在存储单元中查找键 值。因此，如果Nginx给出需要增大hash max size 或 hash bucket size的提示，那么首要的是增大前一个参数的大小.</span></span><br><span class="line">    <span class="attribute">server_names_hash_bucket_size</span> <span class="number">128</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求的头部大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。分页大小可以用命令getconf PAGESIZE取得。</span></span><br><span class="line">    <span class="attribute">client_header_buffer_size</span> <span class="number">32k</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#客户请求头缓冲大小。nginx默认会用client_header_buffer_size这个buffer来读取header值，如果header过大，它会使用large_client_header_buffers来读取。</span></span><br><span class="line">    <span class="attribute">large_client_header_buffers</span> <span class="number">4</span> <span class="number">64k</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#设定通过nginx上传文件的大小</span></span><br><span class="line">    <span class="attribute">client_max_body_size</span> <span class="number">8m</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。</span></span><br><span class="line">    <span class="comment">#sendfile指令指定 nginx 是否调用sendfile 函数（zero copy 方式）来输出文件，对于普通应用，必须设为on。如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络IO处理速度，降低系统uptime。</span></span><br><span class="line">    <span class="attribute">sendfile</span> <span class="literal">on</span>;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">#开启目录列表访问，合适下载服务器，默认关闭。</span></span><br><span class="line">    <span class="attribute">autoindex</span> <span class="literal">on</span>;</span><br><span class="line">    </span><br><span class="line">      <span class="comment">#此选项允许或禁止使用socke的TCP_CORK的选项，此选项仅在使用sendfile的时候使用</span></span><br><span class="line">    <span class="attribute">tcp_nopush</span> <span class="literal">on</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="attribute">tcp_nodelay</span> <span class="literal">on</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#长连接超时时间，单位是秒</span></span><br><span class="line">    <span class="attribute">keepalive_timeout</span> <span class="number">120</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问速度。下面参数看字面意思都能理解。</span></span><br><span class="line">    <span class="attribute">fastcgi_connect_timeout</span> <span class="number">300</span>;</span><br><span class="line">    <span class="attribute">fastcgi_send_timeout</span> <span class="number">300</span>;</span><br><span class="line">    <span class="attribute">fastcgi_read_timeout</span> <span class="number">300</span>;</span><br><span class="line">    <span class="attribute">fastcgi_buffer_size</span> <span class="number">64k</span>;</span><br><span class="line">    <span class="attribute">fastcgi_buffers</span> <span class="number">4</span> <span class="number">64k</span>;</span><br><span class="line">    <span class="attribute">fastcgi_busy_buffers_size</span> <span class="number">128k</span>;</span><br><span class="line">    <span class="attribute">fastcgi_temp_file_write_size</span> <span class="number">128k</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#gzip模块设置</span></span><br><span class="line">    <span class="attribute">gzip</span> <span class="literal">on</span>; <span class="comment">#开启gzip压缩输出</span></span><br><span class="line">    <span class="attribute">gzip_min_length</span> <span class="number">1k</span>;    <span class="comment">#最小压缩文件大小</span></span><br><span class="line">    <span class="attribute">gzip_buffers</span> <span class="number">4</span> <span class="number">16k</span>;    <span class="comment">#压缩缓冲区</span></span><br><span class="line">    <span class="attribute">gzip_http_version</span> <span class="number">1</span>.<span class="number">0</span>; <span class="comment">#压缩版本（默认1.1，前端如果是squid2.5请使用1.0）</span></span><br><span class="line">    <span class="attribute">gzip_comp_level</span> <span class="number">2</span>;     <span class="comment">#压缩等级</span></span><br><span class="line">    <span class="attribute">gzip_types</span> text/plain application/x-javascript text/css application/xml;    <span class="comment">#压缩类型，默认就已经包含textml，所以下面就不用再写了，写上去也不会有问题，但是会有一个warn。</span></span><br><span class="line">    <span class="attribute">gzip_vary</span> <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#开启限制IP连接数的时候需要使用</span></span><br><span class="line">    <span class="comment">#limit_zone crawler $binary_remote_addr 10m;</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">#负载均衡配置</span></span><br><span class="line">    <span class="section">upstream</span> piao.jd.com &#123;</span><br><span class="line">     </span><br><span class="line">        <span class="comment">#upstream的负载均衡，weight是权重，可以根据机器配置定义权重。weigth参数表示权值，权值越高被分配到的几率越大。</span></span><br><span class="line">        <span class="attribute">server</span> <span class="number">192.168.80.121:80</span> weight=<span class="number">3</span>;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">192.168.80.122:80</span> weight=<span class="number">2</span>;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">192.168.80.123:80</span> weight=<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#nginx的upstream目前支持4种方式的分配</span></span><br><span class="line">        <span class="comment">#1、轮询（默认）</span></span><br><span class="line">        <span class="comment">#每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。</span></span><br><span class="line">        <span class="comment">#2、weight</span></span><br><span class="line">        <span class="comment">#指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。</span></span><br><span class="line">        <span class="comment">#例如：</span></span><br><span class="line">        <span class="comment">#upstream bakend &#123;</span></span><br><span class="line">        <span class="comment">#    server 192.168.0.14 weight=10;</span></span><br><span class="line">        <span class="comment">#    server 192.168.0.15 weight=10;</span></span><br><span class="line">        <span class="comment">#&#125;</span></span><br><span class="line">        <span class="comment">#2、ip_hash</span></span><br><span class="line">        <span class="comment">#每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。</span></span><br><span class="line">        <span class="comment">#例如：</span></span><br><span class="line">        <span class="comment">#upstream bakend &#123;</span></span><br><span class="line">        <span class="comment">#    ip_hash;</span></span><br><span class="line">        <span class="comment">#    server 192.168.0.14:88;</span></span><br><span class="line">        <span class="comment">#    server 192.168.0.15:80;</span></span><br><span class="line">        <span class="comment">#&#125;</span></span><br><span class="line">        <span class="comment">#3、fair（第三方）</span></span><br><span class="line">        <span class="comment">#按后端服务器的响应时间来分配请求，响应时间短的优先分配。</span></span><br><span class="line">        <span class="comment">#upstream backend &#123;</span></span><br><span class="line">        <span class="comment">#    server server1;</span></span><br><span class="line">        <span class="comment">#    server server2;</span></span><br><span class="line">        <span class="comment">#    fair;</span></span><br><span class="line">        <span class="comment">#&#125;</span></span><br><span class="line">        <span class="comment">#4、url_hash（第三方）</span></span><br><span class="line">        <span class="comment">#按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。</span></span><br><span class="line">        <span class="comment">#例：在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法</span></span><br><span class="line">        <span class="comment">#upstream backend &#123;</span></span><br><span class="line">        <span class="comment">#    server squid1:3128;</span></span><br><span class="line">        <span class="comment">#    server squid2:3128;</span></span><br><span class="line">        <span class="comment">#    hash $request_uri;</span></span><br><span class="line">        <span class="comment">#    hash_method crc32;</span></span><br><span class="line">        <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#tips:</span></span><br><span class="line">        <span class="comment">#upstream bakend&#123;#定义负载均衡设备的Ip及设备状态&#125;&#123;</span></span><br><span class="line">        <span class="comment">#    ip_hash;</span></span><br><span class="line">        <span class="comment">#    server 127.0.0.1:9090 down;</span></span><br><span class="line">        <span class="comment">#    server 127.0.0.1:8080 weight=2;</span></span><br><span class="line">        <span class="comment">#    server 127.0.0.1:6060;</span></span><br><span class="line">        <span class="comment">#    server 127.0.0.1:7070 backup;</span></span><br><span class="line">        <span class="comment">#&#125;</span></span><br><span class="line">        <span class="comment">#在需要使用负载均衡的server中增加 proxy_pass http://bakend/;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#每个设备的状态设置为:</span></span><br><span class="line">        <span class="comment">#1.down表示单前的server暂时不参与负载</span></span><br><span class="line">        <span class="comment">#2.weight为weight越大，负载的权重就越大。</span></span><br><span class="line">        <span class="comment">#3.max_fails：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream模块定义的错误</span></span><br><span class="line">        <span class="comment">#4.fail_timeout:max_fails次失败后，暂停的时间。</span></span><br><span class="line">        <span class="comment">#5.backup： 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#nginx支持同时设置多组的负载均衡，用来给不用的server来使用。</span></span><br><span class="line">        <span class="comment">#client_body_in_file_only设置为On 可以讲client post过来的数据记录到文件中用来做debug</span></span><br><span class="line">        <span class="comment">#client_body_temp_path设置记录文件的目录 可以设置最多3层目录</span></span><br><span class="line">        <span class="comment">#location对URL进行匹配.可以进行重定向或者进行新的代理 负载均衡</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">#虚拟主机的配置</span></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="comment">#监听端口</span></span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#域名可以有多个，用空格隔开</span></span><br><span class="line">        <span class="attribute">server_name</span> www.jd.com jd.com;</span><br><span class="line">        <span class="comment">#默认入口文件名称</span></span><br><span class="line">        <span class="attribute">index</span> index.html index.htm index.php;</span><br><span class="line">        <span class="attribute">root</span> /data/www/jd;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#对******进行负载均衡</span></span><br><span class="line">        <span class="section">location</span> <span class="regexp">~ .*.(php|php5)?$</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attribute">fastcgi_pass</span> <span class="number">127.0.0.1:9000</span>;</span><br><span class="line">            <span class="attribute">fastcgi_index</span> index.php;</span><br><span class="line">            <span class="attribute">include</span> fastcgi.conf;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">#图片缓存时间设置</span></span><br><span class="line">        <span class="section">location</span> <span class="regexp">~ .*.(gif|jpg|jpeg|png|bmp|swf)$</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attribute">expires</span> <span class="number">10d</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">#JS和CSS缓存时间设置</span></span><br><span class="line">        <span class="section">location</span> <span class="regexp">~ .*.(js|css)?$</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attribute">expires</span> <span class="number">1h</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">#日志格式设定</span></span><br><span class="line">        <span class="comment">#$remote_addr与$http_x_forwarded_for用以记录客户端的ip地址；</span></span><br><span class="line">        <span class="comment">#$remote_user：用来记录客户端用户名称；</span></span><br><span class="line">        <span class="comment">#$time_local： 用来记录访问时间与时区；</span></span><br><span class="line">        <span class="comment">#$request： 用来记录请求的url与http协议；</span></span><br><span class="line">        <span class="comment">#$status： 用来记录请求状态；成功是200，</span></span><br><span class="line">        <span class="comment">#$body_bytes_sent ：记录发送给客户端文件主体内容大小；</span></span><br><span class="line">        <span class="comment">#$http_referer：用来记录从那个页面链接访问过来的；</span></span><br><span class="line">        <span class="comment">#$http_user_agent：记录客户浏览器的相关信息；</span></span><br><span class="line">        <span class="comment">#通常web服务器放在反向代理的后面，这样就不能获取到客户的IP地址了，通过$remote_add拿到的IP地址是反向代理服务器的iP地址。反向代理服务器在转发请求的http头信息中，可以增加x_forwarded_for信息，用以记录原有客户端的IP地址和原来客户端的请求的服务器地址。</span></span><br><span class="line">        <span class="attribute">log_format</span> access <span class="string">&#x27;<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] &quot;<span class="variable">$request</span>&quot; &#x27;</span></span><br><span class="line">        <span class="string">&#x27;<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> &quot;<span class="variable">$http_referer</span>&quot; &#x27;</span></span><br><span class="line">        <span class="string">&#x27;&quot;<span class="variable">$http_user_agent</span>&quot; <span class="variable">$http_x_forwarded_for</span>&#x27;</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">#定义本虚拟主机的访问日志</span></span><br><span class="line">        <span class="attribute">access_log</span>  /usr/local/nginx/logs/host.access.log  main;</span><br><span class="line">        <span class="attribute">access_log</span>  /usr/local/nginx/logs/host.access.<span class="number">404</span>.log  log404;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">#对 &quot;/connect-controller&quot; 启用反向代理</span></span><br><span class="line">        <span class="section">location</span> /connect-controller &#123;</span><br><span class="line">            <span class="attribute">proxy_pass</span> http://127.0.0.1:88; <span class="comment">#请注意此处端口号不能与虚拟主机监听的端口号一样（也就是server监听的端口）</span></span><br><span class="line">            <span class="attribute">proxy_redirect</span> <span class="literal">off</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">             </span><br><span class="line">            <span class="comment">#后端的Web服务器可以通过X-Forwarded-For获取用户真实IP</span></span><br><span class="line">            <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">             </span><br><span class="line">            <span class="comment">#以下是一些反向代理的配置，可选。</span></span><br><span class="line">            <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">#允许客户端请求的最大单文件字节数</span></span><br><span class="line">            <span class="attribute">client_max_body_size</span> <span class="number">10m</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">#缓冲区代理缓冲用户端请求的最大字节数，</span></span><br><span class="line">            <span class="comment">#如果把它设置为比较大的数值，例如256k，那么，无论使用firefox还是IE浏览器，来提交任意小于256k的图片，都很正常。如果注释该指令，使用默认的client_body_buffer_size设置，也就是操作系统页面大小的两倍，8k或者16k，问题就出现了。</span></span><br><span class="line">            <span class="comment">#无论使用firefox4.0还是IE8.0，提交一个比较大，200k左右的图片，都返回500 Internal Server Error错误</span></span><br><span class="line">            <span class="attribute">client_body_buffer_size</span> <span class="number">128k</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">#表示使nginx阻止HTTP应答代码为400或者更高的应答。</span></span><br><span class="line">            <span class="attribute">proxy_intercept_errors</span> <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">#后端服务器连接的超时时间_发起握手等候响应超时时间</span></span><br><span class="line">            <span class="comment">#nginx跟后端服务器连接超时时间(代理连接超时)</span></span><br><span class="line">            <span class="attribute">proxy_connect_timeout</span> <span class="number">90</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">#后端服务器数据回传时间(代理发送超时)</span></span><br><span class="line">            <span class="comment">#后端服务器数据回传时间_就是在规定时间之内后端服务器必须传完所有的数据</span></span><br><span class="line">            <span class="attribute">proxy_send_timeout</span> <span class="number">90</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">#连接成功后，后端服务器响应时间(代理接收超时)</span></span><br><span class="line">            <span class="comment">#连接成功后_等候后端服务器响应时间_其实已经进入后端的排队之中等候处理（也可以说是后端服务器处理请求的时间）</span></span><br><span class="line">            <span class="attribute">proxy_read_timeout</span> <span class="number">90</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">#设置代理服务器（nginx）保存用户头信息的缓冲区大小</span></span><br><span class="line">            <span class="comment">#设置从被代理服务器读取的第一部分应答的缓冲区大小，通常情况下这部分应答中包含一个小的应答头，默认情况下这个值的大小为指令proxy_buffers中指定的一个缓冲区的大小，不过可以将其设置为更小</span></span><br><span class="line">            <span class="attribute">proxy_buffer_size</span> <span class="number">4k</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">#proxy_buffers缓冲区，网页平均在32k以下的设置</span></span><br><span class="line">            <span class="comment">#设置用于读取应答（来自被代理服务器）的缓冲区数目和大小，默认情况也为分页大小，根据操作系统的不同可能是4k或者8k</span></span><br><span class="line">            <span class="attribute">proxy_buffers</span> <span class="number">4</span> <span class="number">32k</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">#高负荷下缓冲大小（proxy_buffers*2）</span></span><br><span class="line">            <span class="attribute">proxy_busy_buffers_size</span> <span class="number">64k</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">#设置在写入proxy_temp_path时数据的大小，预防一个工作进程在传递文件时阻塞太长</span></span><br><span class="line">            <span class="comment">#设定缓存文件夹大小，大于这个值，将从upstream服务器传</span></span><br><span class="line">            <span class="attribute">proxy_temp_file_write_size</span> <span class="number">64k</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#本地动静分离反向代理配置</span></span><br><span class="line">        <span class="comment">#所有jsp的页面均交由tomcat或resin处理</span></span><br><span class="line">        <span class="section">location</span> <span class="regexp">~ .(jsp|jspx|do)?$</span> &#123;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">            <span class="attribute">proxy_pass</span> http://127.0.0.1:8080;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>安装Fish自动匹配历史命令</title>
    <url>/p/install-fish-shell-to-automatically-match-historical-commands/</url>
    <content><![CDATA[<p>本文介绍了Fish的使用，使用Fish可以根据输入自动匹配历史命令。</p>
<p><strong>摘要</strong>：Fish的官网宣传语是 Finally, a command line
shell for the 90s。 翻译过来就是 Fish shell 是一个为90后准备的
shell。有人说：“二逼青年用bash，普通青年用zsh，文艺青年用fish。”
其次由于zsh
的速度实在是太慢，所以决定换用fish，fish速度快，智能提示强大。</p>
<p><strong>关键字</strong>：Fish</p>
<span id="more"></span>
<h4 id="fish入门使用">Fish入门使用</h4>
<h5 id="ubuntu安装fish">Ubuntu安装Fish</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install software-properties-common</span><br><span class="line">sudo apt-add-repository ppa:fish-shell/release-2</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install fish</span><br><span class="line"><span class="comment">#切换到fish</span></span><br><span class="line"><span class="built_in">echo</span> /usr/bin/fish | sudo <span class="built_in">tee</span> -a /etc/shells</span><br><span class="line">sudo chsh -s /usr/bin/fish &amp;&amp; fish</span><br></pre></td></tr></table></figure>
<p>fish的鲜明特征在于安装时已经默认集成了很多需要的功能。 比如：</p>
<ul>
<li>命令行语法高亮，错误会显示红色</li>
<li>智能提示</li>
<li>可以使用web网页的进行终端配置</li>
</ul>
<p>fish
有智能提示，一个命令一旦输入过一次，会自动显示上一次的全部命令，细心一点会发现会有一层灰色的字体表示上一次的命令，按<code>Ctrl+F</code>或者
右方向键<code>→</code>， 即可自动补全。</p>
<h5 id="网页配置fish">网页配置Fish</h5>
<p><code>fish_config</code> 可以直接跳出网页版本配置fish的界面。</p>
<p>web版本可以设置主题， 推荐其中的"Tomorrow Night"主题颜色。</p>
<p>选择想要的主题，然后点击set theme即可设置主题。 在命令里按enter
即可退出web版本的界面。</p>
<p>在prompt里面可以自己选择fish终端的主题。</p>
<h4 id="兼容bash">兼容Bash</h4>
<p>由于fish
很多<strong>不兼容</strong>bash的功能导致了很多脚本无法运行，这一点是很多人吐槽fish的地方，我们需要一种方式来运行bash脚本。</p>
<p>比如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">arc land --onto `git rev-parse --abbrev-ref HEAD` </span><br></pre></td></tr></table></figure>
<p>只需要在前面添加一个bash -c 命令即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash -c <span class="string">&quot;arc land --onto `git rev-parse --abbrev-ref HEAD`&quot;</span></span><br></pre></td></tr></table></figure>
<p>顺手加个alias就更方便了，可以直接在命令行里使用命令<code>arcl</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">alias</span> arcl bash -c <span class="string">&quot;arc land --onto `git rev-parse --abbrev-ref HEAD`&quot;</span></span><br></pre></td></tr></table></figure>
<p>对于脚本文件，比如我将需要执行的命令或文件放到<code>repomerge.sh</code></p>
<p>在~/.config/fish/config.fish添加</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">alias</span> up <span class="string">&quot;bash -c /usr/bin/repomerge.sh&quot;</span></span><br></pre></td></tr></table></figure>
<p>然后就可以自由的使用up命令了</p>
<p>其中function fish_prompt 函数用于定义fish终端的显示样式。</p>
<p>我们只需要写一个fish_prompt函数即可。集成了git的分支名称以及当前的变化。</p>
<p>显示的样式如下：</p>
<p><strong>说明: ✔代表当前git项目是干净的。 %1 表示有一个文件未追踪 +1
表示一个文件已暂存</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 终端显示样式的配置</span></span><br><span class="line"><span class="keyword">function</span> fish_prompt --description <span class="string">&#x27;Write out the prompt&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> not <span class="built_in">set</span> -q __fish_prompt_normal</span><br><span class="line">        <span class="built_in">set</span> -g __fish_prompt_normal (set_color normal)</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    __fish_git_prompt &gt;/dev/null 2&gt;&amp;1</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> git_is_repo</span><br><span class="line">        <span class="keyword">if</span> not <span class="built_in">set</span> -q __git_cb</span><br><span class="line">            <span class="built_in">set</span> __git_cb (set_color blue)<span class="string">&quot; (&quot;</span>(set_color brred)(git branch | grep \* | sed <span class="string">&#x27;s/* //&#x27;</span>) (set_color -o bryellow)(__fish_git_prompt_informative_status)(set_color blue)<span class="string">&quot;)&quot;</span></span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> not <span class="built_in">set</span> -q __fish_prompt_cwd</span><br><span class="line">        <span class="built_in">set</span> -g __fish_prompt_cwd (set_color <span class="variable">$fish_color_cwd</span>)</span><br><span class="line">    end</span><br><span class="line">    <span class="built_in">printf</span> <span class="string">&#x27;%s%s%s%s &#x27;</span> <span class="string">&quot;<span class="variable">$__fish_prompt_cwd</span>&quot;</span> (prompt_pwd) <span class="string">&quot;<span class="variable">$__fish_prompt_normal</span>&quot;</span> <span class="variable">$__git_cb</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h4 id="隐藏欢迎语">隐藏欢迎语</h4>
<p>在confin.sh文件里添加如下函数即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> fish_greeting</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h4 id="其他配置">其他配置</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">alias</span> l <span class="string">&quot;ll&quot;</span></span><br><span class="line"><span class="built_in">alias</span> <span class="built_in">dir</span> <span class="string">&quot;dde-file-manager . &amp;&quot;</span></span><br><span class="line"><span class="built_in">alias</span> docker <span class="string">&quot;sudo docker&quot;</span></span><br><span class="line"><span class="built_in">alias</span> apt <span class="string">&quot;sudo apt&quot;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>安装autojump自动切换目录</title>
    <url>/p/install-autojump-to-automatically-switch-directories/</url>
    <content><![CDATA[<p>本文介绍了autojump的使用，使用autojump可以很方便地切换目录。</p>
<p><strong>摘要</strong>：熟悉Linux
的小伙伴们都知道，在终端下需要使用命令<code>cd</code>切换目录。对于多层目录，还需要不停的用使用<code>cd</code>命令或者
Tab
键补齐，如果目录下文件夹过多，还需要使用<code>ls</code>查看当前目录下的文件。<a
href="https://github.com/wting/autojump">autojump</a>是浏览文件系统的一种更快的方法。它通过维护命令行中最常用的目录的数据库来工作。autojump
是通过记录进入过的目录到数据库来实现的，所以必须是曾经进入过的目录才能跳转。</p>
<p><strong>关键字</strong>：autojump</p>
<span id="more"></span>
<h4 id="linux下安装">Linux下安装</h4>
<h5 id="源码安装">源码安装</h5>
<p>克隆以下仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/wting/autojump.git</span><br></pre></td></tr></table></figure>
<p>coding分流</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://e.coding.net/fly97/github-projects/autojump.git</span><br></pre></td></tr></table></figure>
<p>执行安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> autojump</span><br><span class="line"><span class="built_in">chmod</span> +x install.py</span><br><span class="line">./install.py</span><br></pre></td></tr></table></figure>
<h5 id="fish-shell的设置">fish shell的设置</h5>
<p>执行以下命令以创建fish shell的配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;if test -f /root/.autojump/share/autojump/autojump.fish; . /root/.autojump/share/autojump/autojump.fish; end&quot;</span> &gt;&gt; ~/.config/fish/config.fish</span><br></pre></td></tr></table></figure>
<h5 id="修改环境变量">修改环境变量</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;export PATH=&quot;</span><span class="variable">$PATH</span>:/root/.autojump/bin<span class="string">&quot; &gt; /etc/profile</span></span><br></pre></td></tr></table></figure>
<h5 id="执行以下命令检查是否正常运行">执行以下命令检查是否正常运行</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">j --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>
<p><img data-src="image-20200811140853462.png" /></p>
<h4 id="常用命令">常用命令</h4>
<h5 id="查看-autojump-存储的目录的状态">查看 <code>autojump</code>
存储的目录的状态</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">j -s</span><br></pre></td></tr></table></figure>
<p><img data-src="image-20200811142040440.png" /></p>
<h5 id="查看使用帮助">查看使用帮助</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">j -h</span><br></pre></td></tr></table></figure>
<p><img data-src="image-20200811142133380.png" /></p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker的网络模式</title>
    <url>/p/Docker-network-mode/</url>
    <content><![CDATA[<p><code>docker</code>目前支持以下5种网络模式：</p>
<p>使用<code>docker run</code> 创建 <code>Docker</code> 容器时，可以用
<code>--network</code> 选项指定容器的网络模式。</p>
<span id="more"></span>
<h3 id="host模式">host模式</h3>
<p>​ 使用 <code>--netrork=host</code>
指定。与宿主机共享网络，此时容器没有使用网络的namespace，宿主机的所有设备，如Dbus会暴露到容器中，因此存在安全隐患。容器将不会虚拟出自己的网卡，配置自己的
IP 等，而是使用宿主机的 IP 和端口。</p>
<h3 id="container模式">container模式</h3>
<p>使用 <code>--network=container:NAME or ID</code>
指定。指定与某个容器实例共享网络。这个模式指定新创建的容器和已经存在的一个容器共享一个
Network
Namespace，而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的
IP，而是和一个指定的容器共享
IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。两个容器的进程可以通过
lo 网卡设备通信。</p>
<h3 id="none模式">none模式</h3>
<p>使用 <code>--network=none</code>
指定。不设置网络，相当于容器内没有配置网卡，用户可以手动配置。</p>
<h3 id="bridge模式-默认设置">bridge模式 （默认设置）</h3>
<p>使用 <code>--network=bridge</code> 指定，默认设置。</p>
<p>bridge 模式是 Docker 默认的网络设置，此模式会为每一个容器分配 Network
Namespace、设置 IP 等，并将一个主机上的 Docker
容器连接到一个虚拟网桥上。</p>
<p>当 Docker server 启动时，会在主机上创建一个名为 docker0
的虚拟网桥，此主机上启动的 Docker
容器会连接到这个虚拟网桥上。虚拟网桥的工作方式和物理交换机类似，这样主机上的所有容器就通过交换机连在了一个二层网络中。</p>
<p>接下来就要为容器分配 IP 了，Docker 会从 RFC1918 所定义的私有 IP
网段中，选择一个和宿主机不同的IP地址和子网分配给 docker0，连接到 docker0
的容器就从这个子网中选择一个未占用的 IP 使用。如一般 Docker 会使用
172.17.0.0/16 这个网段，并将 172.17.42.1/16 分配给 docker0
网桥（在主机上使用 ifconfig 命令是可以看到 docker0
的，可以认为它是网桥的管理接口，在宿主机上作为一块虚拟网卡使用）</p>
<p>当创建一个 Docker 容器的时候，同时会创建了一对 veth pair
接口（当数据包发送到一个接口时，另外一个接口也可以收到相同的数据包）。这对接口一端在容器内，即
eth0；另一端在本地并被挂载到 docker0 网桥，名称以 veth 开头（例如
vethAQI2QT）。通过这种方式，主机可以跟容器通信，容器之间也可以相互通信。Docker
就创建了在主机和所有容器之间一个虚拟共享网络。</p>
<p><strong>默认是桥接模式，网络地址为172.17.0.0/16，同一主机的容器实例能够通信，但不能跨主机通信。</strong></p>
<h3 id="自定义模式">自定义模式</h3>
<p>使用自定义网络，可以使用docker network
create创建，并且默认支持多种网络驱动，用户可以自由创建桥接网络或者overlay网络。</p>
]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>初探Docker(二) | 使用Dockerfile定制镜像</title>
    <url>/p/docker-tutorial-02/</url>
    <content><![CDATA[<p>本文主要介绍了Dockerfile。</p>
<p><strong>摘要：什么是 Dockerfile？</strong></p>
<p>Dockerfile
是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。</p>
<p><strong>关键词：</strong>Dockerfile</p>
<span id="more"></span>
<h3 id="使用-dockerfile-定制镜像">使用 Dockerfile 定制镜像</h3>
<h4 id="定制一个ubuntu镜像">定制一个ubuntu镜像</h4>
<p>在一个空目录下，新建一个名为 Dockerfile
文件，并在文件内添加以下内容：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">18.04</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&#x27;这是一个本地构建的ubuntu:18.04镜像&#x27;</span></span></span><br></pre></td></tr></table></figure>
<h4 id="from-和-run-指令的作用">FROM 和 RUN 指令的作用</h4>
<p><strong>FROM</strong>：定制的镜像都是基于 FROM 的镜像，这里的
<strong>ubuntu:18.04</strong>就是定制需要的基础镜像。后续的操作都是基于
ubuntu。</p>
<p><strong>RUN</strong>：用于执行后面跟着的命令行命令。有以下两种格式：</p>
<p>Shell格式</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> &lt;命令行命令&gt;</span></span><br><span class="line"><span class="comment"># &lt;命令行命令&gt; 等同于，在终端操作的 shell 命令。</span></span><br></pre></td></tr></table></figure>
<p>Exec 格式：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> [<span class="string">&quot;可执行文件&quot;</span>, <span class="string">&quot;参数1&quot;</span>, <span class="string">&quot;参数2&quot;</span>]</span></span><br><span class="line"><span class="comment"># 例如：</span></span><br><span class="line"><span class="comment"># RUN [&quot;./test.php&quot;, &quot;dev&quot;, &quot;offline&quot;] 等价于 RUN ./test.php dev offline</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：Dockerfile 的指令每执行一次都会在 docker
上新建一层。所以过多无意义的层，会造成镜像膨胀过大。</p>
<p>​ 例如：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum install wget</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> wget -O redis.tar.gz <span class="string">&quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> tar -xvf redis.tar.gz</span></span><br></pre></td></tr></table></figure>
<p>​ 以上执行会创建 3 层镜像。可简化为以下格式：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum install wget \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; wget -O redis.tar.gz <span class="string">&quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span> \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; tar -xvf redis.tar.gz</span></span><br></pre></td></tr></table></figure>
<p>以 <strong>&amp;&amp;</strong> 符号连接命令，这样执行后，只会创建 1
层镜像。</p>
<h4 id="开始构建镜像">开始构建镜像</h4>
<p>切换到<code>Dockerfile</code>
文件的存放目录，执行以下命令，开始构建对象。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker build -t ubuntu:latest .</span><br></pre></td></tr></table></figure>
<p>以上示例，通过目录下的 Dockerfile 构建一个
<code>ubuntu:latest（镜像名称:镜像标签）</code>。</p>
<p><strong>注：最后的 .
代表本次执行的上下文路径，下一节会介绍。</strong></p>
<p><img data-src="image-20200718201119692.png" /></p>
<p>以上说明已经构建成功。</p>
<h4 id="上下文路径">上下文路径</h4>
<p>上面提到 <strong>.</strong>
是上下文路径，那么什么是上下文路径呢？</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker build -t ubuntu:latest .</span><br></pre></td></tr></table></figure>
<p>上下文路径，是指 docker
在构建镜像，有时候想要使用到本机的文件（比如复制），docker build
命令得知这个路径后，会将路径下的所有内容打包。</p>
<blockquote>
<p>由于 docker 的运行模式是 C/S。我们本机是 C，docker 引擎是
S。实际的构建过程是在 docker
引擎下完成的，所以这个时候无法用到我们本机的文件。这就需要把我们本机的指定目录下的文件一起打包提供给
docker 引擎使用。</p>
</blockquote>
<p>如果未说明最后一个参数，那么默认上下文路径就是 Dockerfile
所在的位置。</p>
<p><strong>注意：上下文路径下不要放无用的文件，因为会一起打包发送给
docker 引擎，如果文件过多会造成过程缓慢。</strong></p>
<h3 id="指令详解">指令详解</h3>
<h4 id="copy">COPY</h4>
<p>复制指令，从上下文目录中复制文件或者目录到容器里指定路径。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">COPY [--<span class="built_in">chown</span>=&lt;user&gt;:&lt;group&gt;] &lt;源路径1&gt;...  &lt;目标路径&gt;</span><br><span class="line">COPY [--<span class="built_in">chown</span>=&lt;user&gt;:&lt;group&gt;] [<span class="string">&quot;&lt;源路径1&gt;&quot;</span>,...  <span class="string">&quot;&lt;目标路径&gt;&quot;</span>]</span><br></pre></td></tr></table></figure>
<p><strong>[--chown=:]</strong>：可选参数，用户改变复制到容器内文件的拥有者和属组。</p>
<p><strong><源路径></strong>：源文件或者源目录，这里可以是通配符表达式，其通配符规则要满足
Go 的 filepath.Match 规则。例如：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> hom* /mydir/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> hom?.txt /mydir/</span></span><br></pre></td></tr></table></figure>
<p><strong><目标路径></strong>：容器内的指定路径，该路径不用事先建好，路径不存在的话，会自动创建。</p>
<h4 id="add">ADD</h4>
<p>ADD 指令和 COPY 的使用格式一致（同样需求下，官方推荐使用
COPY）。功能也类似，不同之处如下：</p>
<ul>
<li>ADD 的优点：在执行 <strong><源文件></strong> 为 tar
压缩文件的话，压缩格式为 gzip, bzip2 以及 xz
的情况下，会自动复制并解压到 <strong><目标路径></strong>。</li>
<li>ADD 的缺点：在不解压的前提下，无法复制 tar
压缩文件。会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。具体是否使用，可以根据是否需要自动解压来决定。</li>
</ul>
<h4 id="label">LABEL</h4>
<p>LABEL 指令将元数据添加到镜像。 LABEL 是键值对。要在 LABEL
值中包含空格，请像在命令行解析中一样使用引号和反斜杠。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> <span class="string">&quot;com.example.vendor&quot;</span>=<span class="string">&quot;ACME Incorporated&quot;</span></span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> com.example.label-with-value=<span class="string">&quot;foo&quot;</span></span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> version=<span class="string">&quot;1.0&quot;</span></span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> description=<span class="string">&quot;This text illustrates \</span></span></span><br><span class="line"><span class="string"><span class="language-bash">that label-values can span multiple lines.&quot;</span></span></span><br></pre></td></tr></table></figure>
<p>当容器运行起来，可以使用如下命令查看镜像的LABEL</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker image inspect --format=<span class="string">&#x27;&#x27;</span> myimage</span><br></pre></td></tr></table></figure>
<h4 id="cmd">CMD</h4>
<p>类似于 RUN 指令，用于运行程序，但二者运行的时间点不同:</p>
<ul>
<li>CMD 在docker run 时运行。</li>
<li>RUN 是在 docker build 时运行。</li>
</ul>
<p><strong>作用</strong>：为启动的容器指定默认要运行的程序，程序运行结束，容器也就结束。CMD
指令指定的程序可被 docker run 命令行参数中指定要运行的程序所覆盖。</p>
<p><strong>注意：如果 Dockerfile 中如果存在多个 CMD
指令，仅最后一个生效。</strong></p>
<p>格式：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="language-bash"> &lt;shell 命令&gt; </span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;&lt;可执行文件或命令&gt;&quot;</span>,<span class="string">&quot;&lt;param1&gt;&quot;</span>,<span class="string">&quot;&lt;param2&gt;&quot;</span>,...] </span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;&lt;param1&gt;&quot;</span>,<span class="string">&quot;&lt;param2&gt;&quot;</span>,...]  <span class="comment"># 该写法是为 ENTRYPOINT 指令指定的程序提供默认参数</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>推荐使用第二种格式，执行过程比较明确。第一种格式实际上在运行的过程中也会自动转换成第二种格式运行，并且默认可执行文件是
sh。</p>
</blockquote>
<h4 id="entrypoint">ENTRYPOINT</h4>
<p>类似于 CMD 指令，但其不会被 <code>docker run</code>
的命令行参数指定的指令所覆盖，而且这些命令行参数会被当作参数送给
ENTRYPOINT 指令指定的程序。</p>
<p>但是, 如果运行 <code>docker run</code> 时使用了
<code>--entrypoint</code> 选项，此选项的参数可当作要运行的程序覆盖
ENTRYPOINT 指令指定的程序。</p>
<p><strong>优点</strong>：在执行 <code>docker run</code> 的时候可以指定
ENTRYPOINT 运行所需的参数。</p>
<p><strong>注意</strong>：如果 Dockerfile 中如果存在多个 ENTRYPOINT
指令，仅最后一个生效。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;&lt;executeable&gt;&quot;</span>,<span class="string">&quot;&lt;param1&gt;&quot;</span>,<span class="string">&quot;&lt;param2&gt;&quot;</span>,...]</span></span><br></pre></td></tr></table></figure>
<p>可以搭配 CMD 命令使用：一般是变参才会使用 CMD ，这里的 CMD 等于是在给
ENTRYPOINT 传参，以下示例会提到。</p>
<p>示例：</p>
<p>假设已通过 Dockerfile 构建了 <strong>nginx:test</strong> 镜像：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM nginx</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [&quot;nginx&quot;, &quot;-c&quot;] # 定参</span><br><span class="line">CMD [&quot;/etc/nginx/nginx.conf&quot;] # 变参 </span><br></pre></td></tr></table></figure>
<p>1、不传参运行</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="language-bash">  nginx:<span class="built_in">test</span></span></span><br></pre></td></tr></table></figure>
<p>容器内会默认运行以下命令，启动主进程。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nginx -c /etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure>
<p>2、传参运行</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="language-bash">  nginx:<span class="built_in">test</span> -c /etc/nginx/new.conf</span></span><br></pre></td></tr></table></figure>
<p>容器内会默认运行以下命令，启动主进程(/etc/nginx/new.conf:假设容器内已有此文件)</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nginx -c /etc/nginx/new.conf</span><br></pre></td></tr></table></figure>
<h4 id="env">ENV</h4>
<p>设置环境变量，定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。</p>
<p>格式：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ENV</span> &lt;key&gt; &lt;value&gt;</span><br><span class="line"><span class="keyword">ENV</span> &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</span><br></pre></td></tr></table></figure>
<p>以下示例设置 NODE_VERSION = 7.2.0 ， 在后续的指令中可以通过
$NODE_VERSION 引用：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ENV</span> NODE_VERSION <span class="number">7.2</span>.<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> curl -SLO <span class="string">&quot;https://nodejs.org/dist/v<span class="variable">$NODE_VERSION</span>/node-v<span class="variable">$NODE_VERSION</span>-linux-x64.tar.xz&quot;</span> \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; curl -SLO <span class="string">&quot;https://nodejs.org/dist/v<span class="variable">$NODE_VERSION</span>/SHASUMS256.txt.asc&quot;</span></span></span><br></pre></td></tr></table></figure>
<h4 id="arg">ARG</h4>
<p>构建参数，与 ENV 作用一致。不过作用域不一样。ARG 设置的环境变量仅对
Dockerfile 内有效，也就是说只有 <code>docker build</code>
的过程中有效，构建好的镜像内不存在此环境变量。</p>
<p>构建命令 <code>docker build</code> 中可以用
<code>--build-arg &lt;参数名&gt;=&lt;值&gt;</code> 来覆盖。</p>
<p>格式：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ARG</span> &lt;参数名&gt;[=&lt;默认值&gt;]</span><br></pre></td></tr></table></figure>
<h4 id="volume">VOLUME</h4>
<p>定义匿名数据卷。在启动容器时忘记挂载数据卷，会自动挂载到匿名卷。</p>
<p>作用：</p>
<ul>
<li>避免重要的数据，因容器重启而丢失，这是非常致命的。</li>
<li>避免容器不断变大。</li>
</ul>
<p>格式：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">VOLUME</span><span class="language-bash"> [<span class="string">&quot;&lt;路径1&gt;&quot;</span>, <span class="string">&quot;&lt;路径2&gt;&quot;</span>...]</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="language-bash"> &lt;路径&gt;</span></span><br></pre></td></tr></table></figure>
<p>在启动容器 docker run 的时候，我们可以通过 -v 参数修改挂载点。</p>
<p><strong>注意：</strong></p>
<ol type="1">
<li>通过<code>docker run</code>命令的<code>-v</code>标识创建的挂载点只能对创建的容器有效。</li>
<li>通过 Dockerfile 的 VOLUME
指令可以在镜像中创建挂载点，这样只要通过该镜像创建的容器都有了挂载点。</li>
<li>通过 VOLUME
指令创建的挂载点，无法指定主机上对应的目录，是自动生成的。</li>
<li><code>docker run</code>中使用
<code>--volumes-from</code>标记的镜像可以共享<strong>匿名数据卷</strong>。镜像可以是同一个镜像，也可以是不同镜像。</li>
</ol>
<h4 id="expose">EXPOSE</h4>
<p>暴露容器的端口。</p>
<p>作用：</p>
<ul>
<li>帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射。</li>
<li>在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射
EXPOSE 的端口。</li>
</ul>
<p>格式：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXPOSE</span> &lt;端口<span class="number">1</span>&gt; [&lt;端口<span class="number">2</span>&gt;...]</span><br></pre></td></tr></table></figure>
<h4 id="workdir">WORKDIR</h4>
<p>指定工作目录。用 WORKDIR
指定的工作目录，会在构建镜像的每一层中都存在。（WORKDIR
指定的工作目录，必须是提前创建好的）。</p>
<p>docker build 构建镜像过程中的，每一个 RUN
命令都是新建的一层。只有通过 WORKDIR 创建的目录才会一直存在。</p>
<p>格式：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> &lt;工作目录路径&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="user">USER</h4>
<p>用于指定执行后续命令的用户和用户组，这边只是切换后续命令执行的用户（用户和用户组必须提前已经存在）。</p>
<p>格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">USER &lt;用户名&gt;[:&lt;用户组&gt;]</span><br></pre></td></tr></table></figure>
<h4 id="healthcheck">HEALTHCHECK</h4>
<p>用于指定某个程序或者指令来监控 docker 容器服务的运行状态。</p>
<p>格式：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">HEALTHCHECK</span><span class="language-bash"> [选项] CMD &lt;命令&gt;：设置检查容器健康状况的命令</span></span><br><span class="line"><span class="keyword">HEALTHCHECK</span><span class="language-bash"> NONE：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">HEALTHCHECK</span><span class="language-bash"> [选项] CMD &lt;命令&gt; : 这边 CMD 后面跟随的命令使用，可以参考 CMD 的用法。</span></span><br></pre></td></tr></table></figure>
<h4 id="onbuild">ONBUILD</h4>
<p>用于延迟构建命令的执行。简单的说，就是 Dockerfile 里用 ONBUILD
指定的命令，在本次构建镜像的过程中不会执行（假设镜像为
test-build）。当有新的 Dockerfile 使用了之前构建的镜像 FROM test-build
，这是执行新镜像的 Dockerfile 构建时候，会执行 test-build 的 Dockerfile
里的 ONBUILD 指定的命令。</p>
<p>格式：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ONBUILD</span> &lt;其它指令&gt;</span><br></pre></td></tr></table></figure>
<h4 id="stopsignal">STOPSIGNAL</h4>
<p>设置容器退出发送到容器的信号，格式可以是<code>SIG&lt;NAME</code>，例如<code>SIGKILL</code>，或者是与内核系统调用表中的位置匹配的无符号数，例如9：即当容器被stop时，对容器中的进程执行<code>kill -9</code>命令。</p>
<p>格式：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">STOPSIGNAL</span> <span class="number">9</span></span><br></pre></td></tr></table></figure>
<p>使用docker
cli运行容器时可以使用<code>--stop-signal=9</code>进行重写。</p>
<p>使用docker-compose运行容器时可以使用如下格式进行重写：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">stop_signal:</span> <span class="string">SIGUSR1</span></span><br></pre></td></tr></table></figure>
<h4 id="shell">SHELL</h4>
<p>SHELL 指令允许覆盖用于命令的 shell 形式的默认 shell。Linux 上的默认
shell 是 ["/bin/sh", "-c"]，Windows 上是 ["cmd", "/S", "/C"]。 SHELL
指令必须以 JSON 格式写入 Dockerfile。</p>
<p>SHELL 指令在 Windows 上特别有用，其中有两种常用且完全不同的原生
shell：cmd 和 powershell，以及包括 sh 在内的备用 shell。</p>
<p>SHELL 指令可以出现多次。每个 SHELL 指令都会覆盖所有先前的 SHELL
指令，并影响所有后续指令。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHELL</span><span class="language-bash"> [<span class="string">&quot;executable&quot;</span>, <span class="string">&quot;parameters&quot;</span>]</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>初探docker(一) | docker的安装及常见命令</title>
    <url>/p/docker-tutorial-01/</url>
    <content><![CDATA[<p>本文介绍的是docker的安装及常见命令。</p>
<p><strong>摘要：</strong><a href="https://www.docker.com/">Docker</a>
是个划时代的开源项目，它彻底释放了计算虚拟化的威力，极大提高了应用的维护效率，降低了云计算应用开发的成本。使用
Docker，可以让应用的部署、测试和分发都变得前所未有的高效和轻松。</p>
<p>关键词：<strong>Docker</strong></p>
<span id="more"></span>
<h3 id="安装docker">安装Docker</h3>
<p>参考：https://mirror.nju.edu.cn/mirrorz-help/docker-ce/?mirror=NJU</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> DOWNLOAD_URL=<span class="string">&quot;https://mirrors.ustc.edu.cn/docker-ce&quot;</span></span><br><span class="line"><span class="comment"># 如您使用 curl</span></span><br><span class="line">curl -fsSL https://get.docker.com/ | sudo -E sh</span><br><span class="line"><span class="comment"># 如您使用 wget</span></span><br><span class="line">wget -O- https://get.docker.com/ | sudo -E sh</span><br></pre></td></tr></table></figure>
<h3 id="启动docker-ce">启动Docker-CE</h3>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> docker</span><br><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure>
<h3 id="解决docker-info产生的warning">解决docker info产生的Warning</h3>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#WARNING: bridge-nf-call-iptables is disabled</span></span><br><span class="line"><span class="comment">#WARNING: bridge-nf-call-ip6tables is disabled</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> &lt;&lt;<span class="string">EOF | sudo tee /etc/sysctl.d/docker.conf</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-ip6tables = 1</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-iptables = 1</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line">sudo sysctl --system</span><br></pre></td></tr></table></figure></p>
<h3 id="优雅的删除docker">优雅的删除docker</h3>
<p>Debian系：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dpkg -l | grep docker</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt remove --purge docker-ce docker-ce-cli</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf /var/lib/docker</span><br></pre></td></tr></table></figure>
<h3 id="测试-docker-是否安装正确">测试 Docker 是否安装正确</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run hello-world</span><br><span class="line">以下是输出：</span><br><span class="line">Unable to find image &#x27;hello-world:latest&#x27; locally</span><br><span class="line">latest: Pulling from library/hello-world</span><br><span class="line">d1725b59e92d: Pull complete</span><br><span class="line">Digest: sha256:0add3ace90ecb4adbf7777e9aacf18357296e799f81cabc9fde470971e499788</span><br><span class="line">Status: Downloaded newer image for hello-world:latest</span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">To generate this message, Docker took the following steps:</span><br><span class="line"> 1. The Docker client contacted the Docker daemon.</span><br><span class="line"> 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.</span><br><span class="line">    (amd64)</span><br><span class="line"> 3. The Docker daemon created a new container from that image which runs the</span><br><span class="line">    executable that produces the output you are currently reading.</span><br><span class="line"> 4. The Docker daemon streamed that output to the Docker client, which sent it</span><br><span class="line">    to your terminal.</span><br><span class="line"></span><br><span class="line">To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line"><span class="meta prompt_"> $ </span><span class="language-bash">docker run -it ubuntu bash</span></span><br><span class="line"></span><br><span class="line">Share images, automate workflows, and more with a free Docker ID:</span><br><span class="line"> https://hub.docker.com/</span><br><span class="line"></span><br><span class="line">For more examples and ideas, visit:</span><br><span class="line"> https://docs.docker.com/get-started/</span><br></pre></td></tr></table></figure>
<h3 id="获取镜像加速器">获取镜像加速器</h3>
<p><del>国内从 Docker Hub
拉取镜像有时会遇到困难，此时可以配置镜像加速器。国内很多云服务商都提供了国内加速器服务，例如：</del></p>
<p><del>- 网易云加速器
<code>https://hub-mirror.c.163.com</code></del></p>
<p><del>- 百度云加速器
<code>https://mirror.baidubce.com</code></del></p>
<p><del>- <a
href="https://cr.console.aliyun.com/cn-hangzhou/mirrors">阿里云加速器(需登录账号获取)</a></del></p>
<p><del>- DaoCloud</del></p>
<p><del>执行以下命令即可：</del></p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://f1361db2.m.daocloud.io</span><br></pre></td></tr></table></figure></p>
<h4 id="linux">Linux</h4>
<p>这里使用国内南京大学提供的镜像缓存服务：</p>
<p>参考： https://nju-mirror-help.njuer.org/dockerhub.html
https://sci.nju.edu.cn/9e/05/c30384a564741/page.htm</p>
<p>对于使用 <a
href="https://www.freedesktop.org/wiki/Software/systemd/">systemd</a>
的系统，请在 <code>/etc/docker/daemon.json</code>
中写入如下内容（如果文件不存在请新建该文件）：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  registry-mirrors<span class="punctuation">:</span> <span class="punctuation">[</span>https<span class="punctuation">:</span><span class="comment">//docker.nju.edu.cn/]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意要保证该文件符合 <strong>json</strong> 规范，否则 Docker
将不能启动。</p>
</blockquote>
<p>之后重启服务。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>
<h4 id="windows-10">Windows 10</h4>
<p>对于使用 <code>Windows 10</code> 的用户，在任务栏托盘 Docker
图标内右键菜单选择
<code>Settings</code>，打开配置窗口后在左侧导航菜单选择
<code>Docker Engine</code>，在右侧像下边一样编辑 json 文件，之后点击
<code>Apply &amp; Restart</code> 保存后 Docker
就会重启并应用配置的镜像地址了。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;registry-mirrors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;https://docker.nju.edu.cn/&quot;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;insecure-registries&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;debug&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;experimental&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p><img data-src="image-20200718170304988.png" /></p>
<h3 id="常见docker命令">常见docker命令</h3>
<h4 id="取回容器">取回容器</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull fly97/v2fly</span><br></pre></td></tr></table></figure>
<h4 id="运行容器">运行容器</h4>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -d --name v2fly -v /etc/caddy:/etc/caddy  -p 443:443 fly97/v2fly</span><br></pre></td></tr></table></figure>
<blockquote>
<p>-v
：启用目录挂载。冒号":"前面的目录是<strong>宿主机目录</strong>，后面的目录是<strong>容器内目录</strong>。</p>
<p>-p：启用端口映射。</p>
<p>-d：在后台运行容器并打印容器ID。</p>
<p>--restart=always：保证每次docker服务重启后容器也自动重启</p>
<p>--network</p>
</blockquote>
<p>​ 如果容器已经启动了而又想设置容器自动启动：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker update --restart=always &lt;CONTAINER ID/CONTAINER NAME&gt;</span><br></pre></td></tr></table></figure>
<h4 id="进入容器">进入容器</h4>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it $(docker ps| grep fly97/v2fly | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span> /bin/sh</span><br></pre></td></tr></table></figure>
<blockquote>
<p>-i： 交互式操作。</p>
<p>-t：启用终端运行。</p>
<p>/bin/sh：打开交互式 Shell</p>
</blockquote>
<h4 id="查看当前运行的容器">查看当前运行的容器</h4>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker ps </span><br></pre></td></tr></table></figure>
<h4 id="运行容器-1">运行容器</h4>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker start CONTAINER_NAME</span><br></pre></td></tr></table></figure>
<h4 id="停止容器">停止容器</h4>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker stop CONTAINER_NAME</span><br></pre></td></tr></table></figure>
<h4 id="删除容器">删除容器</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker rm CONTAINER_NAME</span><br></pre></td></tr></table></figure>
<h4 id="查看镜像">查看镜像</h4>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>
<h4 id="删除镜像">删除镜像</h4>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker rmi IMAGE_ID</span><br></pre></td></tr></table></figure>
<h4 id="清理镜像">清理镜像</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker image prune</span><br></pre></td></tr></table></figure>
<h4 id="全部命令">全部命令</h4>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\wf09\Desktop\v2fly<span class="literal">-docker</span>&gt; docker <span class="literal">--help</span></span><br><span class="line"></span><br><span class="line">Usage:  docker [<span class="type">OPTIONS</span>] COMMAND</span><br><span class="line"></span><br><span class="line">A self<span class="literal">-sufficient</span> runtime <span class="keyword">for</span> containers</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">      <span class="literal">--config</span> string      Location of client config files (default</span><br><span class="line">                           <span class="string">&quot;C:\\Users\\wf09\\.docker&quot;</span>)</span><br><span class="line">  <span class="literal">-c</span>, <span class="literal">--context</span> string     Name of the context to use to connect to the</span><br><span class="line">                           daemon (overrides DOCKER_HOST env var and</span><br><span class="line">                           default context <span class="built_in">set</span> with <span class="string">&quot;docker context use&quot;</span>)</span><br><span class="line">  <span class="literal">-D</span>, <span class="literal">--debug</span>              Enable debug mode</span><br><span class="line">  <span class="literal">-H</span>, <span class="literal">--host</span> list          Daemon socket(s) to connect to</span><br><span class="line">  <span class="literal">-l</span>, <span class="literal">--log-level</span> string   <span class="built_in">Set</span> the logging level</span><br><span class="line">                           (<span class="string">&quot;debug&quot;</span>|<span class="string">&quot;info&quot;</span>|<span class="string">&quot;warn&quot;</span>|<span class="string">&quot;error&quot;</span>|<span class="string">&quot;fatal&quot;</span>)</span><br><span class="line">                           (default <span class="string">&quot;info&quot;</span>)</span><br><span class="line">      <span class="literal">--tls</span>                Use TLS; implied by <span class="literal">--tlsverify</span></span><br><span class="line">      <span class="literal">--tlscacert</span> string   Trust certs signed only by this CA (default</span><br><span class="line">                           <span class="string">&quot;C:\\Users\\wf09\\.docker\\ca.pem&quot;</span>)</span><br><span class="line">      <span class="literal">--tlscert</span> string     Path to TLS certificate file (default</span><br><span class="line">                           <span class="string">&quot;C:\\Users\\wf09\\.docker\\cert.pem&quot;</span>)</span><br><span class="line">      <span class="literal">--tlskey</span> string      Path to TLS key file (default</span><br><span class="line">                           <span class="string">&quot;C:\\Users\\wf09\\.docker\\key.pem&quot;</span>)</span><br><span class="line">      <span class="literal">--tlsverify</span>          Use TLS and verify the remote</span><br><span class="line">  <span class="literal">-v</span>, <span class="literal">--version</span>            Print version information and quit</span><br><span class="line"></span><br><span class="line">Management Commands:</span><br><span class="line">  builder     Manage builds</span><br><span class="line">  config      Manage Docker configs</span><br><span class="line">  container   Manage containers</span><br><span class="line">  context     Manage contexts</span><br><span class="line">  image       Manage images</span><br><span class="line">  network     Manage networks</span><br><span class="line">  node        Manage Swarm nodes</span><br><span class="line">  plugin      Manage plugins</span><br><span class="line">  secret      Manage Docker secrets</span><br><span class="line">  service     Manage services</span><br><span class="line">  stack       Manage Docker stacks</span><br><span class="line">  swarm       Manage Swarm</span><br><span class="line">  system      Manage Docker</span><br><span class="line">  trust       Manage trust on Docker images</span><br><span class="line">  volume      Manage volumes</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  attach      Attach local standard input, output, and error streams to a running container</span><br><span class="line">  build       Build an image from a Dockerfile</span><br><span class="line">  commit      Create a new image from a container<span class="string">&#x27;s changes</span></span><br><span class="line"><span class="string">  cp          Copy files/folders between a container and the local filesystem</span></span><br><span class="line"><span class="string">  create      Create a new container</span></span><br><span class="line"><span class="string">  diff        Inspect changes to files or directories on a container&#x27;</span>s filesystem</span><br><span class="line">  events      Get real time events from the server</span><br><span class="line">  exec        Run a command <span class="keyword">in</span> a running container</span><br><span class="line">  export      Export a container<span class="string">&#x27;s filesystem as a tar archive</span></span><br><span class="line"><span class="string">  history     Show the history of an image</span></span><br><span class="line"><span class="string">  images      List images</span></span><br><span class="line"><span class="string">  import      Import the contents from a tarball to create a filesystem image</span></span><br><span class="line"><span class="string">  info        Display system-wide information</span></span><br><span class="line"><span class="string">  inspect     Return low-level information on Docker objects</span></span><br><span class="line"><span class="string">  kill        Kill one or more running containers</span></span><br><span class="line"><span class="string">  load        Load an image from a tar archive or STDIN</span></span><br><span class="line"><span class="string">  login       Log in to a Docker registry</span></span><br><span class="line"><span class="string">  logout      Log out from a Docker registry</span></span><br><span class="line"><span class="string">  logs        Fetch the logs of a container</span></span><br><span class="line"><span class="string">  pause       Pause all processes within one or more containers</span></span><br><span class="line"><span class="string">  port        List port mappings or a specific mapping for the container</span></span><br><span class="line"><span class="string">  ps          List containers</span></span><br><span class="line"><span class="string">  pull        Pull an image or a repository from a registry</span></span><br><span class="line"><span class="string">  push        Push an image or a repository to a registry</span></span><br><span class="line"><span class="string">  rename      Rename a container</span></span><br><span class="line"><span class="string">  restart     Restart one or more containers</span></span><br><span class="line"><span class="string">  rm          Remove one or more containers</span></span><br><span class="line"><span class="string">  rmi         Remove one or more images</span></span><br><span class="line"><span class="string">  run         Run a command in a new container</span></span><br><span class="line"><span class="string">  save        Save one or more images to a tar archive (streamed to STDOUT by default)</span></span><br><span class="line"><span class="string">  search      Search the Docker Hub for images</span></span><br><span class="line"><span class="string">  start       Start one or more stopped containers</span></span><br><span class="line"><span class="string">  stats       Display a live stream of container(s) resource usage statistics</span></span><br><span class="line"><span class="string">  stop        Stop one or more running containers</span></span><br><span class="line"><span class="string">  tag         Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE</span></span><br><span class="line"><span class="string">  top         Display the running processes of a container</span></span><br><span class="line"><span class="string">  unpause     Unpause all processes within one or more containers</span></span><br><span class="line"><span class="string">  update      Update configuration of one or more containers</span></span><br><span class="line"><span class="string">  version     Show the Docker version information</span></span><br><span class="line"><span class="string">  wait        Block until one or more containers stop, then print their exit codes</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Run &#x27;</span>docker COMMAND <span class="literal">--help</span><span class="string">&#x27; for more information on a command.</span></span><br></pre></td></tr></table></figure>
<h3 id="解决docker使用sudo的问题">解决docker使用sudo的问题</h3>
<h4 id="创建docker组">创建docker组</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo groupadd docker</span><br></pre></td></tr></table></figure>
<h4 id="将当前用户加入docker组">将当前用户加入docker组</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo gpasswd -a <span class="variable">$&#123;USER&#125;</span> docker</span><br></pre></td></tr></table></figure>
<h4 id="重启服务">重启服务</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo service docker restart</span><br></pre></td></tr></table></figure>
<h4 id="刷新docker组成员">刷新docker组成员</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">newgrp - docker</span><br></pre></td></tr></table></figure>
<h3
id="构建docker镜像时处理configuring-tzdata交互输入">构建Docker镜像时处理'Configuring
tzdata'交互输入</h3>
<p>将tzdata设置为非交互方式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ENV DEBIAN_FRONTEND=noninteractive</span><br></pre></td></tr></table></figure>
<h3
id="docker容器内使用dpkg安装chrome浏览器失败">docker容器内使用dpkg安装chrome浏览器失败</h3>
<p>使用<code>apt</code>离线安装即可，会自动帮你安装依赖</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb</span><br><span class="line">apt install -f ./google-chrome-stable_current_amd64.deb</span><br></pre></td></tr></table></figure>
<h3 id="docker-访问外部-https-的数字证书验证问题">docker 访问外部 https
的数字证书验证问题</h3>
<ol type="1">
<li><p>alpine linux</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk --no-cache add ca-certificates \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; update-ca-certificates</span></span><br></pre></td></tr></table></figure></li>
<li><p>ubuntu linux</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">RUN apt-get install ca-certificates -y \</span><br><span class="line">  &amp;&amp; update-ca-certificates</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="修改docker时区">修改docker时区</h3>
<ol type="1">
<li><p>挂载宿主机时区文件 到容器内<code>/etc/localtime</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">- /usr/share/zoneinfo/Asia/Shanghai:/etc/localtime</span><br></pre></td></tr></table></figure></li>
<li><p>debian类镜像构建时指定环境变量</p>
<ol type="1">
<li>容器安装tzdata</li>
</ol>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install -f tzdata</span></span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>使用对应时区的环境变量</li>
</ol>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ENV</span> TZ=<span class="string">&quot;Asia/Shanghai&quot;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="docker-inspect命令">docker inspect命令</h3>
<h4 id="查看容器状态">查看容器状态</h4>
<p>首先运行<code>docker inspect</code>查看容器信息</p>
<p><img data-src="image-20220513100039060.png" /></p>
<p>可以获取以下容器状态</p>
<h5 id="查看容器是否正常运行">查看容器是否正常运行</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker inspect --format <span class="string">&#x27;&#123;&#123;.State.Status&#125;&#125;&#x27;</span> summary</span><br></pre></td></tr></table></figure>
<h5 id="查看容器是否正在重启">查看容器是否正在重启</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker inspect --format <span class="string">&#x27;&#123;&#123;.State.Restarting&#125;&#125;&#x27;</span> summary</span><br></pre></td></tr></table></figure>
<h4 id="查看容器日志存放路径">查看容器日志存放路径</h4>
<p>某些情况下需要删除日志文件路径，因此可以通过这个命令查看。查看定义日志的字段：</p>
<p><img data-src="image-20220513100947538.png" /></p>
<p>运行以下命令获取日志的地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker inspect --format <span class="string">&#x27;&#123;&#123;.LogPath&#125;&#125;&#x27;</span> summary</span><br></pre></td></tr></table></figure>
<p>然后在操作就好了</p>
<h3 id="设置容器日志大小">设置容器日志大小</h3>
<p>一般情况下Docker容器业务日志很大，处理起来不是很方便</p>
<h4 id="指定容器">指定容器</h4>
<p>docker-compose</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">    <span class="attr">summary:</span>        </span><br><span class="line">        <span class="attr">logging:</span></span><br><span class="line">            <span class="attr">driver:</span> <span class="string">&quot;json-file&quot;</span> <span class="comment"># 日志驱动</span></span><br><span class="line">            <span class="attr">options:</span></span><br><span class="line">                <span class="attr">max-size:</span> <span class="string">&quot;50m&quot;</span> <span class="comment">#[0-9+][k|m|g] 【文件的大小】</span></span><br><span class="line">                <span class="attr">max-file:</span> <span class="string">&quot;3&quot;</span>   <span class="comment">#[0-9+] 【文件数量】</span></span><br></pre></td></tr></table></figure>
<p>docker cli</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">--log-driver json-file            <span class="comment">#日志驱动</span></span><br><span class="line">--log-opt max-size=[0-9+][k|m|g]  <span class="comment">#文件的大小</span></span><br><span class="line">--log-opt max-file=[0-9+]          <span class="comment">#文件数量</span></span><br></pre></td></tr></table></figure>
<h4 id="全局设置">全局设置</h4>
<p>编辑文件<code>/etc/docker/daemon.json</code>，增加以下日志的配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;log-driver&quot;</span>:<span class="string">&quot;json-file&quot;</span>,</span><br><span class="line">    <span class="string">&quot;log-opts&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;max-size&quot;</span>:<span class="string">&quot;500m&quot;</span>,</span><br><span class="line">        <span class="string">&quot;max-file&quot;</span>:<span class="string">&quot;3&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="手动安装docker">手动安装Docker</h3>
<p>指定私有仓库的方式安装Docker</p>
<p>安装curl</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install curl -y</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> -p /etc/apt/keyrings</span><br><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg</span><br><span class="line"><span class="built_in">echo</span> \</span><br><span class="line">  <span class="string">&quot;deb [arch=<span class="subst">$(dpkg --print-architecture)</span> signed-by=/etc/apt/keyrings/docker.gpg] https://repo.deepsoft-tech.com/repository/docker-apt \</span></span><br><span class="line"><span class="string">  <span class="subst">$(lsb_release -cs)</span> stable&quot;</span> | sudo <span class="built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br></pre></td></tr></table></figure>
<p>安装docker-ce</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin -y</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>使用jsdelivrCDN加速github文件</title>
    <url>/p/Use-jsdelivrCDN-to-accelerate-github-files/</url>
    <content><![CDATA[<p>jsDelivr 是国外的一家优秀的公共 CDN
服务提供商，也是首个「打通中国大陆（网宿公司运营）与海外的免费 CDN
服务」。</p>
<p><strong>更新：</strong>jsDelivr新增使用政策已经于8月15日生效。根据最新的使用政策，<strong>滥用服务及其资源或将jsDelivr用作通用文件或媒体托管服务，账户将会被BAN。</strong></p>
<p>如果将Github+jsDelivr作为图床使用的话是算违规！！！
相关链接：https://www.jsdelivr.com/terms/acceptable-use-policy-jsdelivr-net</p>
<span id="more"></span>
<h3 id="jsdelivr-配置">jsDelivr 配置</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://cdn.jsdelivr.net/gh/wf09/upload@master/1.png</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li><code>gh</code> 表示来自 Github 的仓库</li>
<li><code>wf09/upload</code> 指的是用户名/仓库名</li>
<li><code>master</code> 仓库的分支</li>
<li><code>1.png</code>仓库下的具体文件</li>
</ul>
]]></content>
      <tags>
        <tag>github</tag>
        <tag>jsdelivrCDN</tag>
      </tags>
  </entry>
  <entry>
    <title>使用WSL链接Github仓库</title>
    <url>/p/Use-WSL-to-link-Github-repositories/</url>
    <content><![CDATA[<p>话不多说，先上教程。</p>
<span id="more"></span>
<h4
id="首先要安装wslwindows-subsystem-for-linux即适用于window10的linux子系统">1.首先，要安装WSL(Windows
Subsystem for Linux)。即适用于Window10的Linux子系统。</h4>
<ul>
<li><p>打开开发者选项，选择开发人员模式。<img data-src="image-20191228201007723.png" /></p></li>
<li><p>打开控制面板-程序，选择适用于Linux的Windows子系统。<img data-src="image-20191228201255121.png" /></p></li>
<li><p>打开Windows应用商店，搜索linux，选择你喜欢的linux系统点击安装。这里以Ubuntu为例。</p>
<p><img data-src="20200531102849.png" /></p></li>
</ul>
<p>第一次打开要选择用户名和密码，因为笔者已经安装完了，这里就不再截图了。到此为止WSL就安装好了。</p>
<h4
id="使用wsl安装hexo相关软件并链接到github仓库">2.使用WSL安装hexo相关软件并链接到github仓库</h4>
<p>打开刚刚安装好的Ubuntu，输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install git</span><br></pre></td></tr></table></figure>
<h5 id="初始化git">初始化git：</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//进入项目</span><br><span class="line">cd Desktop/myproject</span><br><span class="line">//初始化git</span><br><span class="line"> git init</span><br></pre></td></tr></table></figure>
<h5 id="创建ssh-key">创建ssh key：</h5>
<p>为了让github能够识别是我们自己上传文件，需要创建ssh key</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;your_email@youremail.com&quot;</span><br></pre></td></tr></table></figure>
<p>这里的<strong>your_email@youremail.com</strong>是你的<strong>邮箱地址</strong>，在输入后会询问你是否保存创建的ssh
key，点回车就好，然后要求输入你要设置的密码，如果直接回车表示不设密码。然后会提示你ssh
key已经创建好。</p>
<h5 id="把密码导入github">把密码导入GitHub：</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>
<p>此时在终端会显示出刚刚创建好的ssh
key，复制出来，在github在点击头像，然后点击setting，在找到SSH and GPG
keys，创建一个new ssh key，然后将刚刚复制的ssh key填入即可。</p>
<h5 id="验证是否连接成功">验证是否连接成功：</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>
<p>如果回车看到：<strong>You’ve successfully authenticated, but GitHub
does not provide shell access</strong> 。表示已成功连上github。</p>
<h5 id="设置username和email">设置username和email：</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;your name&quot;</span><br><span class="line">git config --global user.email &quot;your_email@youremail.com&quot;</span><br></pre></td></tr></table></figure>
<h5 id="添加远程地址">添加远程地址：</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote add origin git@github.com:yourName/yourRepo.git</span><br></pre></td></tr></table></figure>
<p>后面的yourName和yourRepo分别是你的github的用户名和刚才新建的仓库名。</p>
<h5 id="上传项目">上传项目：</h5>
<p>依次运行以下命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git status</span><br><span class="line">git add .</span><br><span class="line">git commit -m &#x27;my project push&#x27;</span><br><span class="line">git push origin master  --force</span><br></pre></td></tr></table></figure>
<p>这里的<strong>master</strong>指的是主分支名，如果是其他分支，则填写相应的分支名。</p>
<p>这样我们就将我们的项目上传到github仓库。</p>
<h5 id="备注私钥和公钥的权限问题">备注：私钥和公钥的权限问题</h5>
<p>确认将 SSH 权限应用于公钥和私钥文件。</p>
<ol type="1">
<li><p>通过运行以下命令来检查 SSH
公钥文件：<code>ls -l /etc/ssh/*key.pub</code></p></li>
<li><p>确认所有者是 root，组所有者是 root，并且文件权限设置为 0644
(-rw-r--r--)。</p></li>
<li><p>通过运行以下命令来修复任何问题。</p>
<p><code>chown root /etc/ssh/*key.pub</code></p>
<p><code>chgrp root /etc/ssh/*key.pub</code></p>
<p><code>chmod 644 /etc/ssh/*key.pub</code></p></li>
<li><p>通过运行以下命令来检查 SSH
私钥文件：<code>ls -l /etc/ssh/*key</code></p></li>
<li><p>通过运行以下命令来修复任何问题。</p>
<p><code>chown root /etc/ssh/*key</code></p>
<p><code>chgrp root /etc/ssh/*key</code></p>
<p><code>chmod 644 /etc/ssh/*key</code></p></li>
</ol>
]]></content>
      <tags>
        <tag>WSL</tag>
      </tags>
  </entry>
  <entry>
    <title>Office Tool Plus使用教程</title>
    <url>/p/how-to-use-office-tool-plus/</url>
    <content><![CDATA[<p>Office Tool Plus 使用教程</p>
<span id="more"></span>
<p>软件介绍：https://otp.landian.vip/zh-cn/</p>
<p>软件下载地址：https://download.coolhub.top/</p>
<p><del>备份地址：https://ftp.fly97.cn/windows/app/Office%20Tool%20v7.5.zip</del></p>
<h4 id="选择安装产品">1.选择安装产品</h4>
<p><img data-src="image-20200517194431639.png" /></p>
<p>注意：由于国内到微软的网络不稳定，建议<strong>部署模式</strong>选择<strong>下载后安装</strong>。耐心等待安装完毕即可。</p>
<h4 id="激活office">2.激活office</h4>
<p>首先，根据选择的类型选择对应的许可证。</p>
<p><img data-src="image-20200517194323507.png" /></p>
<p><del>然后，选择<strong>零售版</strong>安装的同学<strong>可能需要安装</strong>Office2019专业版特定的密钥：</del></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">NMMKJ-6RK4F-KMJVX-8D9MJ-6MWKP</span><br></pre></td></tr></table></figure>
<p>最后，选择对应的KMS服务器。</p>
<p>推荐使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kms.moeclub.org</span><br></pre></td></tr></table></figure>
<p>完。</p>
]]></content>
      <tags>
        <tag>office</tag>
      </tags>
  </entry>
  <entry>
    <title>Crontab定时任务</title>
    <url>/p/how-to-use-crontab/</url>
    <content><![CDATA[<p>Linux中的crontab - - - -一个自定义定时器</p>
<span id="more"></span>
<h2 id="crontab命令">crontab命令</h2>
<p>重新指定crobtab定时任务文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">crontab $filepath</span><br></pre></td></tr></table></figure>
<p>查看crontab定时任务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">crontab -l</span><br></pre></td></tr></table></figure>
<p>编辑、安装定时任务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">crontab -e</span><br></pre></td></tr></table></figure>
<p>指定用户abc执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">crontab -u abc</span><br></pre></td></tr></table></figure>
<p>删除用户</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">crontab -r</span><br></pre></td></tr></table></figure>
<h2 id="crontab举例">Crontab举例</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">每天早上6点</span> </span><br><span class="line">0 6 * * * echo &quot;Good morning.&quot; &gt;&gt; /tmp/test.txt //注意单纯echo，从屏幕上看不到任何输出，因为cron把任何输出都email到root的信箱了。</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">每两个小时</span> </span><br><span class="line">0 */2 * * * echo &quot;Have a break now.&quot; &gt;&gt; /tmp/test.txt  </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">晚上11点到早上8点之间每两个小时和早上八点</span> </span><br><span class="line">0 23-7/2，8 * * * echo &quot;Have a good dream&quot; &gt;&gt; /tmp/test.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">每个月的4号和每个礼拜的礼拜一到礼拜三的早上11点</span> </span><br><span class="line">0 11 4 * 1-3 command line</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1月1日早上4点</span> </span><br><span class="line">0 4 1 1 * command line SHELL=/bin/bash PATH=/sbin:/bin:/usr/sbin:/usr/bin MAILTO=root //如果出现错误，或者有数据输出，数据作为邮件发给这个帐号 HOME=/ </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">每小时（第一分钟）执行/etc/cron.hourly内的脚本</span></span><br><span class="line">01 * * * * root run-parts /etc/cron.hourly</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">每天（凌晨4：02）执行/etc/cron.daily内的脚本</span></span><br><span class="line">02 4 * * * root run-parts /etc/cron.daily </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">每星期（周日凌晨4：22）执行/etc/cron.weekly内的脚本</span></span><br><span class="line">22 4 * * 0 root run-parts /etc/cron.weekly </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">每月（1号凌晨4：42）去执行/etc/cron.monthly内的脚本</span> </span><br><span class="line">42 4 1 * * root run-parts /etc/cron.monthly </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注意:  <span class="string">&quot;run-parts&quot;</span>这个参数了，如果去掉这个参数的话，后面就可以写要运行的某个脚本名，而不是文件夹名。</span> 　 </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">每天的下午4点、5点、6点的5 min、15 min、25 min、35 min、45 min、55 min时执行命令。</span> </span><br><span class="line">5，15，25，35，45，55 16，17，18 * * * command</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">每周一，三，五的下午3：00系统进入维护状态，重新启动系统。</span></span><br><span class="line">00 15 * *1，3，5 shutdown -r +5</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">每小时的10分，40分执行用户目录下的innd/bbslin这个指令：</span> </span><br><span class="line">10，40 * * * * innd/bbslink </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">每小时的1分执行用户目录下的bin/account这个指令：</span> </span><br><span class="line">1 * * * * bin/account</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">每1分钟执行以下命令</span></span><br><span class="line">*/1 * * * * bin/python</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">每天早晨三点二十分执行用户目录下如下所示的两个指令（每个指令以;分隔）：</span> </span><br><span class="line">203 * * * （/bin/rm -f expire.ls logins.bad;bin/expire$#@62;expire.1st）　</span><br></pre></td></tr></table></figure>
<h2 id="crontab-任务举例">Crontab 任务举例</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">*/5 * * * * /bin/bash /root/kaoyan/tiaoji.sh</span><br></pre></td></tr></table></figure>
<h3 id="sh写法举例">sh写法举例</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin</span><br><span class="line">export PATH</span><br><span class="line"></span><br><span class="line">cd /root/kaoyan</span><br><span class="line">/root/***/python3 *.py &gt;&gt; /root/****/*.log 2&gt;&amp;1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将所有输出写入日志文件</span></span><br></pre></td></tr></table></figure>
<h2 id="crontab训练">Crontab训练</h2>
<p>crontab 分 时 日 月 周</p>
<p>每分钟执行一次命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">* * * * * <span class="built_in">echo</span> <span class="string">&quot;hello&quot;</span></span><br></pre></td></tr></table></figure>
<p><strong>每隔2分钟执行</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">*/2 * * * * <span class="built_in">echo</span> <span class="string">&quot;hello&quot;</span></span><br></pre></td></tr></table></figure>
<p>每小时的第二分钟执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2 * * * * <span class="built_in">echo</span> <span class="string">&quot;hello&quot;</span></span><br></pre></td></tr></table></figure>
<p>每天的1点内每分钟执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">* 1 * * * <span class="built_in">echo</span> <span class="string">&quot;hello&quot;</span></span><br></pre></td></tr></table></figure>
<p>每小时的5-10分钟执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">5-10 * * * * <span class="built_in">echo</span> <span class="string">&quot;hello&quot;</span></span><br></pre></td></tr></table></figure>
<p>每小时的第5分钟、第十分钟执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">5,10 * * * * <span class="built_in">echo</span> <span class="string">&quot;hello&quot;</span></span><br></pre></td></tr></table></figure>
<p><strong>每小时10到20分钟内每隔2分钟执行一次</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">10-20/2 * * * * <span class="built_in">echo</span> <span class="string">&quot;hello&quot;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>crontab</tag>
      </tags>
  </entry>
  <entry>
    <title>使用acme.sh快速申请ssl证书</title>
    <url>/p/Use-acme-to-quickly-apply-for-an-ssl-certificate/</url>
    <content><![CDATA[<p><strong>acme.sh</strong> 实现了 <code>acme</code> 协议, 可以从
letsencrypt 生成免费的证书.</p>
<p><strong>转载自：<a
href="https://github.com/acmesh-official/acme.sh/wiki/说明">https://github.com/acmesh-official/acme.sh/wiki/%E8%AF%B4%E6%98%8E</a></strong></p>
<span id="more"></span>
<p>主要步骤:</p>
<ol type="1">
<li>安装 <strong>acme.sh</strong></li>
<li>生成证书</li>
<li>copy 证书到 nginx/apache 或者其他服务</li>
<li>更新证书</li>
<li>更新 <strong>acme.sh</strong></li>
<li>出错怎么办, 如何调试</li>
</ol>
<p>下面详细介绍.</p>
<h4 id="安装-acme.sh">安装 <strong>acme.sh</strong></h4>
<p>安装很简单, 一个命令： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl  https://get.acme.sh | sh</span><br></pre></td></tr></table></figure></p>
<p>普通用户和 root 用户都可以安装使用. 安装过程进行了以下几步:</p>
<ol type="1">
<li>把 acme.sh 安装到你的 <strong>home</strong> 目录下:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~/.acme.sh/</span><br></pre></td></tr></table></figure>
<p>并创建 一个 bash 的 alias, 方便你的使用:
<code>alias acme.sh=~/.acme.sh/acme.sh</code></p>
<p>2). 自动为你创建 cronjob, 每天 0:00 点自动检测所有的证书,
如果快过期了, 需要更新, 则会自动更新证书.</p>
<p>更高级的安装选项请参考:
https://github.com/Neilpang/acme.sh/wiki/How-to-install</p>
<p><strong>安装过程不会污染已有的系统任何功能和文件</strong>,
所有的修改都限制在安装目录中: <code>~/.acme.sh/</code></p>
<h4 id="生成证书">生成证书</h4>
<p><strong>acme.sh</strong> 实现了 <strong>acme</strong>
协议支持的所有验证协议. 一般有两种方式验证: http 和 dns 验证.</p>
<h5
id="http-方式需要在你的网站根目录下放置一个文件-来验证你的域名所有权完成验证.-然后就可以生成证书了.">http
方式需要在你的网站根目录下放置一个文件, 来验证你的域名所有权,完成验证.
然后就可以生成证书了.</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">acme.sh  --issue  -d mydomain.com -d www.mydomain.com  --webroot  /home/wwwroot/mydomain.com/</span><br></pre></td></tr></table></figure>
<p>只需要指定域名, 并指定域名所在的网站根目录. <strong>acme.sh</strong>
会全自动的生成验证文件, 并放到网站的根目录, 然后自动完成验证.
最后会聪明的删除验证文件. 整个过程没有任何副作用.</p>
<p>如果你用的 <strong>apache</strong>服务器, <strong>acme.sh</strong>
还可以智能的从 <strong>apache</strong>的配置中自动完成验证,
你不需要指定网站根目录: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">acme.sh --issue  -d mydomain.com   --apache</span><br></pre></td></tr></table></figure></p>
<p>如果你用的 <strong>nginx</strong>服务器, 或者反代,
<strong>acme.sh</strong> 还可以智能的从
<strong>nginx</strong>的配置中自动完成验证, 你不需要指定网站根目录:
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">acme.sh --issue  -d mydomain.com   --nginx</span><br></pre></td></tr></table></figure></p>
<p><strong>注意, 无论是 apache 还是 nginx 模式, acme.sh在完成验证之后,
会恢复到之前的状态, 都不会私自更改你本身的配置.
好处是你不用担心配置被搞坏, 也有一个缺点, 你需要自己配置 ssl 的配置,
否则只能成功生成证书, 你的网站还是无法访问https. 但是为了安全,
你还是自己手动改配置吧.</strong></p>
<p>如果你还没有运行任何 web 服务, <strong>80</strong> 端口是空闲的, 那么
<strong>acme.sh</strong> 还能假装自己是一个webserver,
临时听在<strong>80</strong> 端口, 完成验证:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">acme.sh  --issue -d mydomain.com   --standalone</span><br></pre></td></tr></table></figure>
<p>更高级的用法请参考:
https://github.com/Neilpang/acme.sh/wiki/How-to-issue-a-cert</p>
<h5
id="手动-dns-方式-手动在域名上添加一条-txt-解析记录-验证域名所有权.">手动
dns 方式, 手动在域名上添加一条 txt 解析记录, 验证域名所有权.</h5>
<p>这种方式的好处是, 你不需要任何服务器, 不需要任何公网 ip, 只需要 dns
的解析记录即可完成验证. 坏处是，如果不同时配置 Automatic DNS
API，使用这种方式 acme.sh
将无法自动更新证书，每次都需要手动再次重新解析验证域名所有权。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">acme.sh  --issue  --dns   -d mydomain.com</span><br></pre></td></tr></table></figure>
<p>然后, <strong>acme.sh</strong> 会生成相应的解析记录显示出来,
你只需要在你的域名管理面板中添加这条 txt 记录即可.</p>
<p>等待解析完成之后, 重新生成证书: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">acme.sh  --renew   -d mydomain.com</span><br></pre></td></tr></table></figure> 注意第二次这里用的是
<code>--renew</code></p>
<p>dns 方式的真正强大之处在于可以使用域名解析商提供的 api 自动添加 txt
记录完成验证.</p>
<p><strong>acme.sh</strong> 目前支持 cloudflare, dnspod, cloudxns,
godaddy 以及 ovh 等数十种解析商的自动集成.</p>
<p>以 dnspod 为例, 你需要先登录到 dnspod 账号, 生成你的 api id 和 api
key, 都是免费的. 然后: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export DP_Id=&quot;1234&quot;</span><br><span class="line"></span><br><span class="line">export DP_Key=&quot;sADDsdasdgdsf&quot;</span><br><span class="line"></span><br><span class="line">acme.sh   --issue   --dns dns_dp   -d aa.com  -d www.aa.com</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>证书就会自动生成了. 这里给出的 api id 和 api key 会被自动记录下来,
将来你在使用 dnspod api 的时候, 就不需要再次指定了. 直接生成就好了:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">acme.sh  --issue   -d  mydomain2.com   --dns  dns_dp</span><br></pre></td></tr></table></figure>
<p>更详细的 api 用法:
https://github.com/Neilpang/acme.sh/blob/master/dnsapi/README.md</p>
<h4 id="copy安装-证书">copy/安装 证书</h4>
<p>前面证书生成以后, 接下来需要把证书 copy 到真正需要用它的地方.</p>
<p>注意, 默认生成的证书都放在安装目录下: <code>~/.acme.sh/</code>,
请不要直接使用此目录下的文件, 例如: 不要直接让 nginx/apache
的配置文件使用这下面的文件. 这里面的文件都是内部使用,
而且目录结构可能会变化.</p>
<p>正确的使用方法是使用 <code>--installcert</code> 命令,并指定目标位置,
然后证书文件会被copy到相应的位置, 例如: ##### Apache example:
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">acme.sh --installcert -d example.com \</span><br><span class="line">--cert-file      /path/to/certfile/in/apache/cert.pem  \</span><br><span class="line">--key-file       /path/to/keyfile/in/apache/key.pem  \</span><br><span class="line">--fullchain-file /path/to/fullchain/certfile/apache/fullchain.pem \</span><br><span class="line">--reloadcmd     &quot;service apache2 force-reload&quot;</span><br></pre></td></tr></table></figure></p>
<h5 id="nginx-example">Nginx example:</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">acme.sh --installcert -d example.com \</span><br><span class="line">--key-file       /path/to/keyfile/in/nginx/key.pem  \</span><br><span class="line">--fullchain-file /path/to/fullchain/nginx/cert.pem \</span><br><span class="line">--reloadcmd     &quot;service nginx force-reload&quot;</span><br></pre></td></tr></table></figure>
<p>(一个小提醒, 这里用的是 <code>service nginx force-reload</code>, 不是
<code>service nginx reload</code>, 据测试, <code>reload</code>
并不会重新加载证书, 所以用的 <code>force-reload</code>)</p>
<p>Nginx 的配置 <code>ssl_certificate</code> 使用
<code>/etc/nginx/ssl/fullchain.cer</code> ，而非
<code>/etc/nginx/ssl/&lt;domain&gt;.cer</code> ，否则 <a
href="https://www.ssllabs.com/ssltest/">SSL Labs</a> 的测试会报
<code>Chain issues Incomplete</code> 错误。</p>
<p><code>--installcert</code>命令可以携带很多参数, 来指定目标文件.
并且可以指定 reloadcmd, 当证书更新以后,
reloadcmd会被自动调用,让服务器生效.</p>
<p>详细参数请参考:
https://github.com/Neilpang/acme.sh#3-install-the-issued-cert-to-apachenginx-etc</p>
<p>值得注意的是, 这里指定的所有参数都会被自动记录下来,
并在将来证书自动更新以后, 被再次自动调用.</p>
<h4 id="更新证书">更新证书</h4>
<p>目前证书在 60 天以后会自动更新, 你无需任何操作.
今后有可能会缩短这个时间, 不过都是自动的, 你不用关心.</p>
<h4 id="更新-acme.sh">更新 acme.sh</h4>
<p>目前由于 acme 协议和 letsencrypt CA 都在频繁的更新, 因此 acme.sh
也经常更新以保持同步.</p>
<p>升级 acme.sh 到最新版 : <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">acme.sh --upgrade</span><br></pre></td></tr></table></figure></p>
<p>如果你不想手动升级, 可以开启自动升级:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">acme.sh  --upgrade  --auto-upgrade</span><br></pre></td></tr></table></figure>
<p>之后, acme.sh 就会自动保持更新了.</p>
<p>你也可以随时关闭自动更新:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">acme.sh --upgrade  --auto-upgrade  0</span><br></pre></td></tr></table></figure>
<h4 id="调试">调试</h4>
<p>如果出错, 请添加 debug log：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">acme.sh  --issue  .....  --debug </span><br></pre></td></tr></table></figure>
<p>或者： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">acme.sh  --issue  .....  --debug  2</span><br></pre></td></tr></table></figure></p>
<p>请参考：
https://github.com/Neilpang/acme.sh/wiki/How-to-debug-acme.sh</p>
<p>最后, 本文并非完全的使用说明, 还有很多高级的功能,
更高级的用法请参看其他 wiki 页面.</p>
<p>https://github.com/Neilpang/acme.sh/wiki</p>
]]></content>
      <tags>
        <tag>证书</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu服务管理</title>
    <url>/p/How-to-manage-services-on-ubuntu/</url>
    <content><![CDATA[<p>Linux 服务管理两种方式service和systemctl的用法</p>
<span id="more"></span>
<h4 id="service命令">service命令</h4>
<p>service命令其实是去/etc/init.d目录下，去执行相关程序。</p>
<p>其中脚本需要我们自己编写。</p>
<h5 id="基本步骤">基本步骤</h5>
<ol type="1">
<li>进入 <code>/etc/init.d</code></li>
<li>简历一个脚本文件，并赋予755权限：<code>chmod 755 文件名</code></li>
</ol>
<p>以kms服务脚本为例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### BEGIN INIT INFO</span></span><br><span class="line"><span class="comment"># Provides:          kms-service</span></span><br><span class="line"><span class="comment"># Required-Start:    $network $local_fs $remote_fs</span></span><br><span class="line"><span class="comment"># Required-Stop:     $network $local_fs $remote_fs</span></span><br><span class="line"><span class="comment"># Default-Start:     2 3 4 5</span></span><br><span class="line"><span class="comment"># Default-Stop:      0 1 6</span></span><br><span class="line"><span class="comment"># Short-Description: Start kms at boot time</span></span><br><span class="line"><span class="comment"># Description:       Start or stop the KMS-service</span></span><br><span class="line"><span class="comment">### END INIT INFO</span></span><br><span class="line"></span><br><span class="line">NAME=<span class="string">&quot;KMS&quot;</span></span><br><span class="line">NAME_BIN=<span class="string">&quot;kms&quot;</span></span><br><span class="line">FILE=<span class="string">&quot;/home/ubuntu&quot;</span></span><br><span class="line">BIN=<span class="string">&quot;<span class="variable">$&#123;FILE&#125;</span>/kms&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Green_font_prefix=<span class="string">&quot;\033[32m&quot;</span> &amp;&amp; Red_font_prefix=<span class="string">&quot;\033[31m&quot;</span> &amp;&amp; Green_background_prefix=<span class="string">&quot;\033[42;37m&quot;</span> &amp;&amp; Red_background_prefix=<span class="string">&quot;\033[41;37m&quot;</span> &amp;&amp; Font_color_suffix=<span class="string">&quot;\033[0m&quot;</span></span><br><span class="line">Info=<span class="string">&quot;<span class="variable">$&#123;Green_font_prefix&#125;</span>[信息]<span class="variable">$&#123;Font_color_suffix&#125;</span>&quot;</span></span><br><span class="line">Error=<span class="string">&quot;<span class="variable">$&#123;Red_font_prefix&#125;</span>[错误]<span class="variable">$&#123;Font_color_suffix&#125;</span>&quot;</span></span><br><span class="line">RETVAL=0</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">check_running</span></span>()&#123;</span><br><span class="line">	PID=$(ps -ef |grep <span class="string">&quot;<span class="variable">$&#123;NAME_BIN&#125;</span>&quot;</span> |grep -v <span class="string">&quot;grep&quot;</span> |grep -v <span class="string">&quot;init.d&quot;</span> |grep -v <span class="string">&quot;service&quot;</span> |awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span>)</span><br><span class="line">	<span class="keyword">if</span> [[ ! -z <span class="variable">$&#123;PID&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">		<span class="comment">#echo -e &quot;$&#123;Info&#125;$&#123;NAME&#125; 正在运行！&quot;</span></span><br><span class="line">		<span class="built_in">return</span> 0</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="comment">#echo -e &quot;$&#123;Error&#125;$&#123;NAME&#125; 没有运行！&quot;</span></span><br><span class="line">		<span class="built_in">return</span> 1</span><br><span class="line">	<span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">start</span></span>()&#123;</span><br><span class="line">	check_running</span><br><span class="line">	<span class="keyword">if</span> [[ $? -eq 0 ]]; <span class="keyword">then</span></span><br><span class="line">		<span class="built_in">echo</span> -e <span class="string">&quot;<span class="variable">$&#123;Info&#125;</span> <span class="variable">$NAME</span> (PID <span class="variable">$&#123;PID&#125;</span>) 正在运行...&quot;</span> &amp;&amp; <span class="built_in">exit</span> 0</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">cd</span> <span class="variable">$&#123;FILE&#125;</span></span><br><span class="line">		<span class="built_in">echo</span> -e <span class="string">&quot;<span class="variable">$&#123;Info&#125;</span> <span class="variable">$NAME</span> 启动中...&quot;</span></span><br><span class="line">		<span class="built_in">ulimit</span> -n 51200</span><br><span class="line">		./kms </span><br><span class="line">		<span class="built_in">sleep</span> 1s</span><br><span class="line">		check_running</span><br><span class="line">		<span class="keyword">if</span> [[ $? -eq 0 ]]; <span class="keyword">then</span></span><br><span class="line">			<span class="built_in">echo</span> -e <span class="string">&quot;<span class="variable">$&#123;Info&#125;</span> <span class="variable">$NAME</span> 启动成功 !&quot;</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">echo</span> -e <span class="string">&quot;<span class="variable">$&#123;Error&#125;</span> <span class="variable">$NAME</span> 启动失败(请运行脚本查看日志错误输出) !&quot;</span></span><br><span class="line">		<span class="keyword">fi</span></span><br><span class="line">	<span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">stop</span></span>()&#123;</span><br><span class="line">	check_running</span><br><span class="line">	<span class="keyword">if</span> [[ $? -eq 0 ]]; <span class="keyword">then</span></span><br><span class="line">		<span class="built_in">kill</span> -9 <span class="variable">$&#123;PID&#125;</span></span><br><span class="line">		RETVAL=$?</span><br><span class="line">		<span class="keyword">if</span> [[ <span class="variable">$RETVAL</span> -eq 0 ]]; <span class="keyword">then</span></span><br><span class="line">			<span class="built_in">echo</span> -e <span class="string">&quot;<span class="variable">$&#123;Info&#125;</span> <span class="variable">$NAME</span> 停止成功 !&quot;</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">echo</span> -e <span class="string">&quot;<span class="variable">$&#123;Error&#125;</span> <span class="variable">$NAME</span> 停止失败 !&quot;</span></span><br><span class="line">		<span class="keyword">fi</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">echo</span> -e <span class="string">&quot;<span class="variable">$&#123;Info&#125;</span> <span class="variable">$NAME</span> 未运行&quot;</span></span><br><span class="line">		RETVAL=1</span><br><span class="line">	<span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">status</span></span>()&#123;</span><br><span class="line">	check_running</span><br><span class="line">	<span class="keyword">if</span> [[ $? -eq 0 ]]; <span class="keyword">then</span></span><br><span class="line">		<span class="comment">#View_User</span></span><br><span class="line">		<span class="built_in">echo</span> -e <span class="string">&quot;<span class="variable">$&#123;Info&#125;</span> <span class="variable">$NAME</span> (PID <span class="variable">$&#123;PID&#125;</span>) 正在运行...&quot;</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">echo</span> -e <span class="string">&quot;<span class="variable">$&#123;Info&#125;</span> <span class="variable">$NAME</span> 未运行 !&quot;</span></span><br><span class="line">		RETVAL=1</span><br><span class="line">	<span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">restart</span></span>()&#123;</span><br><span class="line">	stop</span><br><span class="line">	<span class="built_in">sleep</span> 2s</span><br><span class="line">	start</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">	start|stop|restart|status)</span><br><span class="line">	<span class="variable">$1</span></span><br><span class="line">	;;</span><br><span class="line">	*)</span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;使用方法: <span class="variable">$0</span> &#123; start | stop | restart | status &#125;&quot;</span></span><br><span class="line">	RETVAL=1</span><br><span class="line">	;;</span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"><span class="built_in">exit</span> <span class="variable">$RETVAL</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="加入到系统启动中">加入到系统启动中</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 添加到系统启动</span><br><span class="line">update-rc.d kms defaults </span><br><span class="line">// 从系统启动中删除</span><br><span class="line">update-rc.d kms remove</span><br></pre></td></tr></table></figure>
<h5 id="启动服务">启动服务</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service kms start</span><br><span class="line">service kms stop</span><br></pre></td></tr></table></figure>
<h4 id="systemctl命令">systemctl命令</h4>
<p>​
systemd是Linux系统最新的初始化系统(init),作用是提高系统的启动速度，尽可能启动较少的进程，尽可能更多进程并发启动。systemd对应的进程管理命令是<strong>systemctl</strong>。</p>
<p>还是以kms服务脚本为例</p>
<p>新建一个<code>kms.service</code>文件，保存在
<code>/etc/systemd/system/kms.service</code>.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=kms-service</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">ExecStart=/usr/local/bin/kms</span><br><span class="line">ExecStop=/bin/kill -9 <span class="variable">$MAINPID</span></span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>
<p>可以看到service文件一般由：<strong>[Unit]</strong>、<strong>[Service]</strong>和<strong>[Install]</strong>
三部分组成</p>
<ol type="1">
<li>[Unit] 主要是对这个服务的说明，内容，
文档介绍以及对一些依赖服务定义</li>
<li>[Service]
服务的主体定义，主要定义服务的一些运行参数，及操作动作</li>
<li>[Install] 服务安装的相关设置，一般可设置为多用户的</li>
</ol>
<p><u>以下是具体参数</u></p>
<p><strong>[Unit]</strong></p>
<table>
<colgroup>
<col style="width: 17%" />
<col style="width: 82%" />
</colgroup>
<thead>
<tr class="header">
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Description</td>
<td>服务描述，作为systemctl status 命令输出的一个介绍</td>
</tr>
<tr class="even">
<td>Documentation</td>
<td>一个url 定义服务的具体介绍网址</td>
</tr>
<tr class="odd">
<td>After</td>
<td>在什么服务启动之后</td>
</tr>
<tr class="even">
<td>Before</td>
<td>在什么服务启动之前启动</td>
</tr>
<tr class="odd">
<td>Requires</td>
<td>依赖其他的单元服务，
需要与列出的服务一起激活，若任何服务无法启动，则该单元不会被激活</td>
</tr>
<tr class="even">
<td>Wants</td>
<td>比Requires依赖性弱，若其他服务没有启动成功，该服务也不受影响，只是表示一种推荐</td>
</tr>
</tbody>
</table>
<p><strong>[Service]</strong></p>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<thead>
<tr class="header">
<th>Type</th>
<th>1.simple默认参数，进程作为主进程<br/>2.forking是后台运行的形式，主进程退出，os接管子进程</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>User</td>
<td>设置服务运行的用户</td>
</tr>
<tr class="even">
<td>Group</td>
<td>设置服务运行的用户组</td>
</tr>
<tr class="odd">
<td>PIDFile</td>
<td>存放PID的文件路径,
对于type设置为<strong>forking</strong>建议使用该项</td>
</tr>
<tr class="even">
<td>ExecStart</td>
<td>服务的具体运行命令</td>
</tr>
<tr class="odd">
<td>ExecStartPre</td>
<td>指定在ExecStart<strong>前</strong>执行的自定义命令</td>
</tr>
<tr class="even">
<td>ExecStartPost</td>
<td>指定在ExecStart<strong>后</strong>执行的自定义命令</td>
</tr>
<tr class="odd">
<td>ExecReload</td>
<td>重启命令，重新加载的动作， 重新加载时执行的命令或者脚本</td>
</tr>
<tr class="even">
<td>ExecStop</td>
<td>停止命令，停止时要执行的命令或脚本</td>
</tr>
<tr class="odd">
<td>Restart</td>
<td>定义何种情况Systemd会自动重启当前服务，值：
包括<strong>always（总是重启）</strong>、<strong>no</strong>
、<strong>on-success</strong>、<strong>on-failure</strong>、<strong>on-abnormal</strong>、<strong>on-abort</strong>、<strong>on-watchdog</strong>
对于守护进程，推荐设为on-failure。对于那些允许发生错误退出的服务，可以设为on-abnormal</td>
</tr>
<tr class="even">
<td>TimeoutStartSec</td>
<td>等待启动的时间。如果守护进程服务没有在配置的时间内发送启动完成的信号，则该服务将被认为失败，
服务将退出。<br/>以秒为单位， “0”来禁用。默认为，
默认使用DefaultTimeoutStartSec=20，<br/>若使用Type=<strong>oneshot</strong>，则该模式默认情况下超时是禁用的</td>
</tr>
<tr class="odd">
<td>TimeoutStopSec</td>
<td>等待关闭的超时时间</td>
</tr>
<tr class="even">
<td>TimeoutSec</td>
<td>快速配置TimeoutStartSec和TimeoutStopSec时间</td>
</tr>
<tr class="odd">
<td>KillMode</td>
<td>control-group（默认值）：当前控制组里面的所有子进程，都会被杀掉<br/>process：只杀主进程<br/>mixed：主进程将收到
SIGTERM 信号，子进程收到 SIGKILL
信号<br/>none：没有进程会被杀掉，只是执行服务的 stop 命令。</td>
</tr>
<tr class="even">
<td>Environmen</td>
<td>指定环境变量</td>
</tr>
<tr class="odd">
<td>PrivateTmp=True</td>
<td>表示给服务分配独立的临时空间</td>
</tr>
</tbody>
</table>
<p>注意：<strong>[Service]</strong>部分的启动、重启、停止命令必须使用绝对路径，使用相对路径则会报错</p>
<p><strong>[Install]</strong></p>
<table>
<colgroup>
<col style="width: 14%" />
<col style="width: 85%" />
</colgroup>
<thead>
<tr class="header">
<th>RequiredBy</th>
<th>依赖该服务的服务列表</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>WantedBy</td>
<td>表示该服务所在的 Target， multi-user.target
可以设置为多用户模式具体参考手册systemd.unit(5)</td>
</tr>
</tbody>
</table>
<p>参考手册：http://www.jinbuguo.com/systemd/systemd.index.html</p>
<p><strong>服务状态列表：</strong></p>
<table>
<thead>
<tr class="header">
<th>loaded</th>
<th>系统服务已经初始化完成，加载过配置</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>actvie(running)</td>
<td>正常运行</td>
</tr>
<tr class="even">
<td>actvie(exited)</td>
<td>正常结束的服务</td>
</tr>
<tr class="odd">
<td>active(waitting)</td>
<td>等待其他的事件才继续处理</td>
</tr>
<tr class="even">
<td>inactive</td>
<td>服务关闭</td>
</tr>
<tr class="odd">
<td>enabled</td>
<td>服务开机启动</td>
</tr>
<tr class="even">
<td>disabled</td>
<td>服务开机不自启</td>
</tr>
<tr class="odd">
<td>static</td>
<td>服务开机启动项不可被管理</td>
</tr>
<tr class="even">
<td>falied</td>
<td>系统配置错误</td>
</tr>
</tbody>
</table>
<p><strong>管理日志：</strong></p>
<p>Systemd 统一管理所有 Unit 的启动日志。</p>
<table>
<thead>
<tr class="header">
<th>journalctl</th>
<th>命令查看所有日志(内核日志和应用日志)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>journalctl _PID=</td>
<td>查看对应pid的日志</td>
</tr>
</tbody>
</table>
<p><strong>unit管理：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 立即启动一个服务</span></span><br><span class="line">sudo systemctl start apache.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 立即停止一个服务</span></span><br><span class="line">sudo systemctl stop apache.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置开机启动</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> apache.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭开机启动</span></span><br><span class="line">sudo systemctl <span class="built_in">disable</span> apache.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启一个服务</span></span><br><span class="line">sudo systemctl restart apache.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 杀死一个服务的所有子进程</span></span><br><span class="line">sudo systemctl <span class="built_in">kill</span> apache.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新加载一个服务的配置文件</span></span><br><span class="line">sudo systemctl reload apache.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重载所有修改过的配置文件</span></span><br><span class="line">sudo systemctl daemon-reload</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>ubuntu</tag>
        <tag>service</tag>
        <tag>systemctl</tag>
      </tags>
  </entry>
  <entry>
    <title>循环神经网络介绍</title>
    <url>/p/Introduction-to-Recurren-Neural-Networks/</url>
    <content><![CDATA[<p>什么是LSTM？ <span id="more"></span></p>
<p>LSTM 即 Long Short Term
网络——一般就叫做LSTM——是一种特殊的RNN，可以学习长期依赖信息。LSTM由
<em>Hochreiter &amp; Schmidhuber</em> (1997) 提出， 并被 <em>Alex
Graves</em> 进行了改良和推广。在很多问题，LSTM
都取得了相当巨大的成功，并得到了广泛的使用。</p>
<p>LSTM 通过刻意的设计来避免长期依赖问题。记住长期的信息是 LSTM
的默认行为，而非需要付出很大代价才能获得的能力。</p>
<p>所有的
RNN都具有一种重复神经网络模块的链式的形式，在标准的RNN中，这个重复的模块只有一个非常简单的结构，例如一个
<em>tanh</em> 层。</p>
<p><img data-src="20150829181722_450.png" /></p>
<blockquote>
<p>上图即<strong>标准RNN中</strong>重复模块包含单一的层</p>
</blockquote>
<p>LSTM同样是这样的结构，但是重复的模块拥有一个不同的结构。不同于单一神经网络层，这里有四个，以一种非常特殊的方式进行交互。</p>
<p><img data-src="20150829181722_631.png" /></p>
<blockquote>
<p>上图即<strong>LSTM</strong>中的重复模块包含的四个交互的层</p>
</blockquote>
<p>我们会一步一步的剖析LSTM解析图。现在，我们先来熟悉一下途中使用的各种元素的图标。</p>
<p><img data-src="20150829181722_777.png" /></p>
<blockquote>
<p>LSTM中的图标</p>
</blockquote>
<p>在上面的图例中，每一条黑线传输着一整个向量，从一个节点的输出到其他节点的输入。粉色的圈代表
<em>pointwise</em>
(逐点的)操作，诸如向量的和，而黄色的矩阵就是学习到的神经网络层。合在一起的线表示向量的连接，分开的线表示内容被复制，然后分发到不同的位置。</p>
<h4 id="lstm核心内容">2.LSTM核心内容</h4>
<p>LSTM的关键就是细胞状态（cell），水平线在图上方贯穿运行，细胞状态类似于传送带，直接在整个链上运行，只有一些少量的线性交互，信息在上面流传保持不变会很容易。</p>
<p><img data-src="20150829181723_640.png" /></p>
<p>LSTM
有通过精心设计的称作"<strong>门</strong>"的结构来去除或者增加信息到细胞状态的能力。门是一种让信息选择式通过的方法。他们包含一个
<em>sigmoid</em> 神经网络层和一个 <em>pointwise</em> 乘法操作。</p>
<p><img data-src="20150829181723_567.png" /></p>
<p><em>sigmoid</em> 层输出 0 到 1
之间的数值，描述每个部分有多少量可以通过。0 代表"不允许任何量通过"，1
就指"允许任何量通过"。</p>
<p>LSTM有三个门，来保护和控制细胞状态。</p>
<h4 id="逐步理解lstm">3.逐步理解LSTM</h4>
<p>LSTM中第一步是决定会从细胞状态中丢弃什么信息。这个决定通过一个称为
<strong>忘记门层</strong> 的门来完成。该门会读取 \(h_{t-1}\) 和
\(x_{t}\) ，输出一个在 0 到 1 之间的数值给每个在细胞状态中的数字。1
表示"完全保留"，0 代表"完全舍弃"。</p>
<p>让我们回到 <strong>语言模型</strong>
的例子中来基于已经看到的词预测下一个词。在这个问题中，细胞状态可能包含当前
<strong>主语</strong> 的类别，因此正确的 <strong>代词</strong>
可以被选择出来。当我们看到新的 <strong>代词</strong>
可以被选择出来。当我们看到新的 <strong>代词</strong> ，我们希望忘记旧的
<strong>代词</strong>。</p>
<p><img data-src="20150829181723_259.png" /></p>
<h5 id="决定丢弃信息">3.1决定丢弃信息</h5>
<p>下一步是确定什么样的新信息被存放在细胞状态中。这里包含两部分。第一，<em>sigmoid</em>
层称 "输入门层" 决定什么值我们将要更新。然后，一个 <em>tanh</em>
层创建一个一个新的候选值向量，\(\)，会被加入到状态中。下一步，我们会将这两个信息来产生对状态的更新。</p>
<p>在我们 <strong>语言模型</strong> 的例子中，我们希望增加新的
<strong>代词</strong> 的类别到细胞状态中，来替代旧的需要忘记的
<strong>代词</strong>。</p>
<p><img data-src="20150829181723_897.png" /></p>
<h5 id="确定更新的信息">3.2确定更新的信息</h5>
<p>现在是更新旧细胞状态的时间了，\(C_{t-1}\) 更新为 \(C_{t}\)</p>
<p>我们把旧状态与 \(f_t\) 相乘，丢弃掉确定丢弃的信息，接着加上 \(i_t *
_t\) ，这就是新的候选值。</p>
<p>在 <strong>语言模型</strong>
的例子中，这就是我们实际根据前面确定的目标，丢弃 <strong>旧代词</strong>
的类别信息并添加新的信息的地方。</p>
<p><img data-src="20150829181723_883.png" /></p>
<h5 id="更新细胞状态">3.3更新细胞状态</h5>
<p>最终，我们需要确定输出什么值，这个输出将会基于我们的细胞状态，但是也是一个过滤后的版本。首先，我们运行一个
<em>sigmoid</em>
层来确定细胞状态的哪个部分将输出出去。接着，我们把细胞状态通过
<em>tanh</em> 进行处理，得到一个在 -1 到 1 之间的值，并将它和 sigmoid
门的输出相乘，最终我们仅仅会输出我们确定输出的那部分。</p>
<p>在 <strong>语言模型</strong> 的例子中，因为他就看到了一个
<strong>代词</strong> ，可能需要输出一个 <strong>代词</strong>
相关的信息。例如，可能输出是否代词是单数还是负数。如果是
<strong>动词</strong> 的话，我们也他要知道 <strong>动词</strong>
需要进行的词形变化。</p>
<p><img data-src="20150829181723_463.png" /></p>
]]></content>
      <tags>
        <tag>LSTM</tag>
      </tags>
  </entry>
  <entry>
    <title>Git常见操作</title>
    <url>/p/Git-common-operations/</url>
    <content><![CDATA[<p>本文主要介绍 Git常见操作。</p>
<span id="more"></span>
<p>几个专用名称的译名如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Workspace: 工作区</span><br><span class="line">Index / Stage: 暂存区</span><br><span class="line">Repository: 仓库区(或本地仓库)</span><br><span class="line">Remote: 远程仓库</span><br></pre></td></tr></table></figure>
<h3 id="新建代码库">新建代码库</h3>
<h4 id="在当前目录新建一个git代码库">在当前目录新建一个Git代码库</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>
<h4
id="新建一个目录并将其初始化为git代码库">新建一个目录，并将其初始化为Git代码库</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init [project-name]</span><br></pre></td></tr></table></figure>
<h4
id="下载一个项目和它的整个代码历史">下载一个项目和它的整个代码历史</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> [url]</span><br></pre></td></tr></table></figure>
<h3 id="配置">配置</h3>
<p>Git的设置文件为<code>.gitconfig</code>,它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p>
<h4 id="显示当前的git配置">显示当前的git配置</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure>
<h4 id="编辑git配置文件">编辑Git配置文件</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config -e [--global]</span><br></pre></td></tr></table></figure>
<h4 id="设置提交的代码时的用户信息">设置提交的代码时的用户信息</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config [--global] user.name <span class="string">&quot;[name]&quot;</span></span><br><span class="line">git config [--global] user.email <span class="string">&quot;[email address]&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="增加删除文件">增加删除文件</h3>
<h4 id="添加空文件夹">添加空文件夹</h4>
<p>空目录无法被提交，在空目录中随便放一个空文件即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">touch</span> build/.keep</span><br><span class="line">git add build/.keep</span><br></pre></td></tr></table></figure>
<h4 id="添加指定文件到暂存区">添加指定文件到暂存区</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add [file1] [file2]</span><br></pre></td></tr></table></figure>
<h4 id="添加指定目录到暂存区">添加指定目录到暂存区</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add [file1] [file2]</span><br></pre></td></tr></table></figure>
<h4
id="添加当前目录的所有文件到暂存区">添加当前目录的所有文件到暂存区</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>
<h4 id="添加时忽略.gitignore文件规则">添加时忽略.gitignore文件规则</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add -f [文件名称]</span><br></pre></td></tr></table></figure>
<h4 id="添加每个变化前都会要求确认">添加每个变化前，都会要求确认</h4>
<p>对于同一个文件的多处变化，可以实现多次提交</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add -p</span><br></pre></td></tr></table></figure>
<p>将文件添加到暂存区后，使用<code>git status</code>命令查看。</p>
<p>若文件出现在<code>Changes to be committed</code>这行下面，说明文件已经被放到暂存区。</p>
<p>若文件出现在<code>Changes not staged for commit</code>这行下面，说明已跟踪文件内容发生了变化，但还没有放到暂存区。</p>
<h4
id="删除工作区文件并将这次删除放入暂存区">删除工作区文件，并将这次删除放入暂存区</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">rm</span> [file1] [file2]</span><br></pre></td></tr></table></figure>
<h4
id="从暂存区撤销这次删除的文件工作区文件不改变">从暂存区撤销这次删除的文件，工作区文件不改变</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git restore --staged [file]</span><br></pre></td></tr></table></figure>
<h4 id="恢复工作区删除的文件">恢复工作区删除的文件</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git restore [file]</span><br></pre></td></tr></table></figure>
<h4
id="停止追踪指定文件但该文件会保留在工作区">停止追踪指定文件，但该文件会保留在工作区</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">rm</span> --cached [file]</span><br></pre></td></tr></table></figure>
<h4
id="改名文件并将这个改名放入暂存区">改名文件，并将这个改名放入暂存区</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">mv</span> [file-original] [file-renamed]</span><br></pre></td></tr></table></figure>
<h3 id="代码提交">代码提交</h3>
<h4 id="提交暂存区到仓库区">提交暂存区到仓库区</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -m [message]</span><br></pre></td></tr></table></figure>
<h4 id="提交暂存区的指定文件到仓库区">提交暂存区的指定文件到仓库区</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit [file1] [file2] ... -m [message]</span><br></pre></td></tr></table></figure>
<h4
id="提交工作区自上次commit之后的变化直接到仓库区">提交工作区自上次commit之后的变化，直接到仓库区</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -a</span><br></pre></td></tr></table></figure>
<h4 id="提交时显示所有diff信息">提交时显示所有diff信息</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -v </span><br></pre></td></tr></table></figure>
<h4
id="使用一次新的commit替代上一次提交">使用一次新的commit，替代上一次提交</h4>
<p>如果代码没有任何新变化，则用来改写上一次commit的提交信息</p>
<p><strong>注意：</strong>如果需要push到远程仓库，需要添加
<code>--force</code> 选项。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit --amend -m [message]</span><br></pre></td></tr></table></figure>
<h4
id="重做上一次commit并包括指定文件的新变化">重做上一次commit，并包括指定文件的新变化</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit --amend [file1] [file2]</span><br></pre></td></tr></table></figure>
<h4 id="提交一个空的commit">提交一个空的commit</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit --allow-empty -m [message]</span><br></pre></td></tr></table></figure>
<h3 id="分支">分支</h3>
<h4 id="列出所有本地分支">列出所有本地分支</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure>
<h4 id="列出所有远程分支">列出所有远程分支</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -r</span><br></pre></td></tr></table></figure>
<h4 id="列出所有本地分支和远程分支">列出所有本地分支和远程分支</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure>
<h4
id="新建一个分支但依然停留在当前分支">新建一个分支，但依然停留在当前分支</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch [branch]</span><br></pre></td></tr></table></figure>
<h4
id="新建一个分支并切换到这个分支">新建一个分支，并切换到这个分支</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -b [branch]</span><br></pre></td></tr></table></figure>
<h4 id="新建一个分支指向指定commit">新建一个分支，指向指定commit</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -b [branch] [commit]</span><br></pre></td></tr></table></figure>
<h4
id="新建一个分支与指定的远程分支建立追踪关系此时仍在原来分支">新建一个分支，与指定的远程分支建立追踪关系，此时仍在原来分支</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch --track [branch] [remote-branch]</span><br></pre></td></tr></table></figure>
<h4 id="切换到指定分支并更新工作区">切换到指定分支，并更新工作区</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout [branch]</span><br></pre></td></tr></table></figure>
<h4 id="切换到上一个分支">切换到上一个分支</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -</span><br></pre></td></tr></table></figure>
<h4
id="建立追踪关系在现有分支与指定分支之间">建立追踪关系，在现有分支与指定分支之间</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch --set-upstream [branch] [remote-branch]</span><br></pre></td></tr></table></figure>
<h4 id="合并指定分支到当前分支">合并指定分支到当前分支</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git merge [branch]</span><br></pre></td></tr></table></figure>
<h4
id="选择一个commit合并进当前分支">选择一个commit，合并进当前分支</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git cherry-pick [commit]</span><br></pre></td></tr></table></figure>
<h4 id="删除分支">删除分支</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -d [branch-name]</span><br></pre></td></tr></table></figure>
<h4 id="删除远程分支">删除远程分支</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push origin --delete [branch-name]</span><br><span class="line">git branch -dr [remote/branch]</span><br></pre></td></tr></table></figure>
<h3 id="标签">标签</h3>
<h4 id="列出所有tag">列出所有tag</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git tag</span><br></pre></td></tr></table></figure>
<h4 id="新建一个tag在当前commit">新建一个tag在当前commit</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git tag [tag]</span><br></pre></td></tr></table></figure>
<h4 id="新建一个tag在指定commit">新建一个tag在指定commit</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git tag [tag] [commit]</span><br></pre></td></tr></table></figure>
<h4 id="删除本地tag">删除本地tag</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git tag -d [tag]</span><br></pre></td></tr></table></figure>
<h4 id="删除远程tag">删除远程tag</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push origin :refs/tags/[tagName]</span><br></pre></td></tr></table></figure>
<h4 id="查看tag信息">查看tag信息</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git show [tag]</span><br></pre></td></tr></table></figure>
<h4 id="提交指定tag">提交指定tag</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push [remote] [tag]</span><br></pre></td></tr></table></figure>
<h4 id="提交所有tag">提交所有tag</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push [remote] --tags</span><br></pre></td></tr></table></figure>
<h4 id="新建一个分支指向某个tag">新建一个分支，指向某个tag</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -b [branch] [tag]</span><br></pre></td></tr></table></figure>
<h3 id="查看信息">查看信息</h3>
<h4 id="显示有变更的文件">显示有变更的文件</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>
<h4 id="以简洁的方式查看更改">以简洁的方式查看更改</h4>
<p>新添加的未跟踪文件有？？标记，新添加到暂存区中的文件有A标记，修改过的文件前面有M标记。修改过，暂存后又做了修改的文件前面有MM标记。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git status -S</span><br></pre></td></tr></table></figure>
<h4 id="显示当前分支的版本历史">显示当前分支的版本历史</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure>
<h4 id="查看日志点线图">查看日志点线图</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --oneline --graph</span><br></pre></td></tr></table></figure>
<h4 id="查找某个人的commit">查找某个人的commit</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --oneline --author=[username]</span><br></pre></td></tr></table></figure>
<h4
id="显示commit历史以及每次commit发生变更的文件">显示commit历史，以及每次commit发生变更的文件</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --<span class="built_in">stat</span></span><br></pre></td></tr></table></figure>
<h4
id="查找commit信息中是否含有某些关键字">查找commit信息中是否含有某些关键字</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --oneline --grep=[keyword]</span><br></pre></td></tr></table></figure>
<h4 id="查找某一时间段的commit">查找某一时间段的commit</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --oneline --since=<span class="string">&quot;1pm&quot;</span> --<span class="keyword">until</span>=<span class="string">&quot;4pm&quot;</span> --after=<span class="string">&quot;2021-05&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="搜索提交历史根据关键词">搜索提交历史，根据关键词</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> -S [keyword]</span><br></pre></td></tr></table></figure>
<h4
id="显示某个commit之后的所有变动其提交说明必须符合搜索条件">显示某个commit之后的所有变动，其"提交说明"必须符合搜索条件</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> [tag] HEAD --grap feature</span><br></pre></td></tr></table></figure>
<h4
id="显示某个文件的版本历史包括文件改名">显示某个文件的版本历史，包括文件改名</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --follow [file]</span><br><span class="line">git whatchanged [file]</span><br></pre></td></tr></table></figure>
<h4 id="显示指定文件夹的每一次diff">显示指定文件夹的每一次diff</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> -p [file]</span><br></pre></td></tr></table></figure>
<h4 id="显示过去五次提交">显示过去五次提交</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> -5 --pretty --oneline</span><br></pre></td></tr></table></figure>
<h4
id="显示所有提交过的用户按提交次数排序">显示所有提交过的用户，按提交次数排序</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git shortlog -sn</span><br></pre></td></tr></table></figure>
<h4
id="显示指定文件是什么人在什么时间修改过">显示指定文件是什么人在什么时间修改过</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git blame [file]</span><br></pre></td></tr></table></figure>
<h4 id="显示暂存区和工作区的差异">显示暂存区和工作区的差异</h4>
<p>此命令比较的是工作目录（workspace）中当前文件和暂存区域（staged）快照之间的差异。也就是修改之后还没有暂存起来的变化内容。</p>
<p><code>git diff</code>本身只显示<em>尚未暂存的改动</em>，而不是自上次提交以来所做的所有改动，所以有时候一下子暂存了所有更新过的文件，运行<code>git diff</code>后却什么也没有，就是这个原因。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git diff </span><br></pre></td></tr></table></figure>
<h4
id="显示暂存区和上一个commit的差异">显示暂存区和上一个commit的差异</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git diff --cached [file]</span><br><span class="line"><span class="comment">#git diff --staged [file]   #用法相同</span></span><br></pre></td></tr></table></figure>
<h4
id="显示工作区与当前分支最新commit之间的差异">显示工作区与当前分支最新commit之间的差异</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git diff HEAD</span><br></pre></td></tr></table></figure>
<h4 id="显示两次提交之间的差异">显示两次提交之间的差异</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git diff [first-branch]...[second-branch]</span><br></pre></td></tr></table></figure>
<h4 id="显示今天你写了多少行代码">显示今天你写了多少行代码</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git diff --shortstat <span class="string">&quot;@&#123;0 day ago&#125;&quot;</span></span><br></pre></td></tr></table></figure>
<h4
id="显示某次提交的元数据和内容变化">显示某次提交的元数据和内容变化</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git show [commit]</span><br></pre></td></tr></table></figure>
<h4 id="显示某次提交发生变化的文件">显示某次提交发生变化的文件</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git show --name-only [commit]</span><br></pre></td></tr></table></figure>
<h4
id="显示某次提交时某个文件的内容">显示某次提交时，某个文件的内容</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git show [commit]:[filename]</span><br></pre></td></tr></table></figure>
<h4 id="显示当前分支的最近的几次提交">显示当前分支的最近的几次提交</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure>
<h3 id="远程同步">远程同步</h3>
<h4 id="下载远程仓库的所有变动">下载远程仓库的所有变动</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git fetch [remote]</span><br></pre></td></tr></table></figure>
<h4 id="显示所有远程仓库">显示所有远程仓库</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure>
<h4 id="显示某个远程仓库的信息">显示某个远程仓库的信息</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote show [remote]</span><br></pre></td></tr></table></figure>
<h4 id="增加一个新的远程仓库并命名">增加一个新的远程仓库，并命名</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add [shortname] [url]</span><br></pre></td></tr></table></figure>
<h4
id="取回远程仓库的变化并于本地分支合并">取回远程仓库的变化，并于本地分支合并</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull [remote] [branch]</span><br></pre></td></tr></table></figure>
<h4 id="上传本地指定分支到远程仓库">上传本地指定分支到远程仓库</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push [remote] [branch]</span><br></pre></td></tr></table></figure>
<h4
id="强行推送当前分支到远程仓库即使有冲突">强行推送当前分支到远程仓库，即使有冲突</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push [remote] --force</span><br></pre></td></tr></table></figure>
<h4 id="推送所有分支到远程仓库">推送所有分支到远程仓库</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push [remote] --all</span><br></pre></td></tr></table></figure>
<h3 id="撤销">撤销</h3>
<h4 id="恢复暂存区的指定文件到工作区">恢复暂存区的指定文件到工作区</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout [file]</span><br></pre></td></tr></table></figure>
<h4
id="恢复某个commit的指定文件到暂存区和工作区">恢复某个commit的指定文件到暂存区和工作区</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout [commit] [file]</span><br></pre></td></tr></table></figure>
<h4 id="恢复暂存区的所有文件到工作区">恢复暂存区的所有文件到工作区</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout .</span><br></pre></td></tr></table></figure>
<h4
id="重置暂存区的指定文件与上一次commit保持一致但是工作区不变">重置暂存区的指定文件，与上一次commit保持一致，但是工作区不变</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset [file]</span><br></pre></td></tr></table></figure>
<h4
id="重置暂存区与工作区与上一次commit保持一致">重置暂存区与工作区，与上一次commit保持一致</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset --hard</span><br></pre></td></tr></table></figure>
<h4
id="重置当前分支的head为指定commit同时重置暂存区但工作区保持不变">重置当前分支的HEAD为指定commit，同时重置暂存区，但工作区保持不变</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset [commit]</span><br></pre></td></tr></table></figure>
<h4
id="重置当前分支的head为指定commit同时重置暂存区和工作区与指定commit一致">重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset --hard [commit]</span><br></pre></td></tr></table></figure>
<h4
id="重置当前分支的head为指定commit但工作区和暂存区保持不变">重置当前分支的HEAD为指定commit，但工作区和暂存区保持不变</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset --keep [commit]</span><br></pre></td></tr></table></figure>
<h4
id="新建一个commit用来撤销指定commit">新建一个commit，用来撤销指定commit</h4>
<p>后者的所有变化都被前者抵消，并且应用到当前分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git revert commit</span><br></pre></td></tr></table></figure>
<h4
id="暂时将为提交的变化移除稍后再移入">暂时将为提交的变化移除，稍后再移入</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git stash </span><br><span class="line">git stash pop</span><br></pre></td></tr></table></figure>
<h3 id="其他">其他</h3>
<h4 id="生成一个可供发布的压缩包">生成一个可供发布的压缩包</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git archive</span><br></pre></td></tr></table></figure>
<h4 id="在本地目录下关联远程仓库">在本地目录下关联远程仓库</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add origin git@github.com:git_username/repository_name.git</span><br></pre></td></tr></table></figure>
<h4 id="取消本地目录下关联的远程库">取消本地目录下关联的远程库：</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote remove origin</span><br></pre></td></tr></table></figure>
<h4 id="查看git-commit-历史">查看git commit 历史</h4>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure>
<h4 id="回退到某个commit版本">回退到某个commit版本</h4>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git reset --hard &lt;COMMIT_ID&gt;</span><br></pre></td></tr></table></figure>
<h4 id="查看本地分支">查看本地分支</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure>
<h4 id="切换到某个分支">切换到某个分支</h4>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git checkout &lt;本地分支名&gt;</span><br></pre></td></tr></table></figure>
<p>但是，这时候 git 可能会提示你当前处于一个“detached HEAD" 状态。因为
tag 相当于是一个快照，是不能更改它的代码的。</p>
<p>如果要在 tag 代码的基础上做修改，你需要一个分支：</p>
<h4 id="创建并切换到新分支">创建并切换到新分支</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout -b &lt;新分支&gt; &lt;本地分支&gt;</span><br></pre></td></tr></table></figure>
<h4 id="tag和branch的区别">tag和branch的区别</h4>
<p>tag就像是一个里程碑一个标志一个点，branch是一个新的征程一条线；</p>
<p>tag就是一个只读的branch，一般为每一个可发布的里程碑版本打一个tag。</p>
<p>tag就是给commit的hash校验和取的一个名字，比较直观，方便记忆和使用，和branch不是一个维度，点与线的区别.</p>
<h4 id="gitignore-编写">.gitignore 编写</h4>
<p>规范：</p>
<ol type="1">
<li>所有空行或者以#开头的行都会被Git忽略。</li>
<li>可以应用标准的glob模式匹配，他回递归地应用在整个工作区中。</li>
<li>匹配模式可以以/开头放在递归。</li>
<li>匹配模式可以以/开头结尾指定目录。</li>
<li>要忽略指定模式以外的文件或者目录，可以在模式前面加上<code>!</code>叹号取反。</li>
</ol>
<h5 id="glob模式">glob模式</h5>
<p>glob模式是指shell所使用的简化了的正则表达式。</p>
<ul>
<li>星号(*)匹配零个或多个任意字符；</li>
<li>[abc]匹配任何一个序列在方括号中的字符（要么匹配一个a，要么匹配一个b，要么匹配一个c）；</li>
<li>问号(?)只匹配一个任意字符；</li>
<li>在方括号中使用短划线分割两个字符，表示所有在这两个字符范围内的都可以匹配（比如【0-9】表示匹配所有0到9的数字）；</li>
<li>使用两个星号(**)表示匹配任意中间目录，比如<code>a/**/z</code>可以匹配<code>a/z</code>、<code>a/b/z</code>、或<code>a/b/c/z</code>等。</li>
</ul>
<h5 id="gitignore例子">.gitignore例子</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 忽略所有的.a文件</span><br><span class="line">*.a</span><br><span class="line"></span><br><span class="line"># 但跟踪所有的lib.a, 即使你在前面忽略了.a文件</span><br><span class="line">!lib.a</span><br><span class="line"></span><br><span class="line"># 只忽略当前目录的TODO文件，而不忽略subdir/TODO</span><br><span class="line">/TODO</span><br><span class="line"></span><br><span class="line"># 忽略db目录下所有后缀是 .sqlite3的文件</span><br><span class="line">/db/*.sqlite3</span><br><span class="line"></span><br><span class="line"># 忽略任何目录下名下为build的文件夹</span><br><span class="line">build/</span><br><span class="line"></span><br><span class="line"># 忽略 doc/notes.txt, 但不忽略 doc/server/arch.txt</span><br><span class="line">doc/*.txt</span><br><span class="line"></span><br><span class="line"># 忽略 doc/ 目录以及所有子目录下的 .pdf文件</span><br><span class="line">doc/**/*.pdf</span><br></pre></td></tr></table></figure>
<p>具体文件的编写可以参考：https://github.com/github/gitignore</p>
<p>一个仓库可以只有根目录下有一个.gitignore文件，它递归地应用到整个仓库。子目录下也可以有额外的.gitignore文件，这只作用于它所在的目录。</p>
<p>新增文件时，只要符合.gitignore的规定，这个文件就会被无视</p>
<h4 id="git-clean">git clean</h4>
<p><code>git clean</code>
命令用来从工作目录中删除没有被tracked的文件。</p>
<p><code>git clean</code> 经常和
<code>git reset --hard</code>一起结合使用。reset只影响被跟踪过的文件，所以需要clean来删除没有track过的文件，结合使用这两个命令能让工作目录完全回到一个指定的<code>commit</code>状态。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#显示那些文件会被删除</span></span><br><span class="line">git clean -n </span><br><span class="line"></span><br><span class="line"><span class="comment">#删除当前目录下所有没有被跟踪的文件，不会删除.gitignore文件里指定的文件夹和文件，不管这些文件有没有被跟踪过</span></span><br><span class="line">git clean -f</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除指定目录下没有被跟踪过的文件</span></span><br><span class="line">git clean -f [path]</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除当前目录下没有被跟踪过的文件和文件夹</span></span><br><span class="line">git clean -<span class="built_in">df</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#删除当前目录下所有没被跟踪过的文件，不管它是否是.gitignore文件里面指定的文件或文件夹</span></span><br><span class="line">git clean -xf</span><br></pre></td></tr></table></figure>
<p>下面的例子要删除所有工作目录下面的修改, 包括新添加的文件.
假设你已经提交了一些快照了, 而且做了一些新的开发</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset --hard</span><br><span class="line">git clean -<span class="built_in">df</span></span><br></pre></td></tr></table></figure>
<p>运行后，工作目录和缓存区回到最近一次commit时候一摸一样的状态，git
status会告诉你这是一个干净的工作目录, 又是一个新的开始了！</p>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建hexo并推送到GitHub Pages</title>
    <url>/p/build-a-hexo-blog-and-push-to-GitHub-Pages/</url>
    <content><![CDATA[<p>之前因为重装系统丢掉了已经搭建好的Hexo博客配置文件。经过这件事以后我深刻地记住了备份的重要性。趁着刚刚搭建完博客，于是写一篇文章水一下！</p>
<span id="more"></span>
<h3 id="安装git软件">安装git软件</h3>
<p>https://git-scm.com/downloads</p>
<p><img data-src="image-20200119205126173.png" style="zoom: 50%;" /></p>
<p>注意：此步需要添加git到环境变量，<del>因为写这边文章时，笔者已经安装完成了。</del></p>
<p>即最后一步添加路径时选择<code>Use Git from the Windows Command Prompt</code>，这样我们就可以直接在命令提示符里打开git了。</p>
<h3 id="安装nodejs">安装nodejs</h3>
<p><a
href="https://nodejs.org/dist/v13.6.0/node-v13.6.0-x64.msi">https://nodejs.org/dist/v13.6.0/node-v13.6.0-x64.msi</a></p>
<p><img data-src="20200119205441241.png" style="zoom:50%;" /></p>
<p>注意：此步需要添加<code>nodejs</code>到系统变量。</p>
<p>安装完毕后打开<code>cmd</code>输入<code>node -v npm -v</code>。如果显示版本号就说明安装完成了。</p>
<p><img data-src="image-20200119210346780.png" style="zoom:50%;" /></p>
<h4 id="给npm添加国内镜像源">给npm添加国内镜像源</h4>
<p>由于众所周知的原因，官方源如此缓慢，故使用阿里爸爸的源进行加速。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>
<h3 id="安装hexo">安装hexo</h3>
<p>在合适的地方新建一个文件夹，用来存放自己的博客文件。比如我的博客文件都存放在</p>
<p><code>C:\Users\wf09\Desktop\hexo</code></p>
<p>在该目录下右键点击<code>Git Bash Here</code></p>
<p><img data-src="image-20200119211049388.png" style="zoom:50%;" /></p>
<p>在git命令行下依次输入以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g             <span class="comment">#安装hexo相关组件</span></span><br><span class="line">hexo -v                             <span class="comment">#检查是否安装完成</span></span><br><span class="line">hexo init                           <span class="comment">#初始化hexo博客目录</span></span><br><span class="line">npm install                         <span class="comment">#安装相关依赖</span></span><br><span class="line">npm install hexo-server --save      <span class="comment">#安装hexo服务器模块</span></span><br></pre></td></tr></table></figure>
<p>安装完成后，输入<code>hexo s</code>命令以启动服务器，网站会在
<code>http://localhost:4000</code>下启动。在服务器启动期间，Hexo会监视文件变动并自动更新，无须重启服务器。</p>
<p>可以通过 <code>-p</code> 选项指定其他端口。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo server -p 4000</span><br></pre></td></tr></table></figure>
<p>此时打开<code>http://localhost:4000</code>就可以成功启动网站了。</p>
<h3 id="推送到github-pages">推送到Github Pages</h3>
<h4 id="链接github">链接Github</h4>
<p>右键打开<code>Git Bash</code>，输入以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;username&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;username@your.site&quot;</span></span><br></pre></td></tr></table></figure>
<p>用户名和邮件根据你注册GitHub的信息自行修改。</p>
<p>输入以下命令以生成SSH key：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;username@your.site&quot;</span></span><br></pre></td></tr></table></figure>
<p>打开<a
href="https://link.zhihu.com/?target=http%3A//github.com/">github</a>，在头像下面点击<code>settings</code>，再点击<code>SSH and GPG keys</code>，新建一个SSH，名称任意。</p>
<p><code>Git Bash</code> 中输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>
<p>将输出的内容复制到框中，点击确定保存。</p>
<p>输入以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>
<p>如果出现一个警告，输入<code>yes</code>回车并忽略他就好。</p>
<p>如果回车看到：<strong><user_name > You’ve successfully authenticated,
but GitHub does not provide shell access</strong>
。表示已成功连上<code>github</code>。</p>
<h4 id="发布网站在github-pages">发布网站在GitHub Pages</h4>
<p>打开博客根目录下的<code>_config.yml</code>文件：</p>
<p>找到以下配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repository: git@github.com:yourname/yourname.github.io</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p>默认分支是<code>master</code></p>
<p>在博客根目录下打开<code>Git Bash</code>，安装一个插件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>然后输入<code>hexo new post "article title"</code>，新建一篇文章。</p>
<p>打开你的<code>博客根目录\source\_posts</code>，会发现多了一个文件夹和一个markdown文件。文件夹用于存放图片等数据。</p>
<p>写完markdown文件后，依次输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g                   <span class="comment">#生成静态网页</span></span><br><span class="line">hexo s                   <span class="comment">#本地预览效果</span></span><br><span class="line">hexo d                   <span class="comment">#把网页推送到GitHub</span></span><br></pre></td></tr></table></figure>
<p>此时打开你的<code>github.io</code>主页就可以看到发布的文章了。</p>
]]></content>
      <tags>
        <tag>git</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu安装php指南</title>
    <url>/p/How-to-install-php-on-Ubuntu/</url>
    <content><![CDATA[<h4 id="ubuntu安装php指南">Ubuntu安装php指南</h4>
<p>由于自带的apt源中不包含php，所以在安装php之前需要给apt添加第三方源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install software-properties-common</span><br><span class="line">sudo add-apt-repository ppa:ondrej/php</span><br><span class="line"><span class="comment">#sudo add-apt-repository -r ppa:ondrej/php              #删除</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install -y php7.3</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu安装nodejs并更改npm镜像源</title>
    <url>/p/How-to-install-nodejs-and-change-npm-mirror-source-on-Ubuntu/</url>
    <content><![CDATA[<h4
id="ubuntu安装nodejs并更改npm镜像源">Ubuntu安装nodejs并更改npm镜像源</h4>
<p>由于众所周知的原因，在国内使用原有的源安装<code>nodejs</code>速度非常缓慢，故可以采用清华大学的源</p>
<h5 id="运行">运行</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -sL https://deb.nodesource.com/setup_12.x | sudo bash</span><br></pre></td></tr></table></figure>
<h5 id="编辑-etcaptsources.list.dnodesource.list">编辑
/etc/apt/sources.list.d/nodesource.list</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deb https://deb.nodesource.com/node_12.x xenial main</span><br><span class="line">deb-src https://deb.nodesource.com/node_12.x xenial main</span><br></pre></td></tr></table></figure>
<h5 id="更改为">更改为：</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/nodesource/deb_12.x xenial main</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/nodesource/deb_12.x xenial main</span><br></pre></td></tr></table></figure>
<h5 id="更新源">更新源</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get clean</span><br><span class="line">apt-get update</span><br></pre></td></tr></table></figure>
<h5 id="安装nodejs">安装nodejs</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install nodejs</span><br></pre></td></tr></table></figure>
<h5 id="查看版本">查看版本</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nodejs -v</span><br><span class="line"></span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure>
<h5 id="更换npm源">更换npm源</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>
<h5 id="验证是否成功">验证是否成功</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm config get registry</span><br></pre></td></tr></table></figure>
<h5 id="安装hexo">安装Hexo</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>
<h5 id="初始化hexo">初始化Hexo</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>
<h5 id="生成静态网页">生成静态网页</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
</search>
